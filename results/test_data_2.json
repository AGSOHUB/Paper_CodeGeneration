{
    "test_data_3_2": [
        {
            "unique_id": "a64f6f92-6321-484e-b9ad-07a512dfe53d",
            "timestamp": "2024-10-31T08:27:19.276942",
            "total time (seconds)": 4.754644155502319,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the Status Register (SR) of the USART peripheral.\n// This offset is used to access the USART_SR register from the base address of a USART peripheral.\n// The value is based on the STM32F407 reference manual, where the USART_SR register is located\n// at an offset of 0x00 from the base address of the USART peripheral.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// USART_CR1_OFFSET is the offset for the Control Register 1 of the USART peripheral.\n// This offset is used to access the USART_CR1 register from the base address of a USART peripheral.\n// The value is specific to the STM32F407 microcontroller series.\n#define USART_CR1_OFFSET ((uint32_t)0x0000000C)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n// on the STM32F407 microcontroller. This address is used to access\n// the RCC registers for configuring the clock system of the MCU.\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference\n// manual for the STM32F407, which specifies the offset for the DR register\n// within the USART peripheral's register map.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the clock is enabled by setting\n * the appropriate bit in the RCC_AHB1ENR register.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC and the offset for the AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Set the bit corresponding to GPIOA (bit 0) to enable its clock\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    for (uint32_t mask = pin_mask; mask > 1; mask >>= 1) {\n        pin_position++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n\n    // Set the mode: 0x1 for output, 0x0 for input\n    *GPIO_MODER |= (mode & 0x1) << (pin_position * 2);\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin specified by the port base address and pin number.\n * It calculates the pin position and checks the input data register (IDR) to determine if the pin is high or low.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The pin mask indicating the specific pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask & 1) == 0) {\n        pin_mask >>= 1;\n        pin_position++;\n    }\n\n    // Define the input data register (IDR) offset for the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n\n    // Read the pin state from the IDR and return 1 if high, 0 if low\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations using bitwise XOR.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *GPIO_ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "0dd92e0b-47f6-4eea-83bf-7c89f651bbd2",
            "timestamp": "2024-10-31T08:29:37.647525",
            "total time (seconds)": 124.23151469230652,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the offset for the USART_SR register.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the USART Data Register (DR) for the STM32F407 board.\n// This offset is used to access the data register of a USART peripheral.\n// The value is based on the STM32F407 reference manual.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_FLAG_TXE is a flag used to indicate that the transmit data register is empty.\n// This flag is typically used in USART communication to check if the USART is ready to send more data.\n// The value 0x00000080 is a standard value for the TXE (Transmit Data Register Empty) flag in STM32 microcontrollers.\n#define USART_FLAG_TXE ((uint32_t)0x00000080)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// The RCC_AHB1ENR register is used to enable the clock for peripherals connected to the AHB1 bus.\n// The offset is based on the STM32F407 reference manual, which specifies the memory map for the RCC registers.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral\n// The USART_BRR_OFFSET is used to calculate the address of the BRR register\n// within the USART peripheral's memory map. This offset is specific to the\n// STM32F407 microcontroller series.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Set the bit corresponding to GPIOA (bit 0) to enable its clock\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n\n    // Set the mode for the pin\n    if (mode == 1) {\n        // Set as output\n        *GPIO_MODER |= (0x1 << (pin_position * 2));\n    } else {\n        // Set as input (default is already cleared)\n    }\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin specified by the port base address and pin mask.\n * It calculates the pin position and checks the input data register (IDR) to determine if the pin is high or low.\n * \n * @param port_base_address The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t port_base_address, uint32_t pin_mask) {\n    // Calculate the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Define the input data register (IDR) offset for the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(port_base_address + 0x10);\n\n    // Read the pin state from the IDR and return 1 if high, 0 if low\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations using bitwise XOR.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *GPIO_ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "dc00b05f-371e-4021-81b1-4ab056518c32",
            "timestamp": "2024-10-31T08:32:02.885070",
            "total time (seconds)": 131.18650031089783,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the Status Register (SR) of the USART peripheral.\n// This offset is used to access the USART_SR register from the base address of a USART peripheral.\n// The value is based on the STM32F407 reference manual, where the USART_SR register is located at an offset of 0x00 from the USART base address.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_FLAG_TXE is a flag used to indicate that the USART transmit data register is empty.\n// This flag is typically used in USART status register (USART_SR) to check if the USART is ready to send more data.\n// The value 0x0080 corresponds to the TXE (Transmit Data Register Empty) flag in the USART status register.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral\n// This offset is used to calculate the address of the BRR register for a given USART instance\n// on the STM32F407 microcontroller. The value is based on the reference manual for the STM32F407.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the clock is enabled by setting\n * the appropriate bit in the RCC_AHB1ENR register.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC and the offset for the AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Set the bit 0 of RCC_AHB1ENR to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n\n    // Set the mode: 0x1 for output, 0x0 for input\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin specified by the port base address and pin mask.\n * It calculates the pin position and checks the input data register (IDR) to determine if the pin is high or low.\n * \n * @param port_base_address The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t port_base_address, uint32_t pin_mask) {\n    // Pointer to the input data register (IDR) of the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(port_base_address + 0x10);\n\n    // Calculate the pin position by finding the first set bit in the pin mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the pin state from the IDR and return 1 if high, 0 if low\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations using bitwise XOR.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *GPIO_ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "86907468-3921-4e18-b3e0-b8377767af54",
            "timestamp": "2024-10-31T08:34:22.612227",
            "total time (seconds)": 123.13480472564697,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the offset for the USART_SR register.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n// on the STM32F407 microcontroller. This address is used to access\n// the RCC registers for configuring the clock system of the MCU.\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference manual\n// for the STM32F407, which specifies the offset for the USART_DR register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_FLAG_TXE is a flag used to indicate that the USART transmit data register is empty.\n// This flag is typically used in USART status register to check if the USART is ready to send more data.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for peripherals connected to the AHB1 bus on the STM32F407 microcontroller.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC and the offset for the AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Set the bit corresponding to GPIOA (bit 0) to enable its clock\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin number from the pin mask\n    uint8_t pin_number = 0;\n    while ((pin_mask >> pin_number) != 1) {\n        pin_number++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin in the MODER register\n    *GPIO_MODER &= ~(0x3 << (pin_number * 2));\n\n    // Set the mode for the pin\n    if (mode == 1) {\n        // Set as output\n        *GPIO_MODER |= (0x1 << (pin_number * 2));\n    } else {\n        // Set as input (default is already cleared)\n    }\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin by accessing the input data register (IDR)\n * of the specified GPIO port. It calculates the bit position of the pin using a loop\n * and returns the state of the pin.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Pointer to the input data register (IDR) of the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n\n    // Calculate the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the pin state from the IDR and return it\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations using bitwise XOR.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the specified pin using XOR operation\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "15c05190-dd5f-4b76-a482-b7ef06e4df62",
            "timestamp": "2024-10-31T08:36:39.286463",
            "total time (seconds)": 2.9599416255950928,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x08)\n\n// USART_FLAG_TXE is a flag used to indicate that the transmit data register is empty.\n// This flag is typically used in USART communication to check if the USART is ready to send more data.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// USART_DR_OFFSET is the offset for the Data Register in the USART peripheral.\n// This offset is used to access the data register for reading or writing data.\n// The value is specific to the STM32F407 microcontroller series.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is based on the STM32F407 reference manual.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// USART_CR1_OFFSET is the offset for the Control Register 1 of the USART peripheral.\n// This offset is used to access the USART_CR1 register from the base address of a USART peripheral.\n// The value is specific to the STM32F407 microcontroller series.\n#define USART_CR1_OFFSET ((uint32_t)0x0000000C)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// The RCC_AHB1ENR register is used to enable the clock for peripherals connected to the AHB1 bus.\n// The offset is based on the STM32F407 reference manual, which specifies the memory map for the RCC registers.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Enable the clock for GPIOA by setting the appropriate bit in the RCC AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n\n    // Set the mode: 0x1 for output, 0x0 for input\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin specified by the port base address\n * and the pin mask. It calculates the pin position and checks the input data register\n * to determine if the pin is set high or low.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask & 1) == 0) {\n        pin_mask >>= 1;\n        pin_position++;\n    }\n\n    // Define the input data register (IDR) offset for the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n\n    // Read the pin state from the IDR and return 1 if high, 0 if low\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations using bitwise XOR.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the specified pin using XOR operation\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "fdcf7cd3-873f-40a7-affe-af8381f41495",
            "timestamp": "2024-10-31T08:38:19.896545",
            "total time (seconds)": 85.46498036384583,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// USART_FLAG_TXE is a flag used to indicate that the transmit data register is empty.\n// This flag is typically used in USART communication to check if the USART is ready to send more data.\n// The value 0x00000080 is a standard value for the TXE (Transmit Data Register Empty) flag in STM32 microcontrollers.\n#define USART_FLAG_TXE ((uint32_t)0x00000080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n// on the STM32F407 microcontroller. This address is used to access\n// the RCC registers for configuring the clock system of the MCU.\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference\n// manual for the STM32F407, which specifies the offset for the DR register\n// within the USART peripheral's register map.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the offset for the USART_SR register.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC (Reset and Clock Control) block.\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock for AHB1 peripherals.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the clock is enabled by setting\n * the appropriate bit in the RCC_AHB1ENR register.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC and the offset for the AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Set the bit 0 of RCC_AHB1ENR to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    for (uint32_t mask = pin_mask; mask > 1; mask >>= 1) {\n        pin_position++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n\n    // Set the mode: 0x1 for output, 0x0 for input\n    *GPIO_MODER |= (mode & 0x1) << (pin_position * 2);\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin by accessing the input data register (IDR)\n * of the specified GPIO port. It uses bitwise operations to determine the state of the pin.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the input data register (IDR) for the given GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the state of the pin by checking the corresponding bit in the IDR\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations by using\n * bitwise XOR to flip the pin's state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "48c9a6ed-10ff-403c-a146-3564f3805d58",
            "timestamp": "2024-10-31T08:40:54.530294",
            "total time (seconds)": 140.449565410614,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, where the BRR register is located\n// at an offset of 0x08 from the base address of the USART peripheral.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// USART_FLAG_TXE is a flag used to indicate that the USART transmit data register is empty.\n// This flag is used in the status register of the USART peripheral to check if the USART is ready to send more data.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the USART Data Register (DR) for the STM32F407 board.\n// This offset is used to access the data register of a USART peripheral.\n// The value is based on the STM32F407 reference manual.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the offset for the USART_SR register.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Enable the clock for GPIOA by setting the appropriate bit in the RCC AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n\n    // Set the mode: 0x1 for output, 0x0 for input\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin by accessing the input data register (IDR)\n * of the specified GPIO port. It uses bitwise operations to determine the state of the pin.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Pointer to the input data register (IDR) of the specified GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the state of the pin by checking the corresponding bit in the IDR\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations using bitwise XOR.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the specified pin using XOR operation\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "0ba73d62-079e-43f5-9bad-1b6f68748d38",
            "timestamp": "2024-10-31T08:43:15.080610",
            "total time (seconds)": 125.86127281188965,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// USART_FLAG_TXE is a flag used to indicate that the USART transmit data register is empty.\n// This flag is used in the status register of the USART peripheral to check if the USART is ready to send more data.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference\n// manual for the STM32F407, which specifies the offset for the DR register\n// within the USART peripheral's register map.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// The RCC_AHB1ENR register is used to enable the clock for peripherals connected to the AHB1 bus.\n// The offset is based on the STM32F407 reference manual, which specifies the memory map for the RCC registers.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the clock is enabled by setting\n * the appropriate bit in the RCC_AHB1ENR register.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC and the offset for the AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Set the bit 0 of RCC_AHB1ENR to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin number from the pin mask\n    uint8_t pin_number = 0;\n    while ((pin_mask >> pin_number) != 1) {\n        pin_number++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin in the MODER register\n    *GPIO_MODER &= ~(0x3 << (pin_number * 2));\n\n    // Set the mode for the pin\n    if (mode == 1) {\n        // Set as output\n        *GPIO_MODER |= (0x1 << (pin_number * 2));\n    } else {\n        // Set as input (default is already cleared)\n    }\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin specified by the port base address and pin mask.\n * It calculates the pin position and checks the input data register (IDR) to determine if the pin is high or low.\n * \n * @param port_base_address The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t port_base_address, uint32_t pin_mask) {\n    // Pointer to the input data register (IDR) of the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(port_base_address + 0x10);\n\n    // Calculate the pin position by finding the first set bit in the pin mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the pin state from the IDR and return 1 if high, 0 if low\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations using bitwise XOR.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14); // ODR offset is 0x14\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "a8d79a72-1378-4a2b-93f9-6e378d0dceee",
            "timestamp": "2024-10-31T08:45:40.213980",
            "total time (seconds)": 4.094818592071533,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x08)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready to accept new data for transmission.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference manual\n// for the STM32F407 series, which specifies the offset for the USART_DR register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The USART_CR1 register is responsible for configuring various settings of the USART peripheral,\n// such as enabling the USART, setting the word length, parity control, and more.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the clock is enabled by setting\n * the appropriate bit in the RCC_AHB1ENR register.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC and the offset for the AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Set the bit 0 of RCC_AHB1ENR to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n\n    // Set the mode: 0x1 for output, 0x0 for input\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Pointer to the Output Data Register (ODR) of the specified GPIO port\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Calculate the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    for (uint32_t mask = pin_mask; mask > 1; mask >>= 1) {\n        pin_position++;\n    }\n\n    // Write the value to the specified pin using bitwise operations\n    if (value) {\n        // Set the pin: Use bitwise OR to set the bit at pin_position\n        *GPIO_ODR |= (1 << pin_position);\n    } else {\n        // Reset the pin: Use bitwise AND with NOT to clear the bit at pin_position\n        *GPIO_ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin by accessing the input data register (IDR)\n * of the specified GPIO port. It calculates the bit position of the pin using a loop\n * to ensure accurate pin configuration.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask representing the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Pointer to the input data register (IDR) of the specified GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n\n    // Calculate the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the pin state from the IDR and return it\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations by using\n * bitwise XOR to flip the pin's state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the specified pin by XORing the ODR with the pin mask\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "eb83ef8e-48c3-4bf4-94b7-3f9ac110cfcf",
            "timestamp": "2024-10-31T08:47:42.593295",
            "total time (seconds)": 108.00972247123718,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC (Reset and Clock Control) block.\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock for AHB1 peripherals.\n// The value is specific to the STM32F407 microcontroller.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral\n// This offset is used to calculate the address of the BRR register for a given USART instance\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is based on the STM32F407 reference manual.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready to accept new data for transmission.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the USART Data Register (DR) for the STM32F407 board.\n// This offset is used to access the data register of a USART peripheral.\n// The value is based on the STM32F407 reference manual.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Enable the clock for GPIOA by setting the appropriate bit in the RCC AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n\n    // Set the mode: 0x1 for output, 0x0 for input\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin by accessing the input data register (IDR)\n * of the specified GPIO port. It calculates the bit position of the pin using a loop\n * to ensure accurate pin configuration.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask representing the pin to read (e.g., 1 << 5 for pin 5).\n * \n * @return 1 if the pin is set (high), 0 if the pin is reset (low).\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Pointer to the input data register (IDR) of the specified GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n\n    // Calculate the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the pin state from the IDR and return it\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It uses bitwise operations to ensure atomic\n * and reliable toggling of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "b5f40e79-1b84-47a5-9595-157eddc15057",
            "timestamp": "2024-10-31T08:49:59.613884",
            "total time (seconds)": 122.31616568565369,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// The USART2 peripheral is used for serial communication and is mapped to a specific memory address.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// The RCC_AHB1ENR register is used to enable the clock for peripherals connected to the AHB1 bus.\n// The offset is based on the STM32F407 reference manual, which specifies the memory map for the RCC registers.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral\n// This offset is used to calculate the address of the BRR register for a given USART instance\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the offset for the USART_SR register.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// USART_FLAG_TXE is a flag used to indicate that the USART transmit data register is empty.\n// This flag is typically used in USART status register to check if the USART is ready to send more data.\n// The value 0x0080 corresponds to the bit position of the TXE flag in the USART status register.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference manual\n// which specifies the offset for the USART_DR register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the clock is enabled by setting\n * the appropriate bit in the register.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Set the bit corresponding to GPIOA (bit 0) to enable its clock\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n\n    // Set the mode: 0x1 for output, 0x0 for input\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin by accessing the input data register (IDR)\n * of the specified GPIO port. It uses bitwise operations to determine the state of the pin.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the position of the pin by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Define a pointer to the input data register (IDR) of the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n\n    // Read the state of the pin by checking the corresponding bit in the IDR\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations using bitwise XOR.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the specified pin using XOR operation\n    *GPIO_ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "95a7866b-81ad-46cf-ad74-d90c93555ad0",
            "timestamp": "2024-10-31T08:51:48.016390",
            "total time (seconds)": 94.08496475219727,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 microcontroller.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// USART_BRR_OFFSET is the offset for the Baud Rate Register in the USART peripheral.\n// This offset is used to calculate the address of the Baud Rate Register for a specific USART instance.\n// The value is based on the STM32F407 reference manual.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the offset for the USART_SR register.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be sent. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference manual.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Enable the clock for GPIOA by setting the appropriate bit in the RCC AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);  // Set bit 0 to enable GPIOA clock\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin number from the pin mask\n    uint8_t pin_number = 0;\n    for (uint32_t mask = pin_mask; mask > 1; mask >>= 1) {\n        pin_number++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin in the MODER register\n    *GPIO_MODER &= ~(0x3 << (pin_number * 2));\n\n    // Set the mode for the pin (0x1 for output, 0x0 for input)\n    *GPIO_MODER |= (mode << (pin_number * 2));\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin specified by the port base address and pin mask.\n * It calculates the pin position and checks the input data register (IDR) to determine if the pin is high or low.\n * \n * @param port_base_address The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t port_base_address, uint32_t pin_mask) {\n    // Calculate the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Define the input data register (IDR) offset for the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(port_base_address + 0x10);\n\n    // Read the pin state from the IDR and return 1 if high, 0 if low\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations using bitwise XOR.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "e6cffd53-33b3-4bdf-b7b6-2a344bd58c33",
            "timestamp": "2024-10-31T08:53:22.522167",
            "total time (seconds)": 79.18728494644165,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC (Reset and Clock Control) block.\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock for AHB1 peripherals.\n// The offset value is based on the STM32F407 reference manual.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, where the BRR register is located\n// at an offset of 0x08 from the base address of the USART peripheral.\n#define USART_BRR_OFFSET ((uint32_t)0x08)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, where the USART_SR register is located at an offset of 0x00 from the USART base address.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// USART_FLAG_TXE is a flag used to indicate that the transmit data register is empty.\n// This flag is typically used in USART communication to check if the USART is ready to send more data.\n// The value 0x00000080 is a standard value for the TXE (Transmit Data Register Empty) flag in STM32 microcontrollers.\n#define USART_FLAG_TXE ((uint32_t)0x00000080)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// USART_DR_OFFSET is the offset for the Data Register in the USART peripheral.\n// This offset is used to access the data register for reading or writing data.\n// The value is specific to the STM32F407 microcontroller series.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_CR1_OFFSET is the offset for the Control Register 1 of the USART peripheral.\n// This offset is used to access the USART_CR1 register from the base address of a USART peripheral.\n// The value is specific to the STM32F407 microcontroller series.\n#define USART_CR1_OFFSET ((uint32_t)0x0000000C)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the clock is enabled by setting\n * the appropriate bit in the RCC_AHB1ENR register.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC and the offset for the AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Set the bit 0 of RCC_AHB1ENR to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bit mask for the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position from the pin mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n\n    // Set the mode for the pin\n    if (mode == 1) {\n        // Set as output\n        *GPIO_MODER |= (0x1 << (pin_position * 2));\n    } else {\n        // Set as input (default is already 0, so no need to set)\n    }\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin specified by the port base address\n * and the pin mask. It calculates the pin position and checks the input data register\n * to determine if the pin is set high or low.\n * \n * @param port_base_address The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t port_base_address, uint32_t pin_mask) {\n    // Calculate the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Define the input data register (IDR) offset for the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(port_base_address + 0x10);\n\n    // Read the pin state from the IDR and return 1 if high, 0 if low\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations by using\n * bitwise XOR to flip the pin's state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the specified pin by XORing the ODR with the pin mask\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "73d49e6d-2e44-4563-88d6-35b7b708f229",
            "timestamp": "2024-10-31T08:55:10.396041",
            "total time (seconds)": 93.43576788902283,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for peripherals connected to the AHB1 bus on the STM32F407 microcontroller.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the offset for the USART_SR register.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// USART_FLAG_TXE is a flag used to indicate that the transmit data register is empty.\n// This flag is typically used in USART communication to check if the USART is ready to send more data.\n// The value 0x00000080 is a standard value for the TXE (Transmit Data Register Empty) flag in STM32 microcontrollers.\n#define USART_FLAG_TXE ((uint32_t)0x00000080)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n// on the STM32F407 microcontroller. This address is used to access\n// the RCC registers for configuring the clock system of the MCU.\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the USART Data Register (DR) for the STM32F407 board.\n// This offset is used to access the data register of a USART peripheral.\n// The value is based on the STM32F407 reference manual.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_CR1_OFFSET is the offset for the Control Register 1 of the USART peripheral.\n// This offset is used to access the USART_CR1 register from the base address of a USART peripheral.\n// The value is specific to the STM32F407 microcontroller series.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the clock is enabled by setting\n * the appropriate bit in the RCC_AHB1ENR register.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC and the offset for the AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Enable the clock for GPIOA by setting the 0th bit of the RCC_AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin number from the pin mask\n    uint8_t pin_number = 0;\n    for (uint32_t mask = pin_mask; mask > 1; mask >>= 1) {\n        pin_number++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin in the MODER register\n    *GPIO_MODER &= ~(0x3 << (pin_number * 2));\n\n    // Set the mode for the pin\n    if (mode == 1) {\n        // Set as output\n        *GPIO_MODER |= (0x1 << (pin_number * 2));\n    } else {\n        // Set as input (default is already cleared)\n    }\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin by accessing the input data register (IDR)\n * of the specified GPIO port. It calculates the bit position of the pin using a loop\n * to ensure accurate pin configuration.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask representing the pin to read (e.g., 1 << 5 for pin 5).\n * \n * @return 1 if the pin is set (high), 0 if the pin is reset (low).\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Pointer to the input data register (IDR) of the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n\n    // Calculate the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the pin state from the IDR and return it\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations using bitwise XOR.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14); // ODR offset is 0x14\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "298cbfbf-1bea-41dd-976d-5efb9fa0969a",
            "timestamp": "2024-10-31T08:58:18.903394",
            "total time (seconds)": 174.25287866592407,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC (Reset and Clock Control) block.\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock for AHB1 peripherals.\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// For STM32F407, the USART status register offset is 0x00.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// USART_FLAG_TXE is a flag used to indicate that the USART transmit data register is empty.\n// This flag is used in the status register of the USART peripheral to check if the USART is ready to send more data.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// USART_DR_OFFSET is the offset for the Data Register in the USART peripheral.\n// This offset is used to access the data register for reading or writing data.\n// The value is specific to the STM32F407 microcontroller series.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the clock is enabled by setting\n * the appropriate bit in the RCC_AHB1ENR register.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC and the offset for the AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Set the bit 0 of RCC_AHB1ENR to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin number from the pin mask\n    uint8_t pin_number = 0;\n    while ((pin_mask >> pin_number) != 1) {\n        pin_number++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin in the MODER register\n    *GPIO_MODER &= ~(0x3 << (pin_number * 2));\n\n    // Set the mode for the pin (0x1 for output, 0x0 for input)\n    *GPIO_MODER |= (mode << (pin_number * 2));\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin specified by the port base address and pin mask.\n * It calculates the pin position and checks the input data register (IDR) to determine if the pin is high or low.\n * \n * @param port_base_address The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t port_base_address, uint32_t pin_mask) {\n    // Pointer to the input data register (IDR) of the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(port_base_address + 0x10);\n\n    // Calculate the pin position by finding the first set bit in the pin mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the pin state from the IDR and return 1 if high, 0 if low\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations using bitwise XOR.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *GPIO_ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "ed5a447b-b813-4b5a-9fcb-76e9720a4848",
            "timestamp": "2024-10-31T09:00:26.098791",
            "total time (seconds)": 112.37904191017151,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// The RCC_AHB1ENR register is used to enable the clock for peripherals connected to the AHB1 bus.\n// The offset is based on the STM32F407 reference manual, which specifies the memory map for the RCC registers.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the offset for the USART_SR register.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference\n// manual for the STM32F407 series, which specifies the offset for the\n// USART_DR register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Enable the clock for GPIOA by setting the appropriate bit in the RCC AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n\n    // Set the mode: 0x1 for output, 0x0 for input\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin specified by the port base address and pin mask.\n * It calculates the pin position and checks the input data register (IDR) to determine if the pin is high or low.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Define the input data register (IDR) offset for the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n\n    // Read the pin state from the IDR and return 1 if high, 0 if low\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations by using\n * bitwise XOR to flip the pin's state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "a220fe01-59f9-4584-b4f2-aecf5e6a7be3",
            "timestamp": "2024-10-31T09:03:02.688892",
            "total time (seconds)": 138.74278855323792,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// The RCC_AHB1ENR register is used to enable the clock for peripherals connected to the AHB1 bus.\n// The offset is based on the STM32F407 reference manual, which specifies the memory map for the RCC registers.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the offset for the Status Register (SR) of the USART peripheral.\n// This offset is used to access the USART_SR register from the base address of a USART peripheral.\n// The value is based on the STM32F407 reference manual, where the USART_SR register is located\n// at an offset of 0x00 from the base address of the USART peripheral.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready to accept new data for transmission.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference\n// manual for the STM32F407, which specifies the offset for the DR register\n// within the USART peripheral's register map.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC and the offset for the AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Set the bit corresponding to GPIOA (bit 0) to enable its clock\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n\n    // Set the mode: 0x1 for output, 0x0 for input\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin: Use bitwise OR to set the specific bit\n        *ODR |= (1 << pin_position);\n    } else {\n        // Reset the pin: Use bitwise AND with NOT to clear the specific bit\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin specified by the port base address and pin mask.\n * It calculates the pin position and checks the input data register (IDR) to determine if the pin is high or low.\n * \n * @param port_base_address The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t port_base_address, uint32_t pin_mask) {\n    // Calculate the pin position by finding the first set bit in the pin mask\n    uint32_t pin_position = 0;\n    while ((pin_mask & 1) == 0) {\n        pin_mask >>= 1;\n        pin_position++;\n    }\n\n    // Define the input data register (IDR) offset for the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(port_base_address + 0x10);\n\n    // Read the IDR and check if the specific pin is set\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations using bitwise XOR.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "69fe166f-b09c-429c-b717-1941ef241f45",
            "timestamp": "2024-10-31T09:04:48.452864",
            "total time (seconds)": 88.88070249557495,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral\n// This offset is used to calculate the address of the BRR register for a given USART instance\n// on the STM32F407 microcontroller. The value is based on the reference manual for the STM32F407.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the offset for the USART_SR register.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// USART_FLAG_TXE is a flag used to indicate that the transmit data register is empty.\n// This flag is typically used in USART communication to check if the USART is ready to send more data.\n// The value 0x00000080 is used based on the STM32F407 reference manual, where the TXE flag is the 7th bit in the USART_SR register.\n#define USART_FLAG_TXE ((uint32_t)0x00000080)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference manual.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC and the offset for the AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Set the bit corresponding to GPIOA (bit 0) to enable its clock\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin number from the pin mask\n    uint8_t pin_number = 0;\n    for (uint32_t mask = pin_mask; mask > 1; mask >>= 1) {\n        pin_number++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin in the MODER register\n    *GPIO_MODER &= ~(0x3 << (pin_number * 2));\n\n    // Set the mode for the pin\n    if (mode == 1) {\n        // Set as output\n        *GPIO_MODER |= (0x1 << (pin_number * 2));\n    } else {\n        // Set as input (default is already 0, so no need to set)\n    }\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    for (uint32_t mask = pin_mask; mask > 1; mask >>= 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin specified by the port base address and pin mask.\n * It calculates the pin position and checks the input data register (IDR) to determine if the pin is high or low.\n * \n * @param port_base_address The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t port_base_address, uint32_t pin_mask) {\n    // Calculate the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask & 1) == 0) {\n        pin_mask >>= 1;\n        pin_position++;\n    }\n\n    // Define the input data register (IDR) offset for the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(port_base_address + 0x10);\n\n    // Read the pin state from the IDR and return 1 if high, 0 if low\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations using bitwise XOR.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "d92e3856-afb4-4ac5-8330-bc6e77c7bfcc",
            "timestamp": "2024-10-31T09:06:24.384578",
            "total time (seconds)": 77.57586860656738,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral\n// This offset is used to calculate the address of the BRR register for a given USART instance\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is based on the STM32F407 reference manual.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// USART_FLAG_TXE is a flag used to indicate that the USART transmit data register is empty.\n// This flag is typically used in USART status register (USART_SR) to check if the USART is ready to send more data.\n// The value 0x0080 corresponds to the bit position of the TXE flag in the USART status register.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the clock is enabled by setting\n * the appropriate bit in the RCC_AHB1ENR register.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC and the offset for the AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Set the bit 0 of RCC_AHB1ENR to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin number from the pin mask\n    uint8_t pin_number = 0;\n    while ((pin_mask >> pin_number) != 1) {\n        pin_number++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin in the MODER register\n    *GPIO_MODER &= ~(0x3 << (pin_number * 2));\n\n    // Set the mode for the pin\n    if (mode == 1) {\n        // Set as output\n        *GPIO_MODER |= (0x1 << (pin_number * 2));\n    } else {\n        // Set as input (default is already cleared)\n    }\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin by accessing the input data register (IDR)\n * of the specified GPIO port. It calculates the bit position of the pin using a loop\n * to ensure accurate pin configuration.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask representing the pin to read (e.g., 1 << 5 for pin 5).\n * \n * @return 1 if the pin is set (high), 0 if the pin is reset (low).\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Pointer to the input data register (IDR) of the specified GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n\n    // Calculate the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the pin state from the IDR and return it\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations using bitwise XOR.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *GPIO_ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "ae97b464-2019-4821-bbbf-25d6a614d93c",
            "timestamp": "2024-10-31T09:08:52.046576",
            "total time (seconds)": 130.485933303833,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, where the BRR register is located\n// at an offset of 0x08 from the base address of the USART peripheral.\n#define USART_BRR_OFFSET ((uint32_t)0x08)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// For STM32F407, the USART status register offset is 0x00.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready to accept new data for transmission. It is a part of the USART\n// status register (USART_SR) and is typically used in USART communication\n// to check if the transmitter is ready to send the next byte of data.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// RCC_BASE is the base address for the Reset and Clock Control (RCC) registers\n// on the STM32F407 microcontroller. This address is used to access the RCC\n// registers for configuring the clock system of the microcontroller.\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// USART_DR_OFFSET is the offset for the Data Register in the USART peripheral.\n// This offset is used to access the data register for reading or writing data.\n// The value is specific to the STM32F407 microcontroller series.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_CR1_OFFSET is the offset for the Control Register 1 of the USART peripheral.\n// This offset is used to access the USART_CR1 register from the base address of a USART peripheral.\n// The value is specific to the STM32F407 microcontroller series.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the clock is enabled by setting\n * the appropriate bit in the RCC_AHB1ENR register.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC and the offset for the AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Set the bit 0 of RCC_AHB1ENR to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin number from the pin mask\n    uint8_t pin_number = 0;\n    while ((pin_mask >> pin_number) != 1) {\n        pin_number++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin in the MODER register\n    *GPIO_MODER &= ~(0x3 << (pin_number * 2));\n\n    // Set the mode for the pin\n    if (mode == 1) {\n        // Set as output\n        *GPIO_MODER |= (0x1 << (pin_number * 2));\n    } else {\n        // Set as input (default is already cleared)\n    }\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin by accessing the input data register (IDR)\n * of the specified GPIO port. It uses bitwise operations to isolate the state of the desired pin.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the input data register (IDR) for the given GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the state of the pin by checking the corresponding bit in the IDR\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations using bitwise XOR.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "358d10d0-48f8-4f58-a3a6-bfda0834bc8b",
            "timestamp": "2024-10-31T09:10:31.275797",
            "total time (seconds)": 80.4797625541687,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral\n// This offset is used to calculate the address of the BRR register for a given USART instance\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the offset for the Status Register (SR) of the USART peripheral.\n// This offset is used to access the USART_SR register relative to the base address of a USART peripheral.\n// The value is based on the STM32F407 reference manual, where the USART_SR register is located at an offset of 0x00 from the USART base address.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// USART_DR_OFFSET is the offset for the Data Register in the USART peripheral.\n// This offset is used to access the data register for reading or writing data.\n// The value is specific to the STM32F407 microcontroller series.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The USART_CR1 register is used to configure various settings of the USART, such as enabling the USART, setting the word length, parity, etc.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the clock is enabled by setting\n * the appropriate bit in the RCC_AHB1ENR register.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC and the offset for the AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Set the bit 0 of RCC_AHB1ENR to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    for (uint32_t mask = pin_mask; mask > 1; mask >>= 1) {\n        pin_position++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n\n    // Set the mode (0 for input, 1 for output) at the pin position\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin by accessing the input data register (IDR)\n * of the specified GPIO port. It calculates the bit position of the pin using a loop\n * and returns the state of the pin.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Pointer to the input data register (IDR) of the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n\n    // Calculate the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the pin state from the IDR and return it\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations using bitwise XOR.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the specified pin using XOR operation\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "a7c7ccda-e584-462e-baf2-beac8a0647ba",
            "timestamp": "2024-10-31T09:14:33.039280",
            "total time (seconds)": 223.84415364265442,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 microcontroller.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the offset for the USART_SR register.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// USART_FLAG_TXE is a flag used to indicate that the USART transmit data register is empty.\n// This flag is typically used in USART status register (USART_SR) to check if the USART is ready to send more data.\n// The value 0x0080 corresponds to the bit position of the TXE flag in the USART status register.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference\n// manual for the STM32F407 series, which specifies the offset for the DR\n// register within the USART peripheral's register map.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Enable the clock for GPIOA by setting the appropriate bit in the RCC AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);  // Set bit 0 to enable GPIOA clock\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n\n    // Set the mode: 0x1 for output, 0x0 for input\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin specified by the port base address\n * and the pin mask. It calculates the pin position and checks the input data register\n * to determine if the pin is set high or low.\n * \n * @param port_base_address The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t port_base_address, uint32_t pin_mask) {\n    // Calculate the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Define the input data register (IDR) offset for the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(port_base_address + 0x10);\n\n    // Read the pin state from the IDR and return 1 if high, 0 if low\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations using bitwise XOR.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14); // ODR offset is 0x14\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "f4a1fd58-c0ee-4aa9-9902-b3b9658bdef1",
            "timestamp": "2024-10-31T09:17:02.195208",
            "total time (seconds)": 132.3899462223053,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC (Reset and Clock Control) block.\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock for AHB1 peripherals.\n// The value is specific to the STM32F407 microcontroller.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the offset for the USART_SR register.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready to accept new data for transmission.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference\n// manual for the STM32F407, which specifies the offset for the DR register\n// within the USART peripheral's register map.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Enable the clock for GPIOA by setting the appropriate bit in the RCC AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);  // Set bit 0 to enable GPIOA clock\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin number from the pin mask\n    uint8_t pin_number = 0;\n    while ((pin_mask >> pin_number) != 1) {\n        pin_number++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin in the MODER register\n    *GPIO_MODER &= ~(0x3 << (pin_number * 2));\n\n    // Set the mode for the pin\n    if (mode == 1) {\n        // Set as output\n        *GPIO_MODER |= (0x1 << (pin_number * 2));\n    } else {\n        // Set as input (default is already cleared)\n    }\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin specified by the port base address\n * and the pin mask. It calculates the pin position and checks the input data register\n * to determine if the pin is set high or low.\n * \n * @param port_base_address The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t port_base_address, uint32_t pin_mask) {\n    // Pointer to the input data register (IDR) of the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(port_base_address + 0x10);\n\n    // Calculate the pin position by finding the first set bit in the pin mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the pin state from the IDR and return 1 if high, 0 if low\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations using bitwise XOR.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14); // ODR offset is 0x14\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "4bb32667-9458-482c-99eb-9582be87758b",
            "timestamp": "2024-10-31T09:18:46.237787",
            "total time (seconds)": 86.42736005783081,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x08)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is based on the STM32F407 reference manual.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for the next byte to be sent. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the Data Register (DR) of the USART peripheral\n// on the STM32F407 board. This offset is used to access the data register\n// for reading and writing data to the USART peripheral.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_CR1_OFFSET is the offset for the Control Register 1 of the USART peripheral.\n// This offset is used to access the USART_CR1 register from the base address of a USART peripheral.\n// The value is specific to the STM32F407 microcontroller series.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Enable the clock for GPIOA by setting the appropriate bit in the RCC AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);  // Set bit 0 to enable GPIOA clock\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n\n    // Set the mode: 0x1 for output, 0x0 for input\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin by accessing the input data register (IDR)\n * of the specified GPIO port. It calculates the bit position of the pin using a loop\n * and returns the state of the pin.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Pointer to the input data register (IDR) of the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n\n    // Calculate the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the pin state from the IDR and return it\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations using bitwise XOR.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "b1dbb5ed-b5fd-4b6b-b9b2-a89e9bf3607e",
            "timestamp": "2024-10-31T09:21:10.345075",
            "total time (seconds)": 127.3823070526123,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral\n// This offset is used to calculate the address of the BRR register for a given USART instance\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the offset for the USART_SR register.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// USART_FLAG_TXE is a flag used to indicate that the USART transmit data register is empty.\n// This flag is typically used in USART status register (USART_SR) to check if the USART is ready to send more data.\n// The value 0x0080 corresponds to the TXE (Transmit Data Register Empty) bit in the USART_SR register.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n// on the STM32F407 microcontroller. This address is used to access\n// the RCC registers for configuring the clock system of the MCU.\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Enable the clock for GPIOA by setting the appropriate bit in the RCC AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);  // Set bit 0 to enable GPIOA clock\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin number from the pin mask\n    uint8_t pin_number = 0;\n    for (uint32_t mask = pin_mask; mask > 1; mask >>= 1) {\n        pin_number++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin in the MODER register\n    *GPIO_MODER &= ~(0x3 << (pin_number * 2));\n\n    // Set the mode for the pin (0x1 for output, 0x0 for input)\n    *GPIO_MODER |= (mode << (pin_number * 2));\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin by accessing the input data register (IDR)\n * of the specified GPIO port. It calculates the bit position of the pin using a loop\n * and returns the state of the pin.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Pointer to the input data register (IDR) of the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n\n    // Calculate the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the pin state from the IDR and return it\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations using bitwise XOR.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *GPIO_ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "9fc0220e-d4f5-49dd-a7f1-201450eb85c0",
            "timestamp": "2024-10-31T09:23:38.022284",
            "total time (seconds)": 130.35666942596436,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC (Reset and Clock Control) block.\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock for AHB1 peripherals.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// USART_BRR_OFFSET is the offset for the Baud Rate Register in the USART peripheral.\n// This offset is used to calculate the address of the Baud Rate Register for a specific USART instance.\n// The value is based on the STM32F407 reference manual.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the offset for the USART_SR register.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written to it. It is a part of the USART status register (SR).\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference\n// manual for the STM32F407, which specifies the offset for the DR register\n// within the USART peripheral's register map.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the clock is enabled by setting\n * the appropriate bit in the RCC_AHB1ENR register.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC and the offset for the AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Set the bit 0 of RCC_AHB1ENR to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin number from the pin mask\n    uint8_t pin_number = 0;\n    for (uint32_t mask = pin_mask; mask > 1; mask >>= 1) {\n        pin_number++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin number\n    *GPIO_MODER &= ~(0x3 << (pin_number * 2));\n\n    // Set the mode for the pin\n    if (mode == 1) {\n        // Set as output\n        *GPIO_MODER |= (0x1 << (pin_number * 2));\n    } else {\n        // Set as input (default is already cleared)\n    }\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin specified by the port base address and pin mask.\n * It calculates the pin position and checks the input data register (IDR) to determine if the pin is high or low.\n * \n * @param port_base_address The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t port_base_address, uint32_t pin_mask) {\n    // Calculate the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Define the input data register (IDR) offset for the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(port_base_address + 0x10);\n\n    // Read the pin state from the IDR and return 1 if high, 0 if low\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations using bitwise XOR.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the specified pin using XOR operation\n    *GPIO_ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "26bff42e-7502-4f68-b99c-eac29aee2cd3",
            "timestamp": "2024-10-31T09:26:20.431445",
            "total time (seconds)": 144.73701000213623,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, where the BRR register is located\n// at an offset of 0x08 from the base address of the USART peripheral.\n#define USART_BRR_OFFSET ((uint32_t)0x08)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the offset for the USART_SR register.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written to it. It is a part of the USART status register (SR).\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// RCC_BASE is the base address for the Reset and Clock Control (RCC) registers\n// on the STM32F407 microcontroller. This address is used to access the RCC\n// registers for configuring the clock system of the microcontroller.\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// USART_DR_OFFSET is the offset for the Data Register in the USART peripheral.\n// This offset is used to access the data register for reading or writing data.\n// The value is specific to the STM32F407 microcontroller series.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Enable the clock for GPIOA by setting the appropriate bit in the RCC AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n\n    // Set the mode: 0x1 for output, 0x0 for input\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin specified by the port base address\n * and the pin mask. It calculates the pin position and checks the input data register\n * to determine if the pin is set high or low.\n * \n * @param port_base_address The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t port_base_address, uint32_t pin_mask) {\n    // Pointer to the input data register (IDR) of the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(port_base_address + 0x10);\n\n    // Calculate the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the pin state from the IDR and return 1 if high, 0 if low\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations using bitwise XOR.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the specified pin by XORing the ODR with the pin mask\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "06725488-c50b-48c1-8263-f4132a28ff6d",
            "timestamp": "2024-10-31T09:29:12.583559",
            "total time (seconds)": 154.5821397304535,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC (Reset and Clock Control) module.\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock for AHB1 peripherals.\n// The value is specific to the STM32F407 microcontroller.\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x08)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// USART_FLAG_TXE is a flag used to indicate that the transmit data register is empty.\n// This flag is typically used in USART communication to check if the USART is ready to send more data.\n// The value 0x00000080 is used to represent this flag in the status register.\n#define USART_FLAG_TXE ((uint32_t)0x00000080)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference\n// manual for the STM32F407, which specifies the offset for the DR register\n// within the USART peripheral's register map.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for peripherals connected to the AHB1 bus on the STM32F407 microcontroller.\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the clock is enabled by setting\n * the appropriate bit in the RCC_AHB1ENR register.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC and the offset for the AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Set the bit 0 of RCC_AHB1ENR to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    for (uint32_t mask = pin_mask; mask > 1; mask >>= 1) {\n        pin_position++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n\n    // Set the mode: 0x1 for output, 0x0 for input\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the input data register (IDR) of a specified GPIO port\n * and checks the state of a specific pin. It returns 1 if the pin is high, \n * and 0 if the pin is low.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to read (e.g., 1 << 5 for pin 5).\n * @return int 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the position of the pin by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Define a pointer to the input data register (IDR) of the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n\n    // Read the IDR and check the state of the specified pin\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations using bitwise XOR.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "da98748a-8254-4cdc-bb7c-229a5b3ea852",
            "timestamp": "2024-10-31T09:31:06.348158",
            "total time (seconds)": 94.36283707618713,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 microcontroller.\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the offset for the BRR register.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for the next byte to be sent. It is a part of the USART status register (SR).\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference\n// manual for the STM32F407, which specifies the offset for the DR register\n// within the USART peripheral's register map.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC (Reset and Clock Control) block.\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock for AHB1 peripherals.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the clock is enabled by setting\n * the appropriate bit in the RCC_AHB1ENR register.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC and the offset for the AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Set the bit 0 of RCC_AHB1ENR to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin number from the pin mask\n    uint8_t pin_number = 0;\n    for (uint32_t mask = pin_mask; mask > 1; mask >>= 1) {\n        pin_number++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin in the MODER register\n    *GPIO_MODER &= ~(0x3 << (pin_number * 2));\n\n    // Set the mode for the pin (0x1 for output, 0x0 for input)\n    *GPIO_MODER |= (mode << (pin_number * 2));\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin specified by the port base address and pin mask.\n * It calculates the pin position and checks the input data register (IDR) to determine if the pin is high or low.\n * \n * @param port_base_address The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t port_base_address, uint32_t pin_mask) {\n    // Pointer to the input data register (IDR) of the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(port_base_address + 0x10);\n\n    // Calculate the pin position by finding the first set bit in the pin mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the pin state from the IDR and return 1 if high, 0 if low\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It uses bitwise operations to ensure atomic\n * and reliable toggling of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "b2e0d8d7-ebf4-4d6e-a331-569b22bbae75",
            "timestamp": "2024-10-31T09:33:02.892165",
            "total time (seconds)": 99.34004950523376,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, where the BRR register is located\n// at an offset of 0x08 from the base address of the USART peripheral.\n#define USART_BRR_OFFSET ((uint32_t)0x08)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the offset for the USART_SR register.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// USART_FLAG_TXE is a flag used to indicate that the USART transmit data register is empty.\n// This flag is typically used in USART status register to check if the USART is ready to send more data.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// RCC_BASE is the base address for the Reset and Clock Control (RCC) registers\n// on the STM32F407 microcontroller. This address is used to access the RCC\n// registers for configuring the clock system of the microcontroller.\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART instance.\n// The value is based on the STM32F407 reference manual.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Enable the clock for GPIOA by setting the 0th bit of the RCC_AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin number from the pin mask\n    uint8_t pin_number = 0;\n    while ((pin_mask >> pin_number) != 1) {\n        pin_number++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin in the MODER register\n    *GPIO_MODER &= ~(0x3 << (pin_number * 2));\n\n    // Set the mode for the pin (0x1 for output, 0x0 for input)\n    *GPIO_MODER |= (mode << (pin_number * 2));\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    for (uint32_t mask = pin_mask; mask > 1; mask >>= 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin specified by the port base address and pin mask.\n * It calculates the pin position and checks the input data register (IDR) to determine if the pin is high or low.\n * \n * @param port_base_address The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t port_base_address, uint32_t pin_mask) {\n    // Pointer to the input data register (IDR) of the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(port_base_address + 0x10);\n\n    // Calculate the pin position by finding the first set bit in the pin mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the pin state from the IDR and return 1 if high, 0 if low\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It uses bitwise operations to ensure atomic\n * and reliable toggling of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "cce1b7ed-11c8-4c82-a4a8-f1b2c5c8567c",
            "timestamp": "2024-10-31T09:36:00.984798",
            "total time (seconds)": 158.9343855381012,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is specific to the STM32F407 microcontroller series.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the offset for the Status Register (SR) of the USART peripheral.\n// This offset is used to access the USART_SR register from the base address of a USART peripheral.\n// The value is based on the STM32F407 reference manual, where the USART_SR register is located at an offset of 0x00 from the USART base address.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n// on the STM32F407 microcontroller. This address is used to access\n// the RCC registers for configuring the clock system of the MCU.\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference\n// manual for the STM32F407, which specifies the offset for the DR register\n// within the USART peripheral's register map.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 microcontroller.\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 microcontroller.\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// The RCC_AHB1ENR register is used to enable the clock for peripherals connected to the AHB1 bus.\n// The offset is based on the STM32F407 reference manual, which specifies the memory map for the RCC registers.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC and the offset for the AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Set the bit corresponding to GPIOA (bit 0) to enable its clock\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin number from the pin mask\n    uint8_t pin_number = 0;\n    while ((pin_mask >> pin_number) != 1) {\n        pin_number++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin in the MODER register\n    *GPIO_MODER &= ~(0x3 << (pin_number * 2));\n\n    // Set the mode for the pin\n    if (mode == 1) {\n        // Set as output\n        *GPIO_MODER |= (0x1 << (pin_number * 2));\n    } else {\n        // Set as input (default is already cleared)\n    }\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin specified by the port base address\n * and the pin mask. It calculates the pin position and checks the input data register\n * to determine if the pin is set high or low.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Pointer to the input data register (IDR) of the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n\n    // Calculate the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the pin state from the IDR and return 1 if high, 0 if low\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations using bitwise XOR.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "340a1e67-57e4-4377-9b58-2ce499bd7b42",
            "timestamp": "2024-10-31T09:38:03.710712",
            "total time (seconds)": 104.99336862564087,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC (Reset and Clock Control) block.\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock for AHB1 peripherals.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral\n// This offset is used to calculate the address of the BRR register for a given USART instance\n// on the STM32F407 microcontroller. The value is based on the reference manual for the STM32F407.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the offset for the USART_SR register.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// USART_FLAG_TXE is a flag used to indicate that the USART transmit data register is empty.\n// This flag is typically used in USART status register (USART_SR) to check if the USART is ready to send more data.\n// The value 0x0080 corresponds to the bit position of the TXE flag in the USART status register.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// RCC_BASE is the base address for the Reset and Clock Control (RCC) registers\n// on the STM32F407 microcontroller. This address is used to access the RCC\n// registers for configuring the clock system of the microcontroller.\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The USART_CR1 register is responsible for configuring various aspects of the USART peripheral,\n// such as enabling the USART, setting the word length, parity, and enabling interrupts.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Enable the clock for GPIOA by setting the 0th bit of the RCC_AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n\n    // Set the mode: 0x1 for output, 0x0 for input\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin by accessing the input data register (IDR)\n * of the specified GPIO port. It calculates the bit position of the pin using a loop\n * and returns the state of the pin.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Pointer to the input data register (IDR) of the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n\n    // Calculate the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the pin state from the IDR and return it\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations using bitwise XOR.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *GPIO_ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "c182aa9d-84bc-4863-8692-d7abd57ec6de",
            "timestamp": "2024-10-31T09:39:49.294196",
            "total time (seconds)": 87.50009799003601,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// The RCC_AHB1ENR register is used to enable the clock for peripherals connected to the AHB1 bus.\n// The offset is based on the STM32F407 reference manual, which specifies the memory map for the RCC registers.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the offset for the BRR register.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// USART_FLAG_TXE is a flag used to indicate that the USART transmit data register is empty.\n// This flag is used in the status register of the USART peripheral to check if the USART is ready to send more data.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference\n// manual for the STM32F407, which specifies the offset for the DR register\n// within the USART peripheral's register map.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the clock is enabled by setting\n * the appropriate bit in the RCC_AHB1ENR register.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC and the offset for the AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Set the bit 0 of RCC_AHB1ENR to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bit mask for the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    for (uint32_t mask = pin_mask; mask > 1; mask >>= 1) {\n        pin_position++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n\n    // Set the mode for the pin\n    if (mode == 1) {\n        // Set as output\n        *GPIO_MODER |= (0x1 << (pin_position * 2));\n    } else {\n        // Set as input (default is already cleared)\n    }\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin specified by the port base address and pin mask.\n * It calculates the pin position and checks the input data register (IDR) to determine if the pin is high or low.\n * \n * @param port_base_address The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t port_base_address, uint32_t pin_mask) {\n    // Pointer to the input data register (IDR) of the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(port_base_address + 0x10);\n\n    // Calculate the pin position by finding the first set bit in the pin mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the pin state from the IDR and return 1 if high, 0 if low\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations using bitwise XOR.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the specified pin using XOR operation\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "4b087d1a-02b4-4734-beb8-7a97a23aa4ba",
            "timestamp": "2024-10-31T09:42:38.757777",
            "total time (seconds)": 148.55217909812927,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC (Reset and Clock Control) block.\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock for AHB1 peripherals.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// USART_BRR_OFFSET is the offset for the Baud Rate Register in the USART peripheral.\n// This offset is used to calculate the address of the Baud Rate Register for a specific USART instance.\n// The value is based on the STM32F407 reference manual.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is based on the STM32F407 reference manual.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the USART transmit data register is empty\n// and ready to accept new data for transmission. It is a part of the USART status register (SR).\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference\n// manual for the STM32F407, which specifies the offset for the DR register\n// within the USART peripheral's register map.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Define the offset for the USART Control Register 1 (CR1) for the STM32F407 board.\n// This offset is used to access the USART_CR1 register relative to the base address of a USART peripheral.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Enable the clock for GPIOA by setting the appropriate bit in the RCC AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bit mask for the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n\n    // Set the mode: 0x1 for output, 0x0 for input\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin specified by the port base address and pin mask.\n * It calculates the pin position and checks the input data register (IDR) to determine if the pin is high or low.\n * \n * @param port_base_address The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t port_base_address, uint32_t pin_mask) {\n    // Pointer to the input data register (IDR) of the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(port_base_address + 0x10);\n\n    // Calculate the pin position by finding the first set bit in the pin mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the pin state from the IDR and return 1 if high, 0 if low\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations using bitwise XOR.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint16_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the specified pin using XOR operation\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "756f6d96-817d-4e91-8174-0b72ae144b7e",
            "timestamp": "2024-10-31T09:44:48.135168",
            "total time (seconds)": 109.32029366493225,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// The RCC_AHB1ENR register is used to enable the clock for peripherals connected to the AHB1 bus.\n// The offset is based on the STM32F407 reference manual, which specifies the memory map for the RCC registers.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// USART_FLAG_TXE is a flag used to indicate that the USART transmit data register is empty.\n// This flag is used in the status register of the USART peripheral to check if the USART is ready to send more data.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// RCC_BASE is the base address for the Reset and Clock Control (RCC) registers\n// on the STM32F407 microcontroller. This address is used to access the RCC\n// registers for configuring the clock system of the microcontroller.\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference\n// manual for the STM32F407, which specifies the offset for the DR register\n// within the USART peripheral's register map.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Enable the clock for GPIOA by setting the 0th bit of the RCC_AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n\n    // Set the mode: 0x1 for output, 0x0 for input\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin specified by the port base address and pin mask.\n * It calculates the pin position and checks the input data register (IDR) to determine if the pin is high or low.\n * \n * @param port_base_address The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t port_base_address, uint32_t pin_mask) {\n    // Calculate the pin position by finding the first set bit in the pin mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Define the input data register (IDR) offset for the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(port_base_address + 0x10);\n\n    // Read the IDR and check if the specific pin is set\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations using bitwise XOR.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *GPIO_ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "6c3e2505-7e63-4c7f-bea1-f6a87df2de56",
            "timestamp": "2024-10-31T09:46:21.214901",
            "total time (seconds)": 76.54700350761414,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// The RCC_AHB1ENR register is used to enable the clock for peripherals connected to the AHB1 bus.\n// The offset is based on the STM32F407 reference manual, which specifies the memory map for the RCC registers.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the offset for the USART_SR register.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// USART_FLAG_TXE is a flag used to indicate that the USART transmit data register is empty.\n// This flag is typically used in USART status register (USART_SR) to check if the USART is ready to send more data.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// USART_DR_OFFSET is the offset for the Data Register in the USART peripheral.\n// This offset is used to access the data register for reading or writing data.\n// The value is specific to the STM32F407 microcontroller series.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Enable the clock for GPIOA by setting the appropriate bit in the RCC AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n\n    // Set the mode for the pin\n    if (mode == 1) {\n        // Set as output\n        *GPIO_MODER |= (0x1 << (pin_position * 2));\n    } else {\n        // Set as input (default is already cleared)\n    }\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin by accessing the input data register (IDR)\n * of the specified GPIO port. It uses bitwise operations to isolate the state of the desired pin.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the input data register (IDR) for the given GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the state of the pin by checking the corresponding bit in the IDR\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations using bitwise XOR.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "fb3dcbe3-a3df-4a37-8d3b-36f804bd83ab",
            "timestamp": "2024-10-31T09:48:44.009095",
            "total time (seconds)": 129.04614806175232,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is based on the STM32F407 reference manual.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// USART_FLAG_TXE is a flag used to indicate that the USART transmit data register is empty.\n// This flag is used in the status register of the USART peripheral to check if the USART is ready to send more data.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference manual\n// for the STM32F407, which specifies the offset for the USART_DR register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Define the offset for the USART Control Register 1 (USART_CR1) for the STM32F407 board.\n// This offset is used to access the USART_CR1 register relative to the base address of a USART peripheral.\n#define USART_CR1_OFFSET ((uint32_t)0x0C)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC and the offset for the AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Set the bit corresponding to GPIOA (bit 0) to enable its clock\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n\n    // Set the mode: 0x1 for output, 0x0 for input\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin by accessing the input data register (IDR)\n * of the specified GPIO port. It calculates the bit position of the pin using a loop\n * to ensure accurate pin configuration.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask representing the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Pointer to the input data register (IDR) of the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n\n    // Calculate the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the pin state from the IDR and return it\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations using bitwise XOR.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "a236ccc6-1259-4133-9cf9-2b82283479af",
            "timestamp": "2024-10-31T09:50:45.782050",
            "total time (seconds)": 101.7720353603363,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC (Reset and Clock Control) block.\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock for AHB1 peripherals.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the offset for the USART_SR register.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// RCC_BASE is the base address for the Reset and Clock Control (RCC) registers\n// on the STM32F407 microcontroller. This address is used to access the RCC\n// registers for configuring the clock system of the microcontroller.\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference manual\n// which specifies the offset for the USART_DR register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC and the offset for the AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Set the bit corresponding to GPIOA (bit 0) to enable its clock\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bit mask for the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n\n    // Set the mode for the pin\n    if (mode == 1) {\n        // Set as output\n        *GPIO_MODER |= (0x1 << (pin_position * 2));\n    } else {\n        // Set as input (default is already cleared)\n    }\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin by accessing the input data register (IDR)\n * of the specified GPIO port. It uses bitwise operations to determine the state of the pin.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the input data register (IDR) for the given GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the state of the pin from the IDR and return it\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It uses bitwise operations to ensure atomic\n * and reliable toggling of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "f5539dc9-0d96-4361-b8af-f5323e7bde2b",
            "timestamp": "2024-10-31T09:52:41.509660",
            "total time (seconds)": 85.17327237129211,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// The USART2 peripheral is used for serial communication and is mapped to a specific memory address.\n// This address is used to access the registers of the USART2 peripheral.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the offset for the USART_SR register.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written to it. It is a part of the USART status register (SR).\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference\n// manual for the STM32F407, which specifies the offset for the DR register\n// within the USART peripheral's register map.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC and the offset for the AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Set the bit corresponding to GPIOA (bit 0) to enable its clock\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n\n    // Set the mode: 0x1 for output, 0x0 for input\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin specified by the port base address\n * and the pin mask. It calculates the pin position and checks the input data register\n * to determine if the pin is set high or low.\n * \n * @param port_base_address The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t port_base_address, uint32_t pin_mask) {\n    // Pointer to the input data register (IDR) of the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(port_base_address + 0x10);\n\n    // Calculate the pin position by finding the first set bit in the pin mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the pin state from the IDR and return 1 if high, 0 if low\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations using bitwise XOR.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14); // ODR offset is 0x14\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "8fee3c7b-9799-4bd8-b670-82026c8dcf93",
            "timestamp": "2024-10-31T09:55:22.214383",
            "total time (seconds)": 129.47095131874084,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready to accept new data for transmission. It is a part of the USART\n// status register (SR) and is typically used in USART communication to check\n// if the transmitter is ready to send the next byte of data.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference manual\n// for the STM32F407, which specifies the offset for the USART_DR register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the clock is enabled by setting\n * the appropriate bit in the RCC_AHB1ENR register.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC and the offset for the AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Set the bit 0 of RCC_AHB1ENR to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n\n    // Set the mode: 0x1 for output, 0x0 for input\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin by accessing the input data register (IDR)\n * of the specified GPIO port. It uses bitwise operations to isolate the state of the desired pin.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the input data register (IDR) for the given GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the state of the pin by checking the corresponding bit in the IDR\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations using bitwise XOR.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the specified pin using XOR operation\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "e79fa65e-11da-445c-87d8-8e399459ce77",
            "timestamp": "2024-10-31T09:57:48.643943",
            "total time (seconds)": 132.26473665237427,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// USART_BRR_OFFSET is the offset for the Baud Rate Register in the USART peripheral.\n// This offset is used to calculate the address of the Baud Rate Register for a specific USART instance.\n// The value is based on the STM32F407 reference manual.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the offset for the Status Register (SR) of the USART peripheral.\n// This offset is used to access the status register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference manual\n// for the STM32F407, where the USART_SR register is located at an offset of 0x00\n// from the base address of the USART peripheral.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// USART_FLAG_TXE is a flag used to indicate that the USART transmit data register is empty.\n// This flag is used in the status register of the USART peripheral to check if the USART is ready to send more data.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference manual\n// for the STM32F407, which specifies the offset for the USART_DR register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Enable the clock for GPIOA by setting the appropriate bit in the RCC AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);  // Set bit 0 to enable GPIOA clock\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n\n    // Set the mode: 0x1 for output, 0x0 for input\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin by accessing the input data register (IDR)\n * of the specified GPIO port. It determines the bit position of the pin using a loop\n * and checks if the pin is set (high) or reset (low).\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * \n * @return 1 if the pin is set (high), 0 if the pin is reset (low).\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Pointer to the input data register (IDR) of the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the pin state from the IDR and return it\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations using bitwise XOR.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the specified pin using XOR operation\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "097c7ded-8348-4353-bc3b-3c88d45add7e",
            "timestamp": "2024-10-31T09:59:52.274760",
            "total time (seconds)": 109.68774223327637,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// USART_BRR_OFFSET is the offset for the Baud Rate Register in the USART peripheral.\n// This offset is used to calculate the address of the Baud Rate Register for a specific USART instance.\n// The value is based on the STM32F407 reference manual.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the offset for the USART_SR register.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference\n// manual for the STM32F407, which specifies the offset for the DR register\n// within the USART peripheral's register map.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC and the offset for the AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Set the bit corresponding to GPIOA (bit 0) to enable its clock\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin number from the pin mask\n    uint8_t pin_number = 0;\n    while ((pin_mask >> pin_number) != 1) {\n        pin_number++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin in the MODER register\n    *GPIO_MODER &= ~(0x3 << (pin_number * 2));\n\n    // Set the mode for the pin\n    if (mode == 1) {\n        // Set as output\n        *GPIO_MODER |= (0x1 << (pin_number * 2));\n    } else {\n        // Set as input (default is already 0, so no need to set)\n    }\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Pointer to the Output Data Register (ODR) of the specified GPIO port\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Calculate the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    for (uint32_t mask = pin_mask; mask > 1; mask >>= 1) {\n        pin_position++;\n    }\n\n    // Write the value to the specified pin using bitwise operations\n    if (value) {\n        // Set the pin: Use bitwise OR to set the bit at pin_position\n        *GPIO_ODR |= (1 << pin_position);\n    } else {\n        // Reset the pin: Use bitwise AND with NOT to clear the bit at pin_position\n        *GPIO_ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin by accessing the input data register (IDR)\n * of the specified GPIO port. It calculates the bit position of the pin using a loop\n * to ensure accurate pin configuration.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask representing the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Pointer to the input data register (IDR) of the specified GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n\n    // Calculate the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the pin state from the IDR and return it\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations using bitwise XOR.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14); // ODR offset is 0x14\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "00832043-5781-4546-b186-8f836f7e604d",
            "timestamp": "2024-10-31T10:01:40.554305",
            "total time (seconds)": 94.21047496795654,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the offset for the Status Register (SR) of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is based on the STM32F407 reference manual, where the USART_SR register is located\n// at an offset of 0x00 from the base address of the USART peripheral.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// RCC_BASE is the base address for the Reset and Clock Control (RCC) registers\n// on the STM32F407 microcontroller. This address is used to access the RCC\n// registers for configuring the clock system of the microcontroller.\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference\n// manual for the STM32F407, which specifies the offset for the DR register\n// within the USART peripheral's register map.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the clock is enabled by setting\n * the appropriate bit in the RCC_AHB1ENR register.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC and the offset for the AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Enable the clock for GPIOA by setting the 0th bit of the RCC_AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n\n    // Set the mode: 0x1 for output, 0x0 for input\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin specified by the port base address and pin mask.\n * It calculates the pin position and checks the input data register (IDR) to determine if the pin is high or low.\n * \n * @param port_base_address The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t port_base_address, uint32_t pin_mask) {\n    // Pointer to the input data register (IDR) of the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(port_base_address + 0x10);\n\n    // Calculate the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the pin state from the IDR and return 1 if high, 0 if low\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations using bitwise XOR.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the specified pin using XOR operation\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "118abbf5-ecfd-48e6-8ae5-f0675cc7b2d6",
            "timestamp": "2024-10-31T10:03:49.870590",
            "total time (seconds)": 115.4601538181305,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// The USART2 peripheral is used for serial communication and is mapped to a specific memory address.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// The RCC_AHB1ENR register is used to enable the clock for peripherals connected to the AHB1 bus.\n// The offset is based on the STM32F407 reference manual, which specifies the memory map for the RCC registers.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the offset for the USART_SR register.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready to accept new data for transmission.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference\n// manual for the STM32F407, which specifies the offset for the DR register\n// within the USART peripheral's register map.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the clock is enabled by setting\n * the appropriate bit in the RCC_AHB1ENR register.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC and the offset for the AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Set the bit 0 of RCC_AHB1ENR to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: Mode to set (0 for input, 1 for output)\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position from the pin mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n\n    // Set the mode for the pin\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin specified by the port base address and pin mask.\n * It calculates the pin position and checks the input data register (IDR) to determine if the pin is high or low.\n * \n * @param port_base_address The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t port_base_address, uint32_t pin_mask) {\n    // Pointer to the input data register (IDR) of the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(port_base_address + 0x10);\n\n    // Calculate the pin position by finding the first set bit in the pin mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the pin state from the IDR and return 1 if high, 0 if low\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations using bitwise XOR.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the specified pin using XOR operation\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "24aeffde-68c2-4dbb-ba62-51d088c95d6e",
            "timestamp": "2024-10-31T10:05:14.535222",
            "total time (seconds)": 70.70985126495361,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x08)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be sent. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// USART_DR_OFFSET is the offset for the Data Register in the USART peripheral.\n// This offset is used to access the data register for reading or writing data.\n// The value is specific to the STM32F407 microcontroller series.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The USART_CR1 register is used to configure various settings of the USART, such as enabling the USART, setting the word length, parity, etc.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the clock is enabled by setting\n * the appropriate bit in the RCC_AHB1ENR register.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC and the offset for the AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Set the bit 0 of RCC_AHB1ENR to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin number from the pin mask\n    uint8_t pin_number = 0;\n    for (uint32_t mask = pin_mask; mask > 1; mask >>= 1) {\n        pin_number++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin in the MODER register\n    *GPIO_MODER &= ~(0x3 << (pin_number * 2));\n\n    // Set the mode for the pin (0x1 for output, 0x0 for input)\n    *GPIO_MODER |= (mode << (pin_number * 2));\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin by accessing the input data register (IDR)\n * of the specified GPIO port. It calculates the bit position of the pin using a loop\n * to ensure accurate pin configuration.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask representing the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Pointer to the input data register (IDR) of the specified GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n\n    // Calculate the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the pin state from the IDR and return it\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations using bitwise XOR.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "ae63a794-c539-4762-a66e-bdcd0e21a1a8",
            "timestamp": "2024-10-31T10:06:48.642032",
            "total time (seconds)": 79.97626447677612,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// The RCC_AHB1ENR register is used to enable the clock for peripherals connected to the AHB1 bus.\n// The offset is based on the STM32F407 reference manual, which specifies the memory map for the RCC registers.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral\n// This offset is used to calculate the address of the BRR register for a given USART instance\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the offset for the Status Register (SR) of the USART peripheral.\n// This offset is used to access the status register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference manual\n// for the STM32F407, where the USART_SR register is located at an offset of 0x00\n// from the base address of the USART peripheral.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the USART transmit data register is empty\n// and ready to accept new data for transmission. It is a part of the USART status register (SR).\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// RCC_BASE is the base address for the Reset and Clock Control (RCC) registers\n// on the STM32F407 microcontroller. This address is used to access the RCC\n// registers for configuring the clock system of the microcontroller.\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference manual\n// which specifies the offset for the USART_DR register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC and the offset for the AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Set the bit corresponding to GPIOA (bit 0) to enable its clock\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n\n    // Set the mode: 0x1 for output, 0x0 for input\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin specified by the port base address and pin mask.\n * It calculates the pin position and checks the input data register (IDR) to determine if the pin is high or low.\n * \n * @param port_base_address The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t port_base_address, uint32_t pin_mask) {\n    // Pointer to the input data register (IDR) of the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(port_base_address + 0x10);\n\n    // Calculate the pin position by finding the first set bit in the pin mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the pin state from the IDR and return 1 if high, 0 if low\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations using bitwise XOR.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *GPIO_ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "a2d0fb59-04c7-4931-a278-ec394c5464fc",
            "timestamp": "2024-10-31T10:08:55.541236",
            "total time (seconds)": 113.12752938270569,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is based on the STM32F407 reference manual.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// USART_FLAG_TXE is a flag used to indicate that the USART transmit data register is empty.\n// This flag is used in the status register of the USART peripheral to check if the USART is ready to send more data.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC and the offset for the AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Set the bit corresponding to GPIOA (bit 0) to enable its clock\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n\n    // Set the mode for the pin\n    if (mode == 1) {\n        // Set as output\n        *GPIO_MODER |= (0x1 << (pin_position * 2));\n    } else {\n        // Set as input (default is already cleared)\n    }\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin specified by the port base address\n * and the pin mask. It calculates the pin position and checks the input data register\n * to determine if the pin is set high or low.\n * \n * @param port_base_address The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t port_base_address, uint32_t pin_mask) {\n    // Pointer to the input data register (IDR) of the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(port_base_address + 0x10);\n\n    // Calculate the pin position by finding the first set bit in the pin mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the pin state from the IDR and return 1 if high, 0 if low\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations using bitwise\n * XOR to flip the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *GPIO_ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "7008251d-a5f4-44fe-8e69-237fc738df88",
            "timestamp": "2024-10-31T10:11:25.186935",
            "total time (seconds)": 135.91331338882446,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC (Reset and Clock Control) block.\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock for AHB1 peripherals.\n// The value is specific to the STM32F407 microcontroller.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, where the BRR register is located\n// at an offset of 0x08 from the base address of the USART peripheral.\n#define USART_BRR_OFFSET ((uint32_t)0x08)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is based on the STM32F407 reference manual.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// USART_FLAG_TXE is a flag used to indicate that the USART transmit data register is empty.\n// This flag is typically used in USART status register to check if the USART is ready to send more data.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference manual\n// for the STM32F407, which specifies the offset for the USART_DR register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Enable the clock for GPIOA by setting the appropriate bit in the RCC AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);  // Set bit 0 to enable GPIOA clock\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    for (uint32_t mask = pin_mask; mask > 1; mask >>= 1) {\n        pin_position++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n\n    // Set the mode (0 for input, 1 for output) at the pin position\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin by accessing the input data register (IDR)\n * of the specified GPIO port. It uses bitwise operations to determine the state of the pin.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the input data register (IDR) for the given GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the state of the pin by checking the corresponding bit in the IDR\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations using bitwise\n * XOR to flip the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *GPIO_ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "d871d734-c79b-4672-93cc-8e958c1facba",
            "timestamp": "2024-10-31T10:13:55.408699",
            "total time (seconds)": 136.12652587890625,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// The RCC_AHB1ENR register is used to enable the clock for peripherals connected to the AHB1 bus.\n// The offset is based on the STM32F407 reference manual, which specifies the memory map for the RCC registers.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// USART_BRR_OFFSET is the offset for the Baud Rate Register in the USART peripheral.\n// This offset is used to calculate the address of the Baud Rate Register for a specific USART instance.\n// The value is based on the STM32F407 reference manual.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the offset for the USART_SR register.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// USART_FLAG_TXE is a flag used to indicate that the USART transmit data register is empty.\n// This flag is typically used in USART status register to check if the USART is ready to send more data.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference\n// manual for the STM32F407 series, which specifies the offset for the\n// USART_DR register within the USART peripheral's register map.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Enable the clock for GPIOA by setting the appropriate bit in the RCC AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n\n    // Set the mode: 0x1 for output, 0x0 for input\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin on the STM32F407 board.\n * It uses direct register access to determine if the pin is set high or low.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the input data register (IDR) address for the given GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the pin state from the IDR and return 1 if high, 0 if low\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of the specified GPIO port\n * to toggle the state of a given pin. It ensures atomic operations using bitwise XOR.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the specified pin using XOR operation\n    *GPIO_ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "56e1c15f-6a12-4c33-9d7e-0041b2248752",
            "timestamp": "2024-10-31T10:15:41.877569",
            "total time (seconds)": 92.64672923088074,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC (Reset and Clock Control) block.\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock for AHB1 peripherals.\n// The offset value is based on the STM32F407 reference manual.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready to accept new data for transmission.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// RCC_BASE is the base address for the Reset and Clock Control (RCC) registers\n// on the STM32F407 microcontroller. This address is used to access the RCC\n// registers for configuring the clock system of the microcontroller.\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference manual\n// which specifies the offset for the USART_DR register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The USART_CR1 register is responsible for configuring various aspects of the USART peripheral,\n// such as enabling the USART, setting the word length, parity control, and more.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Enable the clock for GPIOA by setting the appropriate bit in the RCC AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n\n    // Set the mode: 0x1 for output, 0x0 for input\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin by accessing the input data register (IDR)\n * of the specified GPIO port. It calculates the bit position of the pin using a loop\n * and returns the state of the pin.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Pointer to the input data register (IDR) of the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n\n    // Calculate the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the pin state from the IDR and return it\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of the specified GPIO port\n * to toggle the state of a given pin. It uses bitwise operations to ensure atomic and reliable\n * toggling of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the specified pin by XORing the ODR with the pin mask\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "9f1d701e-8cb1-4578-95ca-5c5aff19ce06",
            "timestamp": "2024-10-31T10:17:40.632270",
            "total time (seconds)": 103.10197830200195,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready to accept new data for transmission. It is a part of the USART\n// status register (USART_SR) and is typically used in USART communication\n// to check if the transmitter is ready to send the next byte of data.\n// The value 0x0080 corresponds to the TXE flag in the USART_SR register.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference\n// manual for the STM32F407, which specifies the offset for the DR register\n// within the USART peripheral's register map.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Enable the clock for GPIOA by setting the appropriate bit in the RCC AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);  // Set bit 0 to enable GPIOA clock\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n\n    // Set the mode: 0x1 for output, 0x0 for input\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin specified by the port base address and pin mask.\n * It calculates the pin position and checks the input data register (IDR) to determine if the pin is high or low.\n * \n * @param port_base_address The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t port_base_address, uint32_t pin_mask) {\n    // Calculate the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Define the input data register (IDR) offset for the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(port_base_address + 0x10);\n\n    // Read the pin state from the IDR and return 1 if high, 0 if low\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It uses bitwise operations to ensure atomic\n * and reliable toggling of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *GPIO_ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "d6bbf7ae-361b-481d-bf88-d1a1514ad86d",
            "timestamp": "2024-10-31T10:20:33.522148",
            "total time (seconds)": 157.63594484329224,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the offset for the USART_SR register.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the USART transmit data register is empty\n// and ready to accept new data for transmission. It is a common flag used in\n// USART communication to manage data flow.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n// on the STM32F407 microcontroller. This address is used to access\n// the RCC registers for configuring the clock system of the MCU.\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference manual\n// which specifies the offset for the USART_DR register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the clock is enabled by setting\n * the appropriate bit in the RCC_AHB1ENR register.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC and the offset for the AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Set the bit 0 of RCC_AHB1ENR to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    for (uint32_t mask = pin_mask; mask > 1; mask >>= 1) {\n        pin_position++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n\n    // Set the mode for the pin\n    if (mode == 1) {\n        // Set as output\n        *GPIO_MODER |= (0x1 << (pin_position * 2));\n    } else {\n        // Set as input (default is already cleared)\n    }\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin specified by the port base address\n * and the pin mask. It calculates the pin position and checks the input data register\n * to determine if the pin is set high or low.\n * \n * @param port_base_address The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t port_base_address, uint32_t pin_mask) {\n    // Pointer to the input data register (IDR) of the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(port_base_address + 0x10);\n\n    // Calculate the pin position by finding the first set bit in the pin mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the pin state from the IDR and return 1 if high, 0 if low\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations using bitwise XOR.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "d8107d6a-6379-4972-9cf9-70cbe5d3c2bf",
            "timestamp": "2024-10-31T10:24:24.804515",
            "total time (seconds)": 217.02049922943115,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x08)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the USART transmit data register is empty\n// and ready to accept new data for transmission. The value is based on the\n// STM32F407 reference manual, where the TXE flag is typically bit 7 in the\n// USART status register (SR).\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference\n// manual for the STM32F407, which specifies the offset for the USART_DR register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Enable the clock for GPIOA by setting the appropriate bit in the RCC AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);  // Set bit 0 to enable GPIOA clock\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n\n    // Set the mode: 0x1 for output, 0x0 for input\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin by accessing the input data register (IDR)\n * of the specified GPIO port. It calculates the bit position of the pin using a loop\n * and returns the state of the pin.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Pointer to the input data register (IDR) of the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n\n    // Calculate the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the pin state from the IDR and return it\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations using bitwise XOR.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "f86c7c5e-c758-4ac7-94af-3134aa4349fb",
            "timestamp": "2024-10-31T10:26:18.628840",
            "total time (seconds)": 99.35483932495117,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// The RCC_AHB1ENR register is used to enable the clock for peripherals connected to the AHB1 bus.\n// The offset is based on the STM32F407 reference manual, which specifies the memory map for the RCC registers.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral\n// This offset is used to calculate the address of the BRR register for a given USART instance\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the offset for the USART_SR register.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a common flag used in USART\n// communication to manage data transmission.\n// The value 0x00000080 is typically used for the TXE flag in the status register.\n#define USART_FLAG_TXE ((uint32_t)0x00000080)\n\n// RCC_BASE is the base address for the Reset and Clock Control (RCC) registers\n// on the STM32F407 microcontroller. This address is used to access the RCC\n// registers for configuring the clock system of the microcontroller.\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the clock is enabled by setting\n * the appropriate bit in the RCC_AHB1ENR register.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC and the offset for the AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Set the bit 0 of RCC_AHB1ENR to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin number from the pin mask\n    uint8_t pin_number = 0;\n    while ((pin_mask >> pin_number) != 1) {\n        pin_number++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin in the MODER register\n    *GPIO_MODER &= ~(0x3 << (pin_number * 2));\n\n    // Set the mode for the pin\n    if (mode == 1) {\n        // Set as output\n        *GPIO_MODER |= (0x1 << (pin_number * 2));\n    } else {\n        // Set as input (default is already cleared)\n    }\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin by accessing the input data register (IDR)\n * of the specified GPIO port. It calculates the bit position of the pin using a loop\n * and returns the state of the pin.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Pointer to the input data register (IDR) of the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n\n    // Calculate the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the pin state from the IDR and return it\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations using bitwise XOR.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the specified pin using XOR operation\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "218b3653-3f52-439c-9491-18ef8452edc9",
            "timestamp": "2024-10-31T10:28:04.518269",
            "total time (seconds)": 91.42804002761841,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC (Reset and Clock Control) block.\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock for AHB1 peripherals.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral\n// This offset is used to calculate the address of the BRR register for a given USART instance\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the USART transmit data register is empty\n// and ready to accept new data for transmission. It is a part of the USART status register (SR).\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// RCC_BASE is the base address for the Reset and Clock Control (RCC) registers\n// on the STM32F407 microcontroller. This address is used to access the RCC\n// registers for configuring the clock system of the microcontroller.\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference\n// manual for the STM32F407, which specifies the offset for the DR register\n// within the USART peripheral's register map.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the clock is enabled by setting\n * the appropriate bit in the RCC_AHB1ENR register.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC and the offset for the AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Set the bit 0 of RCC_AHB1ENR to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin number from the pin mask\n    uint8_t pin_number = 0;\n    for (uint32_t mask = pin_mask; mask > 1; mask >>= 1) {\n        pin_number++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin in the MODER register\n    *GPIO_MODER &= ~(0x3 << (pin_number * 2));\n\n    // Set the mode for the pin\n    if (mode == 1) {\n        // Set as output\n        *GPIO_MODER |= (0x1 << (pin_number * 2));\n    } else {\n        // Set as input (default is already cleared)\n    }\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin specified by the port base address\n * and the pin mask. It calculates the pin position and checks the input data register\n * to determine if the pin is set high or low.\n * \n * @param port_base_address The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t port_base_address, uint32_t pin_mask) {\n    // Pointer to the input data register (IDR) of the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(port_base_address + 0x10);\n\n    // Calculate the pin position by finding the first set bit in the pin mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the pin state from the IDR and return 1 if high, 0 if low\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It uses bitwise operations to ensure atomic\n * and reliable toggling of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "f0f47631-a438-4ef6-85b3-7093e3f78d80",
            "timestamp": "2024-10-31T10:30:00.210553",
            "total time (seconds)": 101.66891860961914,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// The RCC_AHB1ENR register is used to enable the clock for peripherals connected to the AHB1 bus.\n// The offset is based on the STM32F407 reference manual, which specifies the memory map for the RCC registers.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n#define USART_FLAG_TXE ((uint16_t)0x0080) // USART Transmit Data Register Empty flag: This flag is set when the transmit data register is empty and ready for new data.\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// USART_DR_OFFSET is the offset for the Data Register in the USART peripheral.\n// This offset is used to access the data register for reading or writing data.\n// The value is specific to the STM32F407 microcontroller series.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the clock is enabled by setting\n * the appropriate bit in the RCC_AHB1ENR register.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC and the offset for the AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Enable the clock for GPIOA by setting the 0th bit of the RCC_AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n\n    // Set the mode: 0x1 for output, 0x0 for input\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin by accessing the input data register (IDR)\n * of the specified GPIO port. It uses bitwise operations to determine the state of the pin.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the input data register (IDR) for the given GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the state of the pin from the IDR and return it\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It uses bitwise operations to ensure atomic\n * and reliable toggling of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "35d05ceb-703d-46e2-80b5-68bcbf52c180",
            "timestamp": "2024-10-31T10:32:55.147486",
            "total time (seconds)": 160.86262345314026,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral\n// This offset is used to calculate the address of the BRR register for a given USART instance\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the offset for the Status Register (SR) of the USART peripheral.\n// This offset is used to access the USART_SR register from the base address of a USART peripheral.\n// The value is based on the STM32F407 reference manual, where the USART_SR register is located\n// at an offset of 0x00 from the base address of the USART peripheral.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference\n// manual for the STM32F407, which specifies the offset for the DR register\n// within the USART peripheral's register map.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the clock is enabled by setting\n * the appropriate bit in the RCC_AHB1ENR register.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC and the offset for the AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Enable the clock for GPIOA by setting the 0th bit of the RCC_AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin number from the pin mask\n    uint8_t pin_number = 0;\n    while ((pin_mask >> pin_number) != 1) {\n        pin_number++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin in the MODER register\n    *GPIO_MODER &= ~(0x3 << (pin_number * 2));\n\n    // Set the mode for the pin\n    // 0x1 for output mode, 0x0 for input mode\n    *GPIO_MODER |= (mode << (pin_number * 2));\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin specified by the port base address and pin mask.\n * It calculates the pin position and checks the input data register (IDR) to determine if the pin is high or low.\n * \n * @param port_base_address The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t port_base_address, uint32_t pin_mask) {\n    // Pointer to the input data register (IDR) of the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(port_base_address + 0x10);\n\n    // Calculate the pin position by finding the first set bit in the pin mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the pin state from the IDR and return 1 if high, 0 if low\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations using bitwise XOR.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "32045fe9-9860-4da2-8a11-aeadc0861a66",
            "timestamp": "2024-10-31T10:35:28.906982",
            "total time (seconds)": 139.81062078475952,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// The RCC_AHB1ENR register is used to enable the clock for peripherals connected to the AHB1 bus.\n// The offset is based on the STM32F407 reference manual, which specifies the memory map for the RCC registers.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x08)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready to accept new data for transmission.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference\n// manual for the STM32F407, which specifies the offset for the USART_DR register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Enable the clock for GPIOA by setting the appropriate bit in the RCC AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin number from the pin mask\n    uint8_t pin_number = 0;\n    while ((pin_mask >> pin_number) != 1) {\n        pin_number++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin in the MODER register\n    *GPIO_MODER &= ~(0x3 << (pin_number * 2));\n\n    // Set the mode for the pin\n    if (mode == 1) {\n        // Set as output\n        *GPIO_MODER |= (0x1 << (pin_number * 2));\n    } else {\n        // Set as input (default is already cleared)\n    }\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Pointer to the Output Data Register (ODR) of the specified GPIO port\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *GPIO_ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *GPIO_ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin by accessing the input data register (IDR)\n * of the specified GPIO port. It calculates the bit position of the pin using a loop\n * to ensure accurate pin configuration.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask representing the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Access the input data register (IDR) of the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n\n    // Read the pin state and return it\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations using bitwise\n * XOR to flip the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *GPIO_ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "aad0c54e-1e8e-43dc-ba1f-6eb4fa00f6dc",
            "timestamp": "2024-10-31T10:38:50.161597",
            "total time (seconds)": 187.46352195739746,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a specific USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the offset for the USART_SR register.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written to it. It is a part of the USART status register (SR).\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n// on the STM32F407 microcontroller. This address is used to access\n// the RCC registers for configuring the clock system of the MCU.\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// USART_DR_OFFSET is the offset for the Data Register in the USART peripheral.\n// This offset is used to access the data register for reading or writing data.\n// The value is specific to the STM32F407 microcontroller series.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the clock is enabled by setting\n * the appropriate bit in the RCC_AHB1ENR register.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC and the offset for the AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Set the bit 0 of RCC_AHB1ENR to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin\n// Parameters:\n// - port_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: Mode to set (0 for input, 1 for output)\nvoid set_input_output_mode(uint32_t port_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position from the pin mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(port_base + 0x00);\n\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n\n    // Set the mode for the pin\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin by accessing the input data register (IDR)\n * of the specified GPIO port. It uses bitwise operations to determine the state of the pin.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the position of the pin by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Access the input data register (IDR) of the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n\n    // Read the state of the pin by checking the corresponding bit in the IDR\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations by using\n * bitwise XOR to flip the pin's state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *GPIO_ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "9bc27721-9bdf-4984-a10c-52a10ec690b2",
            "timestamp": "2024-10-31T10:41:21.549352",
            "total time (seconds)": 137.37849116325378,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the offset for the USART_SR register.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// USART_FLAG_TXE is a flag used to indicate that the USART transmit data register is empty.\n// This flag is used in the status register of the USART peripheral to check if the USART is ready to send more data.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Enable the clock for GPIOA by setting the appropriate bit in the RCC AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);  // Set bit 0 to enable GPIOA clock\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position from the pin mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n\n    // Set the mode: 0x1 for output, 0x0 for input\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin by accessing the input data register (IDR)\n * of the specified GPIO port. It calculates the bit position of the pin using a loop\n * to ensure accurate pin configuration.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Pointer to the input data register (IDR) of the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n\n    // Calculate the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the pin state from the IDR and return it\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations using bitwise XOR.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the specified pin using XOR operation\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "fcf6a114-fdac-4712-be9c-b57201fdbb33",
            "timestamp": "2024-10-31T14:29:15.284273",
            "total time (seconds)": 5.522446632385254,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register (SR).\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n// on the STM32F407 microcontroller. This address is used to access\n// the RCC registers for configuring the clock system of the MCU.\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference\n// manual for the STM32F407 series, which specifies the offset for the DR\n// register within the USART peripheral's register map.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the offset for the USART_SR register.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral\n// This offset is used to calculate the address of the BRR register for a given USART instance\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Enable the clock for GPIOA by setting the appropriate bit in the RCC AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin number from the pin mask\n    uint8_t pin_number = 0;\n    for (uint32_t mask = pin_mask; mask > 1; mask >>= 1) {\n        pin_number++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin in the MODER register\n    *GPIO_MODER &= ~(0x3 << (pin_number * 2));\n\n    // Set the mode for the pin (0x1 for output, 0x0 for input)\n    *GPIO_MODER |= (mode << (pin_number * 2));\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the input data register (IDR) of a specified GPIO port\n * and checks the state of a specific pin. It uses bitwise operations to\n * determine the state of the pin.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to read (e.g., 1 << 5 for pin 5).\n * \n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Pointer to the input data register (IDR) of the specified GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the state of the pin from the IDR and return it\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations using bitwise XOR.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the specified pin using XOR operation\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "cf889c8a-0679-487c-a870-59af2927a5b1",
            "timestamp": "2024-10-31T14:31:35.390551",
            "total time (seconds)": 114.158940076828,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// USART_FLAG_TXE is a flag used to indicate that the USART transmit data register is empty.\n// This flag is used in the status register of the USART peripheral to check if the USART is ready to send more data.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// USART_CR1_OFFSET is the offset for the Control Register 1 of the USART peripheral.\n// This offset is used to access the USART_CR1 register from the base address of a USART peripheral.\n// The value is specific to the STM32F407 microcontroller series.\n#define USART_CR1_OFFSET ((uint32_t)0x0000000C)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// The RCC_AHB1ENR register is used to enable the clock for peripherals connected to the AHB1 bus.\n// The offset is based on the STM32F407 reference manual, which specifies the memory map for the RCC registers.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the Data Register (DR) of the USART peripheral\n// on the STM32F407 microcontroller. This offset is used to access the\n// data register for reading and writing data to the USART peripheral.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the offset for the USART_SR register.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the clock is enabled by setting\n * the appropriate bit in the RCC_AHB1ENR register.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC and the offset for the AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Set the bit 0 of RCC_AHB1ENR to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin number from the pin mask\n    uint8_t pin_number = 0;\n    for (uint32_t mask = pin_mask; mask > 1; mask >>= 1) {\n        pin_number++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin in the MODER register\n    *GPIO_MODER &= ~(0x3 << (pin_number * 2));\n\n    // Set the mode for the pin\n    // 0x1 for output mode, 0x0 for input mode\n    *GPIO_MODER |= (mode & 0x1) << (pin_number * 2);\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 to reset, 1 to set).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin: use bitwise OR to set the specific bit\n        *ODR |= (1 << pin_position);\n    } else {\n        // Reset the pin: use bitwise AND with NOT to clear the specific bit\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin by accessing the input data register (IDR)\n * of the specified GPIO port. It uses bitwise operations to isolate the state of the desired pin.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the input data register (IDR) for the specified GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the state of the pin by checking the corresponding bit in the IDR\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It uses bitwise operations to ensure atomic\n * and reliable toggling of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "602a22e4-6a0f-4533-8141-0b5a6034cf30",
            "timestamp": "2024-10-31T14:33:46.091687",
            "total time (seconds)": 104.63240694999695,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written to it. It is a part of the USART status register (SR).\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n// on the STM32F407 microcontroller. This address is used to access\n// the RCC registers for configuring the clock system of the MCU.\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// USART_DR_OFFSET is the offset for the Data Register in the USART peripheral.\n// This offset is used to access the data register for reading or writing data.\n// The value is specific to the STM32F407 microcontroller series.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Enable the clock for GPIOA by setting the appropriate bit in the RCC AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    for (uint32_t mask = pin_mask; mask > 1; mask >>= 1) {\n        pin_position++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n\n    // Set the mode: 0x1 for output, 0x0 for input\n    *GPIO_MODER |= (mode & 0x1) << (pin_position * 2);\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin specified by the port base address and pin mask.\n * It calculates the pin position and checks the input data register (IDR) to determine if the pin is high or low.\n * \n * @param port_base_address The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t port_base_address, uint32_t pin_mask) {\n    // Calculate the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Define the input data register (IDR) offset for the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(port_base_address + 0x10);\n\n    // Read the pin state from the IDR and return 1 if high, 0 if low\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It uses bitwise operations to ensure atomic\n * and reliable toggling of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "c5d47944-66e6-47f7-85c1-0d173b4f916b",
            "timestamp": "2024-10-31T14:36:02.739438",
            "total time (seconds)": 108.9206030368805,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// USART_CR1_OFFSET is the offset for the Control Register 1 (CR1) of the USART peripheral.\n// This offset is used to access the CR1 register from the base address of a USART peripheral.\n// The value is specific to the STM32F407 microcontroller series.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the offset for the USART_SR register.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a specific USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x08)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the clock is enabled by setting\n * the appropriate bit in the register.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC and the offset for the AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Set the bit corresponding to GPIOA (bit 0) to enable its clock\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n\n    // Set the mode: 0x1 for output, 0x0 for input\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin specified by the port base address and pin mask.\n * It calculates the pin position and checks the input data register (IDR) to determine if the pin is high or low.\n * \n * @param port_base_address The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t port_base_address, uint32_t pin_mask) {\n    // Calculate the pin position by finding the first set bit in the pin mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Define the input data register (IDR) offset for the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(port_base_address + 0x10);\n\n    // Read the pin state from the IDR and return 1 if high, 0 if low\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It uses bitwise operations to ensure atomic\n * and reliable toggling of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "33c54bf2-0556-44f0-967b-1646827c6fb9",
            "timestamp": "2024-10-31T14:38:26.841622",
            "total time (seconds)": 117.96137881278992,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// USART_FLAG_TXE is a flag used to indicate that the USART transmit data register is empty.\n// This flag is typically used in USART status register to check if the USART is ready to send more data.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board\n// The USART2 peripheral is used for serial communication and is mapped to a specific memory address\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the USART Control Register 1 (CR1) from the base address of a USART peripheral.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// The RCC_AHB1ENR register is used to enable the clock for peripherals connected to the AHB1 bus.\n// The offset is based on the STM32F407 reference manual, which specifies the memory map for the RCC registers.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the offset for the USART_SR register.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a specific USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x08)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Enable the clock for GPIOA by setting the appropriate bit in the RCC AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin number from the pin mask\n    uint8_t pin_number = 0;\n    for (uint32_t mask = pin_mask; mask > 1; mask >>= 1) {\n        pin_number++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin in the MODER register\n    *GPIO_MODER &= ~(0x3 << (pin_number * 2));\n\n    // Set the mode for the pin\n    if (mode == 1) {\n        // Set as output\n        *GPIO_MODER |= (0x1 << (pin_number * 2));\n    } else {\n        // Set as input (default is already cleared)\n    }\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin by accessing the input data register (IDR)\n * of the specified GPIO port. It uses bitwise operations to determine the state of the pin.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the input data register (IDR) for the given GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the state of the pin from the IDR and return it\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations using bitwise XOR.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "65f9d50a-c632-40f5-a09d-dc1396f0655d",
            "timestamp": "2024-10-31T14:40:47.817576",
            "total time (seconds)": 115.02217221260071,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written to it. It is a part of the USART status register (SR).\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference\n// manual for the STM32F407, which specifies the offset for the DR register\n// within the USART peripheral's memory map.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the offset for the USART_SR register.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Enable the clock for GPIOA by setting the appropriate bit in the RCC AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bit mask for the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin number from the pin mask\n    uint8_t pin_number = 0;\n    while ((pin_mask >> pin_number) != 1) {\n        pin_number++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin in the MODER register\n    *GPIO_MODER &= ~(0x3 << (pin_number * 2));\n\n    // Set the mode for the pin\n    if (mode == 1) {\n        // Set as output\n        *GPIO_MODER |= (0x1 << (pin_number * 2));\n    } else {\n        // Set as input (default is already cleared)\n    }\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin specified by the port base address and pin mask.\n * It calculates the pin position and checks the input data register (IDR) to determine if the pin is high or low.\n * \n * @param port_base_address The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t port_base_address, uint32_t pin_mask) {\n    // Pointer to the input data register (IDR) of the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(port_base_address + 0x10);\n\n    // Calculate the pin position by finding the first set bit in the pin mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the pin state from the IDR and return 1 if high, 0 if low\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It uses bitwise operations to ensure atomic\n * and reliable toggling of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the specified pin by XORing the ODR with the pin mask\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "d76da03b-f9e4-4d89-9ecf-526f73b2bee8",
            "timestamp": "2024-11-01T19:56:52.580591",
            "total time (seconds)": 3.717970132827759,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is specific to the STM32F407 microcontroller series.\n#define USART_SR_OFFSET ((uint32_t)0x00000000)\n\n// Define the offset for the USART Data Register (DR) for the STM32F407 board.\n// This offset is used to access the data register of a USART peripheral.\n// The value is based on the STM32F407 reference manual.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n// on the STM32F407 microcontroller. This address is used to access\n// the RCC registers for configuring the clock system of the MCU.\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral\n// This offset is used to calculate the address of the BRR register for a given USART instance\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// USART_FLAG_TXE is a flag used to indicate that the USART transmit data register is empty.\n// This flag is typically used in USART communication to check if the USART is ready to send more data.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the clock is enabled by setting\n * the appropriate bit in the register.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Set the bit corresponding to GPIOA (bit 0) to enable its clock\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bit mask for the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin number from the pin mask\n    uint8_t pin_number = 0;\n    for (uint32_t mask = pin_mask; mask > 1; mask >>= 1) {\n        pin_number++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin in the MODER register\n    *GPIO_MODER &= ~(0x3 << (pin_number * 2));\n\n    // Set the mode for the pin\n    if (mode == 1) {\n        // Set as output\n        *GPIO_MODER |= (0x1 << (pin_number * 2));\n    } else {\n        // Set as input (default is already cleared)\n    }\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin specified by the port base address and pin number.\n * It calculates the pin position and checks the input data register (IDR) to determine if the pin is high or low.\n * \n * @param port_base_address The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t port_base_address, uint32_t pin_mask) {\n    // Pointer to the input data register (IDR) of the specified GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(port_base_address + 0x10);\n\n    // Calculate the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the pin state from the IDR and return 1 if high, 0 if low\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations by using\n * bitwise XOR to flip the pin's state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the specified pin by XORing the ODR with the pin mask\n    *GPIO_ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "30c8bf79-1415-410a-820b-1c07361633a3",
            "timestamp": "2024-11-01T20:02:29.886436",
            "total time (seconds)": 2.988801956176758,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference\n// manual for the STM32F407, which specifies the offset for the DR register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is specific to the STM32F407 microcontroller series.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// USART_FLAG_TXE is a flag used to indicate that the transmit data register is empty.\n// This flag is typically used in USART communication to check if the USART is ready to send more data.\n// The value 0x00000080 is a standard value for the TXE (Transmit Data Register Empty) flag in STM32 microcontrollers.\n#define USART_FLAG_TXE ((uint32_t)0x00000080)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC (Reset and Clock Control) block.\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock for AHB1 peripherals.\n// The value is specific to the STM32F407 microcontroller.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n// on the STM32F407 microcontroller. This address is used to access\n// the RCC registers for configuring the clock system of the MCU.\n#define RCC_BASE ((uint32_t)0x40023800)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Enable the clock for GPIOA by setting the appropriate bit in the RCC AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin number from the pin mask\n    uint8_t pin_number = 0;\n    while ((pin_mask >> pin_number) != 1) {\n        pin_number++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin in the MODER register\n    *GPIO_MODER &= ~(0x3 << (pin_number * 2));\n\n    // Set the mode for the pin\n    // If mode is 1, set the pin as output (01 in MODER)\n    // If mode is 0, set the pin as input (00 in MODER)\n    *GPIO_MODER |= (mode << (pin_number * 2));\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin by accessing the input data register (IDR)\n * of the specified GPIO port. It calculates the bit position of the pin using a loop\n * to ensure accurate pin configuration.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask representing the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Define the input data register (IDR) offset for the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n\n    // Read the pin state from the IDR and return the result\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It uses bitwise operations to ensure atomic\n * and reliable toggling of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the specified pin by XORing the ODR with the pin mask\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "b688bc0b-f11c-40bb-8583-4e14853ee695",
            "timestamp": "2024-11-01T20:04:03.636408",
            "total time (seconds)": 77.62521290779114,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference\n// manual for the STM32F407, which specifies the offset for the DR register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the offset for the USART_SR register.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral\n// This offset is used to calculate the address of the BRR register for a given USART instance\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// USART_FLAG_TXE is a flag used to indicate that the USART transmit data register is empty.\n// This flag is typically used in USART status register to check if the USART is ready to send more data.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n// on the STM32F407 microcontroller. This address is used to access\n// the RCC registers for configuring the clock system of the MCU.\n#define RCC_BASE ((uint32_t)0x40023800)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Enable the clock for GPIOA by setting the appropriate bit in the RCC AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n\n    // Set the mode: 0x1 for output, 0x0 for input\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin by accessing the input data register (IDR)\n * of the specified GPIO port. It uses bitwise operations to determine the state of the pin.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Pointer to the input data register (IDR) of the specified GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the state of the pin by checking the corresponding bit in the IDR\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations using bitwise XOR.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *GPIO_ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "40dcc563-bb46-447c-b47c-cd85c3abe5bd",
            "timestamp": "2024-11-01T20:05:41.309696",
            "total time (seconds)": 81.75810885429382,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference\n// manual for the STM32F407, which specifies the offset for the DR register\n// within the USART peripheral's register map.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is specific to the STM32F407 microcontroller series.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral\n// This offset is used to calculate the address of the BRR register for a given USART instance\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be sent. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Enable the clock for GPIOA by setting the appropriate bit in the RCC AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin number from the pin mask\n    uint8_t pin_number = 0;\n    while ((pin_mask >> pin_number) != 1) {\n        pin_number++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin in the MODER register\n    *GPIO_MODER &= ~(0x3 << (pin_number * 2));\n\n    // Set the mode for the pin\n    if (mode == 1) {\n        // Set as output\n        *GPIO_MODER |= (0x1 << (pin_number * 2));\n    } else {\n        // Set as input (default is already 0, so no need to set)\n    }\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin specified by the port base address\n * and the pin mask. It calculates the pin position and checks the input data register\n * to determine if the pin is set high or low.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Pointer to the input data register (IDR) of the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n\n    // Calculate the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the pin state from the IDR and return 1 if high, 0 if low\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations using bitwise\n * XOR to flip the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the specified pin using XOR operation\n    *GPIO_ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "1b85bcad-bd49-4d6e-b005-d37cf22261f8",
            "timestamp": "2024-11-01T20:07:18.884933",
            "total time (seconds)": 82.56662917137146,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART Data Register (DR) for the STM32F407 board.\n// This offset is used to access the data register of a USART peripheral.\n// The value is based on the STM32F407 reference manual.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is based on the STM32F407 reference manual.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x08)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Enable the clock for GPIOA by setting the 0th bit of the RCC_AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    for (uint32_t mask = pin_mask; mask > 1; mask >>= 1) {\n        pin_position++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n\n    // Set the mode: 0x1 for output, 0x0 for input\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin by accessing the input data register (IDR)\n * of the specified GPIO port. It calculates the bit position of the pin using a loop\n * to ensure accurate pin configuration.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask representing the pin to read (e.g., 1 << 5 for pin 5).\n * \n * @return 1 if the pin is set (high), 0 if the pin is reset (low).\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Pointer to the input data register (IDR) of the specified GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n\n    // Calculate the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the pin state from the IDR and return the result\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It uses bitwise operations to ensure atomic\n * and reliable toggling of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "aba0ab87-5f58-4da9-9bc2-ef9d488266db",
            "timestamp": "2024-11-01T20:09:38.340807",
            "total time (seconds)": 123.3441572189331,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// USART_DR_OFFSET is the offset for the Data Register in the USART peripheral.\n// This offset is used to access the data register for reading or writing data.\n// The value is specific to the STM32F407 microcontroller series.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is specific to the STM32F407 microcontroller series.\n#define USART_SR_OFFSET ((uint32_t)0x00000000)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral\n// This offset is used to calculate the address of the BRR register for a given USART instance\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// USART_CR1_OFFSET is the offset for the Control Register 1 of the USART peripheral.\n// This offset is used to access the USART_CR1 register from the base address of a USART peripheral.\n// The value is specific to the STM32F407 microcontroller series.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the USART transmit data register is empty\n// and ready to accept new data for transmission. The value is based on the\n// STM32F407 reference manual, where the TXE flag is typically represented\n// by the bit position in the status register.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// The RCC_AHB1ENR register is used to enable the clock for peripherals connected to the AHB1 bus.\n// The offset is based on the STM32F407 reference manual, which specifies the memory map for the RCC registers.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the clock is enabled by setting\n * the appropriate bit in the RCC_AHB1ENR register.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC and the offset for the AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Enable the clock for GPIOA by setting the 0th bit of the RCC_AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin number from the pin mask\n    uint8_t pin_number = 0;\n    while ((pin_mask >> pin_number) != 1) {\n        pin_number++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin in the MODER register\n    *GPIO_MODER &= ~(0x3 << (pin_number * 2));\n\n    // Set the mode for the pin\n    if (mode == 1) {\n        // Set as output\n        *GPIO_MODER |= (0x1 << (pin_number * 2));\n    } else {\n        // Set as input (default is already 0, so no need to set)\n    }\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Pointer to the Output Data Register (ODR) of the specified GPIO port\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14); // ODR offset is 0x14\n\n    if (value) {\n        // Set the pin: Use bitwise OR to set the specific pin bit\n        *GPIO_ODR |= pin_mask;\n    } else {\n        // Reset the pin: Use bitwise AND with NOT to clear the specific pin bit\n        *GPIO_ODR &= ~pin_mask;\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin by accessing the input data register (IDR)\n * of the specified GPIO port. It calculates the bit position of the pin using a loop\n * to ensure accurate pin configuration.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask representing the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Pointer to the input data register (IDR) of the specified GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n\n    // Calculate the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the pin state from the IDR and return 1 if high, 0 if low\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of the specified GPIO port\n * to toggle the state of a given pin. It ensures atomic operations using bitwise XOR.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the specified pin using XOR operation\n    *GPIO_ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "0ec79a49-65f8-45ed-9fee-32fa632eeffe",
            "timestamp": "2024-11-01T20:11:29.576215",
            "total time (seconds)": 97.22310733795166,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is specific to the STM32F407 microcontroller series.\n#define USART_SR_OFFSET ((uint32_t)0x00000000)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a specific USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready to accept new data for transmission.\n// The value is based on the STM32F407 reference manual, where the TXE flag\n// is typically represented by the bit position in the status register.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 microcontroller.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Enable the clock for GPIOA by setting the appropriate bit in the RCC AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin number from the pin mask\n    uint8_t pin_number = 0;\n    while ((pin_mask >> pin_number) != 1) {\n        pin_number++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin in the MODER register\n    *GPIO_MODER &= ~(0x3 << (pin_number * 2));\n\n    // Set the mode for the pin\n    // 0x1 for output mode, 0x0 for input mode\n    *GPIO_MODER |= (mode << (pin_number * 2));\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin specified by the port base address and pin number.\n * It calculates the pin position and checks the input data register (IDR) to determine if the pin is high or low.\n * \n * @param port_base_address The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t port_base_address, uint32_t pin_mask) {\n    // Pointer to the input data register (IDR) of the specified GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(port_base_address + 0x10);\n\n    // Calculate the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the pin state from the IDR and return 1 if high, 0 if low\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It uses bitwise operations to ensure atomic\n * and reliable toggling of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "a47cf120-6fe6-4387-aa98-a35a25733c42",
            "timestamp": "2024-11-01T20:13:51.736447",
            "total time (seconds)": 128.25209856033325,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the offset for the USART_SR register.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the USART transmit data register is empty\n// and ready to accept new data for transmission. The value is based on the\n// STM32F407 reference manual, where the TXE flag is typically represented by\n// the bit position in the status register.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Enable the clock for GPIOA by setting the 0th bit of the RCC_AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n\n    // Set the mode for the pin\n    if (mode == 1) {\n        // Set as output\n        *GPIO_MODER |= (0x1 << (pin_position * 2));\n    } else {\n        // Set as input (default is already cleared)\n    }\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin by accessing the input data register (IDR)\n * of the specified GPIO port. It uses bitwise operations to determine the state of the pin.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the position of the pin by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Define a pointer to the input data register (IDR) of the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n\n    // Read the state of the pin by checking the corresponding bit in the IDR\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of the specified GPIO port\n * to toggle the state of a given pin. It ensures atomic operations using bitwise XOR.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the specified pin using XOR operation\n    *GPIO_ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "d6e6cbf1-1b82-4cd5-87b0-47190a5dc129",
            "timestamp": "2024-11-01T20:15:26.558878",
            "total time (seconds)": 80.33445858955383,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// USART_DR_OFFSET is the offset for the Data Register in the USART peripheral.\n// This offset is used to access the data register for reading or writing data.\n// The value is specific to the STM32F407 microcontroller series.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is specific to the STM32F407 microcontroller series.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral\n// This offset is used to calculate the address of the BRR register for a given USART instance\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n#define USART_FLAG_TXE ((uint16_t)0x0080) // USART Transmit Data Register Empty flag: This flag is set when the transmit data register is empty and ready to accept new data.\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Enable the clock for GPIOA by setting the appropriate bit in the RCC AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin number from the pin mask\n    uint8_t pin_number = 0;\n    while ((pin_mask >> pin_number) != 1) {\n        pin_number++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin in the MODER register\n    *GPIO_MODER &= ~(0x3 << (pin_number * 2));\n\n    // Set the mode for the pin (0x1 for output, 0x0 for input)\n    *GPIO_MODER |= (mode << (pin_number * 2));\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin specified by the port base address and pin mask.\n * It calculates the pin position and checks the input data register (IDR) to determine if the pin is high or low.\n * \n * @param port_base_address The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t port_base_address, uint32_t pin_mask) {\n    // Calculate the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask & 1) == 0) {\n        pin_mask >>= 1;\n        pin_position++;\n    }\n\n    // Define the input data register (IDR) offset for the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(port_base_address + 0x10);\n\n    // Read the pin state from the IDR and return 1 if high, 0 if low\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of the specified GPIO port\n * to toggle the state of a given pin. It ensures atomic operations using bitwise XOR.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the specified pin using XOR operation\n    *GPIO_ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "34aa941a-42be-4b78-9b0a-30aa1bb83f8d",
            "timestamp": "2024-11-01T20:16:53.934497",
            "total time (seconds)": 72.54111337661743,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference\n// manual for the STM32F407, which specifies the offset for the DR register\n// within the USART peripheral's register map.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is specific to the STM32F407 microcontroller series.\n#define USART_SR_OFFSET ((uint32_t)0x00000000)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written to it. It is a part of the USART status register (SR).\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n// on the STM32F407 microcontroller. This address is used to access\n// the RCC registers for configuring the clock system of the MCU.\n#define RCC_BASE ((uint32_t)0x40023800)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Enable the clock for GPIOA by setting the appropriate bit in the RCC AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin number from the pin mask\n    uint8_t pin_number = 0;\n    while ((pin_mask >> pin_number) != 1) {\n        pin_number++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin in the MODER register\n    *GPIO_MODER &= ~(0x3 << (pin_number * 2));\n\n    // Set the mode for the pin\n    if (mode == 1) {\n        // Set as output\n        *GPIO_MODER |= (0x1 << (pin_number * 2));\n    } else {\n        // Set as input (default is already cleared)\n    }\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin specified by the port base address and pin mask.\n * It calculates the pin position and checks the input data register (IDR) to determine if the pin is high or low.\n * \n * @param port_base_address The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t port_base_address, uint32_t pin_mask) {\n    // Pointer to the input data register (IDR) of the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(port_base_address + 0x10);\n\n    // Calculate the pin position by finding the first set bit in the pin mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the pin state from the IDR and return 1 if high, 0 if low\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations using bitwise XOR.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "7216379b-0fe5-4532-9856-19a577459ca1",
            "timestamp": "2024-11-01T20:18:18.028010",
            "total time (seconds)": 69.18241119384766,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference manual\n// which specifies the offset for the USART_DR register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is specific to the STM32F407 microcontroller series.\n#define USART_SR_OFFSET ((uint32_t)0x00000000)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral\n// This offset is used to calculate the address of the BRR register for a given USART instance\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// USART_CR1_OFFSET is the offset for the Control Register 1 of the USART peripheral.\n// This offset is used to access the USART_CR1 register from the base address of a USART peripheral.\n// The value is specific to the STM32F407 microcontroller series.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n#define USART_FLAG_TXE ((uint16_t)0x0080) // USART Transmit Data Register Empty flag: This flag is set when the transmit data register is empty and ready for new data.\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n// on the STM32F407 microcontroller. This address is used to access\n// the RCC registers for configuring the clock system of the MCU.\n#define RCC_BASE ((uint32_t)0x40023800)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the clock is enabled by setting\n * the appropriate bit in the RCC_AHB1ENR register.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC and the offset for the AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Set the bit 0 of RCC_AHB1ENR to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n\n    // Set the mode: 0x1 for output, 0x0 for input\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin by accessing the input data register (IDR)\n * of the specified GPIO port. It calculates the bit position of the pin using a loop\n * to ensure accurate pin configuration.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask representing the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Pointer to the input data register (IDR) of the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n\n    // Calculate the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the pin state from the IDR and return it\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It uses bitwise operations to ensure atomic\n * and reliable toggling of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the specified pin by XORing the ODR with the pin mask\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "9a4cbdb3-5581-486b-82e3-c8ca5c7ee224",
            "timestamp": "2024-11-01T20:20:49.161273",
            "total time (seconds)": 136.6339967250824,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference\n// manual for the STM32F407, which specifies the offset for the DR register\n// within the USART peripheral's register map.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is based on the STM32F407 reference manual.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral\n// This offset is used to calculate the address of the BRR register for a given USART instance\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// USART_FLAG_TXE is a flag used to indicate that the transmit data register is empty.\n// This flag is typically used in USART communication to check if the USART is ready to send more data.\n// The value 0x00000080 is used based on the STM32F407 reference manual, where the TXE flag is the 7th bit in the USART_SR register.\n#define USART_FLAG_TXE ((uint32_t)0x00000080)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Enable the clock for GPIOA by setting the appropriate bit in the RCC AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n\n    // Set the mode for the pin\n    if (mode == 1) {\n        // Set as output\n        *GPIO_MODER |= (0x1 << (pin_position * 2));\n    } else {\n        // Set as input (default is already cleared)\n    }\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin by accessing the input data register (IDR)\n * of the specified GPIO port. It calculates the bit position of the pin using a loop\n * to ensure accurate pin configuration.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Pointer to the input data register (IDR) of the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n\n    // Calculate the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the pin state from the IDR and return it\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It uses bitwise operations to ensure atomic\n * and reliable toggling of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "97cfb0fe-8686-42bf-8726-fc9284116e35",
            "timestamp": "2024-11-01T20:23:21.774088",
            "total time (seconds)": 138.28021121025085,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// USART_DR_OFFSET is the offset for the Data Register in the USART peripheral.\n// This offset is used to access the data register for reading or writing data.\n// The value is specific to the STM32F407 microcontroller series.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is based on the STM32F407 reference manual.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for the next byte to be sent. It is a part of the USART status register (SR).\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Enable the clock for GPIOA by setting the 0th bit of the RCC_AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position from the pin mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n\n    // Set the mode for the pin\n    if (mode == 1) {\n        // Set as output\n        *GPIO_MODER |= (0x1 << (pin_position * 2));\n    } else {\n        // Set as input (default is already cleared)\n    }\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin specified by the port base address and pin mask.\n * It calculates the pin position and checks the input data register (IDR) to determine if the pin is high or low.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Define the input data register (IDR) offset for the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n\n    // Read the pin state from the IDR and return 1 if high, 0 if low\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It uses bitwise operations to ensure atomic\n * and reliable toggling of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "4cdbedb1-52c1-496d-967c-a4b72835aa9d",
            "timestamp": "2024-11-01T20:25:07.619159",
            "total time (seconds)": 91.94378733634949,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference\n// manual for the STM32F407, which specifies the offset for the DR register\n// within the USART peripheral's register map.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is based on the STM32F407 reference manual.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// USART_CR1_OFFSET is the offset for the Control Register 1 of the USART peripheral.\n// This offset is used to access the USART_CR1 register from the base address of a USART peripheral.\n// The value is specific to the STM32F407 microcontroller series.\n#define USART_CR1_OFFSET ((uint32_t)0x0000000C)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Enable the clock for GPIOA by setting the 0th bit of the RCC_AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bit mask for the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position from the pin mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n\n    // Set the mode for the pin\n    if (mode == 1) {\n        // Set as output\n        *GPIO_MODER |= (0x1 << (pin_position * 2));\n    } else {\n        // Set as input (default is already cleared)\n    }\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin by accessing the input data register (IDR)\n * of the specified GPIO port. It uses bitwise operations to determine the state of the pin.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Pointer to the input data register (IDR) of the specified GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the state of the pin by checking the corresponding bit in the IDR\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It uses bitwise operations to ensure atomic\n * and reliable toggling of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the specified pin by XORing the ODR with the pin mask\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "ff361866-d230-44be-bc21-b232e1314d75",
            "timestamp": "2024-11-01T20:26:39.946341",
            "total time (seconds)": 77.72188639640808,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference manual.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is based on the STM32F407 reference manual.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x08)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the USART transmit data register is empty\n// and ready to accept new data for transmission. The value is based on the\n// STM32F407 reference manual, where the TXE flag is typically represented\n// by the bit position in the status register.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Enable the clock for GPIOA by setting the appropriate bit in the RCC AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n\n    // Set the mode: 0x1 for output, 0x0 for input\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Pointer to the Output Data Register (ODR) of the specified GPIO port\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Calculate the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    for (uint32_t mask = pin_mask; mask > 1; mask >>= 1) {\n        pin_position++;\n    }\n\n    // Write the value to the specified pin\n    if (value) {\n        // Set the pin: Use bitwise OR to set the bit at pin_position\n        *GPIO_ODR |= (1 << pin_position);\n    } else {\n        // Reset the pin: Use bitwise AND with NOT to clear the bit at pin_position\n        *GPIO_ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin by accessing the input data register (IDR)\n * of the specified GPIO port. It calculates the bit position of the pin using a loop\n * and returns the state of the pin.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Pointer to the input data register (IDR) of the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n\n    // Calculate the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the pin state from the IDR and return it\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of the GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations using bitwise XOR.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "ac454a5b-4f86-48a0-a93d-5abb63eed26c",
            "timestamp": "2024-11-01T20:28:52.648849",
            "total time (seconds)": 118.06250071525574,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference manual\n// for the STM32F407, which specifies the offset for the USART_DR register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the offset for the USART_SR register.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// USART_CR1_OFFSET is the offset for the Control Register 1 of the USART peripheral.\n// This offset is used to access the USART_CR1 register from the base address of a USART peripheral.\n// The value is specific to the STM32F407 microcontroller series.\n#define USART_CR1_OFFSET ((uint32_t)0x0000000C)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the USART transmit data register is empty\n// and ready to accept new data for transmission. It is a part of the USART status register (SR).\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Enable the clock for GPIOA by setting the 0th bit of the RCC_AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin number from the pin mask\n    uint8_t pin_number = 0;\n    for (uint32_t mask = pin_mask; mask > 1; mask >>= 1) {\n        pin_number++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin in the MODER register\n    *GPIO_MODER &= ~(0x3 << (pin_number * 2));\n\n    // Set the mode for the pin (0x1 for output, 0x0 for input)\n    *GPIO_MODER |= (mode << (pin_number * 2));\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin specified by the port base address and pin mask.\n * It calculates the pin position and checks the input data register (IDR) to determine if the pin is high or low.\n * \n * @param port_base_address The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t port_base_address, uint32_t pin_mask) {\n    // Pointer to the input data register (IDR) of the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(port_base_address + 0x10);\n\n    // Calculate the pin position by finding the first set bit in the pin mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the pin state from the IDR and return 1 if high, 0 if low\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations using bitwise XOR.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the specified pin using XOR operation\n    *GPIO_ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "b1db933f-4bbd-4c3d-a035-63c850bf532d",
            "timestamp": "2024-11-01T20:31:12.775535",
            "total time (seconds)": 125.4896445274353,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference\n// manual for the STM32F407, which specifies the offset for the DR register\n// within the USART peripheral's register map.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is specific to the STM32F407 microcontroller series.\n#define USART_SR_OFFSET ((uint32_t)0x00000000)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral\n// This offset is used to calculate the address of the BRR register for a given USART instance\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Enable the clock for GPIOA by setting the appropriate bit in the RCC AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n\n    // Set the mode: 0x1 for output, 0x0 for input\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin by accessing the input data register (IDR)\n * of the specified GPIO port. It calculates the bit position of the pin using a loop\n * to ensure accurate pin configuration.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask representing the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Access the input data register (IDR) of the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n\n    // Read the pin state and return it\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It uses bitwise operations to ensure atomic\n * and reliable toggling of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "a3891fa0-2e1d-4fb0-9c63-8b3700f34b99",
            "timestamp": "2024-11-01T20:33:53.197298",
            "total time (seconds)": 145.98395013809204,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART Data Register (DR) for the STM32F407 board.\n// This offset is used to access the data register of a USART peripheral.\n// The value is based on the STM32F407 reference manual.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is based on the STM32F407 reference manual.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready to accept new data for transmission. It is a part of the USART\n// status register (USART_SR) and is typically used in USART communication\n// to check if the transmitter is ready to send the next byte of data.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 microcontroller.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n// on the STM32F407 microcontroller. This address is used to access\n// the RCC registers for configuring the clock system of the MCU.\n#define RCC_BASE ((uint32_t)0x40023800)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the clock is enabled by setting\n * the appropriate bit in the RCC_AHB1ENR register.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC and the offset for the AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Set the bit 0 of RCC_AHB1ENR to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n\n    // Set the mode: 0x1 for output, 0x0 for input\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin by accessing the input data register (IDR)\n * of the specified GPIO port. It calculates the bit position of the pin using a loop\n * and returns the state of the pin.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Pointer to the input data register (IDR) of the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n\n    // Calculate the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the pin state from the IDR and return it\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations using bitwise XOR.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "9f8962e9-ed5a-48b0-a0a9-732af15fc8eb",
            "timestamp": "2024-11-01T20:35:40.491156",
            "total time (seconds)": 93.04121994972229,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART instance.\n// The value is based on the STM32F407 reference manual.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is specific to the STM32F407 microcontroller series.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the USART transmit data register is empty\n// and ready to accept new data for transmission. It is a part of the USART status register (SR).\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// The RCC_AHB1ENR register is used to enable the clock for peripherals connected to the AHB1 bus.\n// The offset is based on the STM32F407 reference manual, which specifies the memory map for the RCC registers.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the clock is enabled by setting\n * the appropriate bit in the register.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC and the offset for the AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Set the bit 0 of RCC_AHB1ENR to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n\n    // Set the mode: 0x1 for output, 0x0 for input\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin by accessing the input data register (IDR)\n * of the specified GPIO port. It uses bitwise operations to determine the state of the pin.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the input data register (IDR) for the given GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the state of the pin from the IDR and return it\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of the specified GPIO port\n * to toggle the state of a given pin. It ensures atomic operations using bitwise XOR.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the specified pin using XOR operation\n    *GPIO_ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "bb3b5807-a27c-49c0-8d76-dd4227c6660a",
            "timestamp": "2024-11-01T20:37:12.491187",
            "total time (seconds)": 77.77768158912659,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference\n// manual for the STM32F407, which specifies the offset for the DR register\n// within the USART peripheral's register map.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is based on the STM32F407 reference manual.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the USART transmit data register is empty\n// and ready to accept new data for transmission. The value is based on the\n// STM32F407 reference manual, where the TXE flag is typically represented by\n// the bit position in the status register.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Enable the clock for GPIOA by setting the appropriate bit in the RCC AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n\n    // Set the mode: 0x1 for output, 0x0 for input\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin by accessing the input data register (IDR)\n * of the specified GPIO port. It calculates the bit position of the pin using a loop\n * and returns the state of the pin.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Pointer to the input data register (IDR) of the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n\n    // Calculate the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the pin state from the IDR and return it\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It uses bitwise operations to ensure atomic\n * and reliable toggling of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "6a551eb1-faa2-4d15-8160-f0c407a4f3d4",
            "timestamp": "2024-11-01T20:39:58.822394",
            "total time (seconds)": 152.16244053840637,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference\n// manual for the STM32F407, which specifies the offset for the DR register\n// within the USART peripheral's register map.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is based on the STM32F407 reference manual.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, where the BRR register is located\n// at an offset of 0x08 from the base address of the USART peripheral.\n#define USART_BRR_OFFSET ((uint32_t)0x08)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC (Reset and Clock Control) block.\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock for AHB1 peripherals.\n// The offset value is based on the STM32F407 reference manual.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the clock is enabled by setting\n * the appropriate bit in the RCC_AHB1ENR register.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC and the offset for the AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Enable the clock for GPIOA by setting the 0th bit in the RCC_AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n\n    // Set the mode: 0x1 for output, 0x0 for input\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin specified by the port base address and pin mask.\n * It calculates the pin position and checks the input data register (IDR) to determine if the pin is high or low.\n * \n * @param port_base_address The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t port_base_address, uint32_t pin_mask) {\n    // Calculate the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Define the input data register (IDR) offset for the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(port_base_address + 0x10);\n\n    // Read the pin state from the IDR and return 1 if high, 0 if low\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations using bitwise XOR.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the specified pin using XOR operation\n    *GPIO_ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "b003ff86-ab2c-467f-be43-b4bc5ad67ab8",
            "timestamp": "2024-11-01T20:42:18.602841",
            "total time (seconds)": 125.04717493057251,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference manual\n// for the STM32F407, which specifies the offset for the USART_DR register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is based on the STM32F407 reference manual.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral\n// This offset is used to calculate the address of the BRR register for a given USART instance\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Enable the clock for GPIOA by setting the appropriate bit in the RCC AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n\n    // Set the mode: 0x1 for output, 0x0 for input\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin specified by the port base address and pin mask.\n * It calculates the pin position and checks the input data register (IDR) to determine if the pin is high or low.\n * \n * @param port_base_address The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t port_base_address, uint32_t pin_mask) {\n    // Calculate the pin position by finding the first set bit in the pin mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Define the input data register (IDR) offset for the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(port_base_address + 0x10);\n\n    // Read the pin state from the IDR and return 1 if high, 0 if low\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It uses bitwise operations to ensure atomic\n * and reliable toggling of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "3f48c50a-338b-4a63-b954-51852f9e8da3",
            "timestamp": "2024-11-01T20:43:47.797496",
            "total time (seconds)": 74.19334292411804,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is specific to the STM32F407 microcontroller series.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral\n// This offset is used to calculate the address of the BRR register for a given USART instance\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the USART transmit data register is empty\n// and ready to accept new data for transmission. The value is based on the\n// STM32F407 reference manual, where the TXE flag is typically represented\n// by the bit position in the status register.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// The RCC_AHB1ENR register is used to enable the clock for peripherals connected to the AHB1 bus.\n// The offset is based on the STM32F407 reference manual, which specifies the memory map for the RCC registers.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the base address for USART2 peripheral on the STM32F407 board\n// The USART2 peripheral is used for serial communication and is mapped to a specific memory address\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the clock is enabled by setting\n * the appropriate bit in the RCC_AHB1ENR register.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC and the offset for the AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Set the bit 0 of RCC_AHB1ENR to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n\n    // Set the mode: 0x1 for output, 0x0 for input\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 to reset, 1 to set).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin: Use bitwise OR to set the specific bit\n        *ODR |= (1 << pin_position);\n    } else {\n        // Reset the pin: Use bitwise AND with NOT to clear the specific bit\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin by accessing the input data register (IDR)\n * of the specified GPIO port. It calculates the bit position of the pin using a loop\n * to ensure accurate pin configuration.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask representing the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Pointer to the input data register (IDR) of the specified GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n\n    // Calculate the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the pin state from the IDR and return it\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations using bitwise XOR.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *GPIO_ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "bfbe3a3a-c2aa-435e-b833-759c009e0575",
            "timestamp": "2024-11-01T20:45:16.941226",
            "total time (seconds)": 74.3570146560669,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// USART_DR_OFFSET is the offset for the Data Register in the USART peripheral.\n// This offset is used to access the data register for reading or writing data.\n// The value is specific to the STM32F407 microcontroller series.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is specific to the STM32F407 microcontroller series.\n#define USART_SR_OFFSET ((uint32_t)0x00000000)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the USART transmit data register is empty\n// and ready to accept new data for transmission. It is a part of the USART status register (SR).\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 microcontroller.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Enable the clock for GPIOA by setting the appropriate bit in the RCC AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin number from the pin mask\n    uint8_t pin_number = 0;\n    while ((pin_mask >> pin_number) != 1) {\n        pin_number++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin in the MODER register\n    *GPIO_MODER &= ~(0x3 << (pin_number * 2));\n\n    // Set the mode for the pin\n    if (mode == 1) {\n        // Set as output\n        *GPIO_MODER |= (0x1 << (pin_number * 2));\n    } else {\n        // Set as input (default is already cleared)\n    }\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin by accessing the input data register (IDR)\n * of the specified GPIO port. It uses bitwise operations to determine the state of the pin.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the input data register (IDR) for the given GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the state of the pin from the IDR and return it\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations using bitwise XOR.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the specified pin using XOR operation\n    *GPIO_ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "a2726376-22ae-41e5-8ea3-12cdfcd388e5",
            "timestamp": "2024-11-01T20:47:21.350198",
            "total time (seconds)": 109.78051924705505,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference\n// manual for the STM32F407, which specifies the offset for the DR register\n// within the USART peripheral's register map.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is specific to the STM32F407 microcontroller series.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready to accept new data for transmission.\n// The value is based on the STM32F407 reference manual, where the TXE flag\n// is typically represented by the bit position 7 in the USART status register.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC (Reset and Clock Control) block.\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock for AHB1 peripherals.\n// The value is specific to the STM32F407 microcontroller.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Enable the clock for GPIOA by setting the appropriate bit in the RCC AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    for (uint32_t mask = pin_mask; mask > 1; mask >>= 1) {\n        pin_position++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n\n    // Set the mode: 0x1 for output, 0x0 for input\n    *GPIO_MODER |= (mode & 0x1) << (pin_position * 2);\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin by accessing the input data register (IDR)\n * of the specified GPIO port. It uses bitwise operations to determine the state of the pin.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the input data register (IDR) for the given GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the state of the pin from the IDR and return it\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations using bitwise XOR.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the specified pin using XOR operation\n    *GPIO_ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "3ba9b2ce-45a8-41ad-bd43-a605e3f706e8",
            "timestamp": "2024-11-01T20:50:09.170236",
            "total time (seconds)": 153.32370138168335,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference manual\n// for the STM32F407, which specifies the offset for the USART_DR register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the offset for the USART_SR register.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the offset for the BRR register.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The USART_CR1 register is used to configure various settings of the USART peripheral,\n// such as enabling the USART, setting the word length, parity, and enabling interrupts.\n#define USART_CR1_OFFSET ((uint32_t)0x0000000C)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n// on the STM32F407 microcontroller. This address is used to access\n// the RCC registers for configuring the clock system of the MCU.\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC (Reset and Clock Control) block.\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock for AHB1 peripherals.\n// The offset value is based on the STM32F407 reference manual.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the clock is enabled before any\n * GPIOA operations are performed.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Enable the clock for GPIOA by setting the appropriate bit in the RCC AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n\n    // Set the mode: 0x1 for output, 0x0 for input\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin specified by the port base address\n * and the pin mask. It calculates the pin position and checks the input data register\n * to determine if the pin is set high or low.\n * \n * @param port_base_address The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t port_base_address, uint32_t pin_mask) {\n    // Pointer to the input data register (IDR) of the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(port_base_address + 0x10);\n\n    // Calculate the pin position by finding the first set bit in the pin mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the pin state from the IDR and return 1 if high, 0 if low\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations using bitwise XOR.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *GPIO_ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "9047a505-c279-40d5-a41c-8a9bbb37d0cf",
            "timestamp": "2024-11-01T20:52:19.205550",
            "total time (seconds)": 115.79613900184631,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// USART_DR_OFFSET is the offset for the Data Register in the USART peripheral.\n// This offset is used to access the data register for reading or writing data.\n// The value is specific to the STM32F407 microcontroller series.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is specific to the STM32F407 microcontroller series.\n#define USART_SR_OFFSET ((uint32_t)0x00000000)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral\n// This offset is used to calculate the address of the BRR register for a given USART instance\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// USART_CR1_OFFSET is the offset for the Control Register 1 of the USART peripheral.\n// This offset is used to access the USART_CR1 register from the base address of a USART peripheral.\n// The value is specific to the STM32F407 microcontroller series.\n#define USART_CR1_OFFSET ((uint32_t)0x0000000C)\n\n#define USART_FLAG_TXE ((uint16_t)0x0080) // USART Transmit Data Register Empty flag: This flag is set when the transmit data register is empty and ready for new data.\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 microcontroller.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the clock is enabled by setting\n * the appropriate bit in the RCC_AHB1ENR register.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC and the offset for the AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Enable the clock for GPIOA by setting the 0th bit of the RCC_AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n\n    // Set the mode: 0x1 for output, 0x0 for input\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin by accessing the input data register (IDR)\n * of the specified GPIO port. It calculates the bit position of the pin using a loop\n * to ensure accurate pin configuration.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * \n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Pointer to the input data register (IDR) of the specified GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n\n    // Calculate the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the pin state from the IDR and return it\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations using bitwise\n * XOR to flip the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *GPIO_ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "9b6eb83f-83b2-40a8-a8b4-868e07452d99",
            "timestamp": "2024-11-01T20:54:42.386223",
            "total time (seconds)": 128.80013465881348,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference manual\n// which specifies the offset for the USART_DR register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is based on the STM32F407 reference manual.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a specific USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x08)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the USART transmit data register is empty\n// and ready to accept new data for transmission. The value is based on the\n// STM32F407 reference manual, where the TXE flag is typically represented by\n// a specific bit in the USART status register (SR).\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Enable the clock for GPIOA by setting the appropriate bit in the RCC AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n\n    // Set the mode: 0x1 for output, 0x0 for input\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin by accessing the input data register (IDR)\n * of the specified GPIO port. It uses bitwise operations to determine the state of the pin.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the input data register (IDR) for the given GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the state of the pin from the IDR and return it\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations using bitwise\n * XOR to flip the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *GPIO_ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "89895a90-4098-4ff0-a7a9-1d8354f68e43",
            "timestamp": "2024-11-01T20:56:58.845472",
            "total time (seconds)": 122.10337042808533,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference\n// manual for the STM32F407, which specifies the offset for the DR register\n// within the USART peripheral's register map.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is based on the STM32F407 reference manual.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register (SR).\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC (Reset and Clock Control) block.\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock for AHB1 peripherals.\n// The offset value is based on the STM32F407 reference manual.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n// on the STM32F407 microcontroller. This address is used to access\n// the RCC registers for configuring the clock system of the MCU.\n#define RCC_BASE ((uint32_t)0x40023800)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the clock is enabled by setting\n * the appropriate bit in the register.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Set the bit corresponding to GPIOA (bit 0) to enable its clock\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bit mask for the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin number from the pin mask\n    uint8_t pin_number = 0;\n    for (uint32_t mask = pin_mask; mask > 1; mask >>= 1) {\n        pin_number++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin in the MODER register\n    *GPIO_MODER &= ~(0x3 << (pin_number * 2));\n\n    // Set the mode for the pin\n    if (mode == 1) {\n        // Set as output\n        *GPIO_MODER |= (0x1 << (pin_number * 2));\n    } else {\n        // Set as input (default is already cleared)\n    }\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin specified by the port base address and pin mask.\n * It calculates the pin position and checks the input data register (IDR) to determine if the pin is high or low.\n * \n * @param port_base_address The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t port_base_address, uint32_t pin_mask) {\n    // Pointer to the input data register (IDR) of the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(port_base_address + 0x10);\n\n    // Calculate the pin position by finding the first set bit in the pin mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the pin state from the IDR and return 1 if high, 0 if low\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of the specified GPIO port\n * to toggle the state of a given pin. It ensures atomic operations using bitwise XOR.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the specified pin using XOR operation\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "6c28d8ba-f90b-4319-a262-c2f7cdda7c2b",
            "timestamp": "2024-11-01T20:58:47.409549",
            "total time (seconds)": 94.05801558494568,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// USART_DR_OFFSET is the offset for the Data Register in the USART peripheral.\n// This offset is used to access the data register for reading or writing data.\n// The value is specific to the STM32F407 microcontroller series.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is specific to the STM32F407 microcontroller series.\n#define USART_SR_OFFSET ((uint32_t)0x00000000)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x08)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// USART_FLAG_TXE is a flag used to indicate that the USART transmit data register is empty.\n// This flag is typically used in USART status register to check if the USART is ready to send more data.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 microcontroller.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n// on the STM32F407 microcontroller. This address is used to access\n// the RCC registers for configuring the clock system of the MCU.\n#define RCC_BASE ((uint32_t)0x40023800)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the clock is enabled by setting\n * the appropriate bit in the register.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Set the bit corresponding to GPIOA (bit 0) to enable its clock\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin number from the pin mask\n    uint8_t pin_number = 0;\n    while ((pin_mask >> pin_number) != 1) {\n        pin_number++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin in the MODER register\n    *GPIO_MODER &= ~(0x3 << (pin_number * 2));\n\n    // Set the mode for the pin\n    if (mode == 1) {\n        // Set as output\n        *GPIO_MODER |= (0x1 << (pin_number * 2));\n    } else {\n        // Set as input (default is already cleared)\n    }\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin by accessing the input data register (IDR)\n * of the specified GPIO port. It uses bitwise operations to isolate the state of the desired pin.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the input data register (IDR) for the given GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the state of the pin from the IDR and return it\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations using bitwise XOR.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the specified pin using XOR operation\n    *GPIO_ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "a26d017b-5c38-48e2-8616-bf7190a5caee",
            "timestamp": "2024-11-01T21:01:43.676320",
            "total time (seconds)": 161.3284683227539,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference\n// manual for the STM32F407 series, which specifies the offset for the\n// USART_DR register within the USART peripheral's memory map.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is specific to the STM32F407 microcontroller series.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// USART_BRR_OFFSET is the offset for the Baud Rate Register in the USART peripheral.\n// This offset is used to calculate the address of the Baud Rate Register for a specific USART instance.\n// The value is based on the STM32F407 reference manual.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// USART_FLAG_TXE is a flag used to indicate that the USART transmit data register is empty.\n// This flag is typically used in USART status register to check if the USART is ready to send more data.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC (Reset and Clock Control) block.\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock for AHB1 peripherals.\n// The offset value is based on the STM32F407 reference manual.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Enable the clock for GPIOA by setting the appropriate bit in the RCC AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n\n    // Set the mode: 0x1 for output, 0x0 for input\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 to reset, 1 to set).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Pointer to the Output Data Register (ODR) of the specified GPIO port\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Calculate the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    for (uint32_t mask = pin_mask; mask > 1; mask >>= 1) {\n        pin_position++;\n    }\n\n    // Write the value to the specified pin using bitwise operations\n    if (value) {\n        // Set the pin: Use bitwise OR to set the bit at pin_position\n        *GPIO_ODR |= (1 << pin_position);\n    } else {\n        // Reset the pin: Use bitwise AND with NOT to clear the bit at pin_position\n        *GPIO_ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin by accessing the input data register (IDR)\n * of the specified GPIO port. It calculates the bit position of the pin using a loop\n * to ensure accurate pin configuration.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask representing the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Pointer to the input data register (IDR) of the specified GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n\n    // Calculate the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the pin state from the IDR and return it\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations using bitwise XOR.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the specified pin by XORing the ODR with the pin mask\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "af5a29d4-ac31-46dc-92f7-9396a46d42d1",
            "timestamp": "2024-11-03T06:55:15.459714",
            "total time (seconds)": 4.207271099090576,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference manual\n// which specifies the offset for the DR register within the USART peripheral's\n// memory map.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral\n// This offset is used to calculate the address of the BRR register for a given USART instance\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n// on the STM32F407 microcontroller. This address is used to access\n// the RCC registers for configuring the clock system of the MCU.\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// USART_FLAG_TXE is a flag used to indicate that the USART transmit data register is empty.\n// This flag is used in the status register of the USART peripheral to check if the USART is ready to send more data.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the clock is enabled by setting\n * the appropriate bit in the RCC_AHB1ENR register.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC and the offset for the AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Set the bit 0 of RCC_AHB1ENR to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n\n    // Set the mode: 0x1 for output, 0x0 for input\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin specified by the port base address and pin mask.\n * It calculates the pin position and checks the input data register (IDR) to determine if the pin is high or low.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Define the input data register (IDR) offset for the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n\n    // Read the pin state from the IDR and return 1 if high, 0 if low\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic and reliable operations\n * by using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the specified pin by using XOR operation\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "3283fb2b-6666-4c04-ab62-65bb16913fd3",
            "timestamp": "2024-11-03T06:58:29.811201",
            "total time (seconds)": 176.08105754852295,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference\n// manual for the STM32F407, which specifies the offset for the DR register\n// within the USART peripheral's register map.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral\n// This offset is used to calculate the address of the BRR register for a given USART instance\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// The RCC_AHB1ENR register is used to enable the clock for peripherals connected to the AHB1 bus.\n// The offset is based on the STM32F407 reference manual, which specifies the memory map for the RCC registers.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// RCC_BASE is the base address for the Reset and Clock Control (RCC) registers\n// on the STM32F407 microcontroller. This address is used to access the RCC\n// registers for configuring the clock system of the microcontroller.\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is based on the STM32F407 reference manual.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// USART_FLAG_TXE is a flag used to indicate that the USART transmit data register is empty.\n// This flag is typically used in USART status register (USART_SR) to check if the USART is ready to send more data.\n// The value 0x0080 corresponds to the TXE (Transmit Data Register Empty) bit in the USART status register.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC and the offset for the AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Enable the clock for GPIOA by setting the 0th bit of the RCC_AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin number from the pin mask\n    uint8_t pin_number = 0;\n    for (uint32_t mask = pin_mask; mask > 1; mask >>= 1) {\n        pin_number++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin in the MODER register\n    *GPIO_MODER &= ~(0x3 << (pin_number * 2));\n\n    // Set the mode for the pin\n    // 0x1 for output mode, 0x0 for input mode\n    *GPIO_MODER |= (mode << (pin_number * 2));\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin specified by the port base address\n * and the pin mask. It calculates the pin position and checks the input data register\n * to determine if the pin is set high or low.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Pointer to the input data register (IDR) of the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n\n    // Calculate the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the pin state from the IDR and return 1 if high, 0 if low\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It uses bitwise operations to ensure atomic\n * and reliable toggling of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "3c56f501-c862-408d-94cb-dbabd385257a",
            "timestamp": "2024-11-03T07:00:03.227791",
            "total time (seconds)": 78.21605348587036,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference\n// manual for the STM32F407 series, which specifies the offset for the\n// USART_DR register within the USART peripheral's memory map.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x08)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n\n// RCC_BASE is the base address for the Reset and Clock Control (RCC) registers\n// on the STM32F407 microcontroller. This address is used to access the RCC\n// registers for configuring the clock system of the microcontroller.\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the offset for the USART_SR register.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// USART_FLAG_TXE is a flag used to indicate that the USART transmit data register is empty.\n// This flag is used in the status register of the USART peripheral to check if the transmit buffer is ready for new data.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Enable the clock for GPIOA by setting the appropriate bit in the RCC AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin number from the pin mask\n    uint8_t pin_number = 0;\n    while ((pin_mask >> pin_number) != 1) {\n        pin_number++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin in the MODER register\n    *GPIO_MODER &= ~(0x3 << (pin_number * 2));\n\n    // Set the mode for the pin\n    if (mode == 1) {\n        // Set as output\n        *GPIO_MODER |= (0x1 << (pin_number * 2));\n    } else {\n        // Set as input (default is already cleared)\n    }\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin by accessing the input data register (IDR)\n * of the specified GPIO port. It uses bitwise operations to determine the state of the pin.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the position of the pin by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask & 1) == 0) {\n        pin_mask >>= 1;\n        pin_position++;\n    }\n\n    // Define the address of the input data register (IDR) for the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n\n    // Read the state of the pin by checking the corresponding bit in the IDR\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It uses bitwise operations to ensure atomic\n * and reliable toggling of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "efe61f6e-a686-4418-bfbe-010aa32ba7b1",
            "timestamp": "2024-11-03T07:01:28.344653",
            "total time (seconds)": 65.44478988647461,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference manual.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral\n// This offset is used to calculate the address of the BRR register for a given USART instance\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for peripherals connected to the AHB1 bus on the STM32F407 microcontroller.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// RCC_BASE is the base address for the Reset and Clock Control (RCC) registers\n// on the STM32F407 microcontroller. This address is used to access the RCC\n// registers for configuring the clock system of the microcontroller.\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is specific to the STM32F407 microcontroller series.\n#define USART_SR_OFFSET ((uint32_t)0x00000000)\n\n// USART_FLAG_TXE is a flag used to indicate that the USART transmit data register is empty.\n// This flag is used in the status register of the USART peripheral to check if the USART is ready to send more data.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the clock is enabled by setting\n * the appropriate bit in the register.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Set the bit corresponding to GPIOA (bit 0) to enable its clock\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n\n    // Set the mode: 0x1 for output, 0x0 for input\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin specified by the port base address and pin mask.\n * It calculates the pin position and checks the input data register (IDR) to determine if the pin is high or low.\n * \n * @param port_base_address The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t port_base_address, uint32_t pin_mask) {\n    // Calculate the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Define the input data register (IDR) offset for the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(port_base_address + 0x10);\n\n    // Read the IDR and check if the specific pin is set\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations using bitwise XOR.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "9e50c2d2-d8a1-4405-84ad-f36490df7db1",
            "timestamp": "2024-11-03T07:02:58.900154",
            "total time (seconds)": 65.86268663406372,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference\n// manual for the STM32F407, which specifies the offset for the DR register\n// within the USART peripheral's register map.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a specific USART instance.\n// The value is based on the STM32F407 reference manual, where the BRR register is located at an offset of 0x08 from the base address of the USART peripheral.\n#define USART_BRR_OFFSET ((uint32_t)0x08)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 microcontroller.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is based on the STM32F407 reference manual.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// USART_FLAG_TXE is a flag used to indicate that the transmit data register is empty.\n// This flag is typically used in USART communication to check if the USART is ready to send more data.\n// The value 0x00000080 is a standard value for the TXE (Transmit Data Register Empty) flag in STM32 microcontrollers.\n#define USART_FLAG_TXE ((uint32_t)0x00000080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the clock is enabled by setting\n * the appropriate bit in the RCC_AHB1ENR register.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC and the offset for the AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Set the bit 0 in RCC_AHB1ENR to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n\n    // Set the mode: 0x1 for output, 0x0 for input\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 to reset, 1 to set).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin: Use bitwise OR to set the specific bit\n        *ODR |= (1 << pin_position);\n    } else {\n        // Reset the pin: Use bitwise AND with NOT to clear the specific bit\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin by accessing the input data register (IDR)\n * of the specified GPIO port. It calculates the bit position of the pin using a loop\n * to ensure accurate pin configuration.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask representing the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Pointer to the input data register (IDR) of the specified GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n\n    // Calculate the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the pin state from the IDR and return 1 if high, 0 if low\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations using bitwise XOR.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the specified pin using XOR operation\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "a2c425e3-080e-4c0a-b923-b7bc1204e1cf",
            "timestamp": "2024-11-19T08:52:49.011278",
            "total time (seconds)": 4.325187921524048,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference\n// manual for the STM32F407 series, which specifies the offset for the DR\n// register within the USART peripheral's register map.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// USART_FLAG_TXE is a flag used to indicate that the transmit data register is empty.\n// This flag is typically used in USART communication to check if the USART is ready to send more data.\n// The value 0x00000080 is a standard value for the TXE (Transmit Data Register Empty) flag in STM32 microcontrollers.\n#define USART_FLAG_TXE ((uint32_t)0x00000080)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, where the BRR register is located\n// at an offset of 0x08 from the base address of the USART peripheral.\n#define USART_BRR_OFFSET ((uint32_t)0x08)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// The RCC_AHB1ENR register is used to enable the clock for peripherals connected to the AHB1 bus.\n// The offset is based on the STM32F407 reference manual, which specifies the memory map for the RCC registers.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Enable the clock for GPIOA by setting the appropriate bit in the RCC AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n\n    // Set the mode: 0x1 for output, 0x0 for input\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin by accessing the input data register (IDR)\n * of the specified GPIO port. It calculates the bit position of the pin using a loop\n * to ensure accurate pin configuration.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask representing the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Access the input data register (IDR) of the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n\n    // Read the pin state and return it\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations using bitwise XOR.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the specified pin using XOR operation\n    *ODR ^= pin_mask;\n}\n\n"
        }
    ]
}