{
    "test_data_3_1": [
        {
            "unique_id": "693114ef-43af-4c49-9707-0ffd8186fd2e",
            "timestamp": "2024-10-31T07:30:08.458797",
            "total time (seconds)": 4.389495849609375,
            "compilation-success": true,
            "Similarity with Previous": 0.0,
            "Similarity with Original": 0.0,
            "Removed Element": "hardware_abstraction_layer_function_gpio_toggle_pin",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n    // Enable the clock for GPIOA by setting the appropriate bit in the RCC AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n    // Set the mode: 0x1 for output, 0x0 for input\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin by accessing the input data register (IDR)\n * of the specified GPIO port. It uses bitwise operations to determine the state of the pin.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the input data register (IDR) for the given GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Read the state of the pin from the IDR and return it\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n *\n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations using bitwise\n * XOR to flip the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Toggle the specified pin using XOR operation\n    *GPIO_ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "fc90b5e0-3113-4515-825c-18ac67eee1b2",
            "timestamp": "2024-10-31T07:30:56.187743",
            "total time (seconds)": 28.32761001586914,
            "compilation-success": true,
            "Similarity with Previous": 91.44050104384134,
            "Similarity with Original": 91.44050104384134,
            "Removed Element": "set_input_output_mode",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n    // Enable the clock for GPIOA by setting the appropriate bit in the RCC AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin by accessing the input data register (IDR)\n * of the specified GPIO port. It uses bitwise operations to determine the state of the pin.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the input data register (IDR) for the given GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Read the state of the pin from the IDR and return it\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n/**\n * @brief Toggles the state of a specified GPIO pin.\n *\n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations using bitwise\n * XOR to flip the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Toggle the specified pin using XOR operation\n    *GPIO_ODR ^= pin_mask;\n}\n\n/**\n * @brief Configures a GPIO pin as input or output.\n * \n * This function sets the mode of a specific GPIO pin on the STM32F407 board.\n * It calculates the pin position from the pin mask and configures the mode\n * in the GPIO mode register (MODER).\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    \n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n    \n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n    \n    // Set the mode: 0x1 for output, 0x0 for input\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n\n"
        },
        {
            "unique_id": "22dbd77f-7930-4886-983c-fa033436ee1e",
            "timestamp": "2024-10-31T07:31:20.012202",
            "total time (seconds)": 5.574433088302612,
            "compilation-success": true,
            "Similarity with Previous": 100.0,
            "Similarity with Original": 91.44050104384134,
            "Removed Element": "hardware_abstraction_layer_function_gpio_toggle_pin",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n    // Enable the clock for GPIOA by setting the appropriate bit in the RCC AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin by accessing the input data register (IDR)\n * of the specified GPIO port. It uses bitwise operations to determine the state of the pin.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the input data register (IDR) for the given GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Read the state of the pin from the IDR and return it\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n/**\n * @brief Configures a GPIO pin as input or output.\n * \n * This function sets the mode of a specific GPIO pin on the STM32F407 board.\n * It calculates the pin position from the pin mask and configures the mode\n * in the GPIO mode register (MODER).\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n    // Set the mode: 0x1 for output, 0x0 for input\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n *\n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations using bitwise\n * XOR to flip the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the specified pin using XOR operation\n    *GPIO_ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "2181db30-aba9-4b56-8474-28cc46cff44b",
            "timestamp": "2024-10-31T07:32:06.042495",
            "total time (seconds)": 23.020797729492188,
            "compilation-success": true,
            "Similarity with Previous": 100.0,
            "Similarity with Original": 91.44050104384134,
            "Removed Element": "set_input_output_mode",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n    // Enable the clock for GPIOA by setting the appropriate bit in the RCC AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin by accessing the input data register (IDR)\n * of the specified GPIO port. It uses bitwise operations to determine the state of the pin.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the input data register (IDR) for the given GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Read the state of the pin from the IDR and return it\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n/**\n * @brief Toggles the state of a specified GPIO pin.\n *\n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations using bitwise\n * XOR to flip the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Toggle the specified pin using XOR operation\n    *GPIO_ODR ^= pin_mask;\n}\n\n/**\n * @brief Configures a GPIO pin as input or output.\n * \n * This function sets the mode of a specific GPIO pin on the STM32F407 board.\n * It calculates the pin position from the pin mask and configures the mode\n * in the GPIO mode register (MODER).\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n\n    // Set the mode: 0x1 for output, 0x0 for input\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n\n"
        },
        {
            "unique_id": "3a27bb5f-d03d-44c7-ab5a-65fcecb9c696",
            "timestamp": "2024-10-31T07:32:32.910356",
            "total time (seconds)": 6.427697420120239,
            "compilation-success": true,
            "Similarity with Previous": 99.5837669094693,
            "Similarity with Original": 91.05098855359,
            "Removed Element": "hardware_abstraction_layer_function_gpio_toggle_pin",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n    // Enable the clock for GPIOA by setting the appropriate bit in the RCC AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin by accessing the input data register (IDR)\n * of the specified GPIO port. It uses bitwise operations to determine the state of the pin.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the input data register (IDR) for the given GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Read the state of the pin from the IDR and return it\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n/**\n * @brief Configures a GPIO pin as input or output.\n * \n * This function sets the mode of a specific GPIO pin on the STM32F407 board.\n * It calculates the pin position from the pin mask and configures the mode\n * in the GPIO mode register (MODER).\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n    // Set the mode: 0x1 for output, 0x0 for input\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n *\n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations using bitwise\n * XOR to flip the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Toggle the specified pin using XOR operation\n    *GPIO_ODR ^= (1 << pin_position);\n}\n\n"
        },
        {
            "unique_id": "40efdb0d-5661-433b-9ca3-4a9259d7453e",
            "timestamp": "2024-10-31T07:32:58.604881",
            "total time (seconds)": 6.642854452133179,
            "compilation-success": true,
            "Similarity with Previous": 100.0,
            "Similarity with Original": 91.05098855359,
            "Removed Element": "set_input_output_mode",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n    // Enable the clock for GPIOA by setting the appropriate bit in the RCC AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin by accessing the input data register (IDR)\n * of the specified GPIO port. It uses bitwise operations to determine the state of the pin.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the input data register (IDR) for the given GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Read the state of the pin from the IDR and return it\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n/**\n * @brief Toggles the state of a specified GPIO pin.\n *\n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations using bitwise\n * XOR to flip the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Toggle the specified pin using XOR operation\n    *GPIO_ODR ^= (1 << pin_position);\n}\n\n/**\n * @brief Configures a GPIO pin as input or output.\n * \n * This function sets the mode of a specific GPIO pin on the STM32F407 board.\n * It calculates the pin position from the pin mask and configures the mode\n * in the GPIO mode register (MODER).\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    \n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n    \n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n    \n    // Set the mode: 0x1 for output, 0x0 for input\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n\n"
        },
        {
            "unique_id": "117b7c91-e8ab-4a13-a851-940d5e421639",
            "timestamp": "2024-10-31T07:33:22.322667",
            "total time (seconds)": 4.829339027404785,
            "compilation-success": true,
            "Similarity with Previous": 100.0,
            "Similarity with Original": 91.05098855359,
            "Removed Element": "ENABLE_GPIOA_CLOCK",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin by accessing the input data register (IDR)\n * of the specified GPIO port. It uses bitwise operations to determine the state of the pin.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the input data register (IDR) for the given GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Read the state of the pin from the IDR and return it\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n/**\n * @brief Toggles the state of a specified GPIO pin.\n *\n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations using bitwise\n * XOR to flip the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Toggle the specified pin using XOR operation\n    *GPIO_ODR ^= (1 << pin_position);\n}\n/**\n * @brief Configures a GPIO pin as input or output.\n * \n * This function sets the mode of a specific GPIO pin on the STM32F407 board.\n * It calculates the pin position from the pin mask and configures the mode\n * in the GPIO mode register (MODER).\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n    // Set the mode: 0x1 for output, 0x0 for input\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n    // Enable the clock for GPIOA by setting the appropriate bit in the RCC AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n"
        },
        {
            "unique_id": "81f40007-644e-4332-8694-2b304a3684cc",
            "timestamp": "2024-10-31T07:33:47.741033",
            "total time (seconds)": 8.13299560546875,
            "compilation-success": true,
            "Similarity with Previous": 100.0,
            "Similarity with Original": 91.05098855359,
            "Removed Element": "set_input_output_mode",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin by accessing the input data register (IDR)\n * of the specified GPIO port. It uses bitwise operations to determine the state of the pin.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the input data register (IDR) for the given GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Read the state of the pin from the IDR and return it\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n/**\n * @brief Toggles the state of a specified GPIO pin.\n *\n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations using bitwise\n * XOR to flip the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Toggle the specified pin using XOR operation\n    *GPIO_ODR ^= (1 << pin_position);\n}\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n    // Enable the clock for GPIOA by setting the appropriate bit in the RCC AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n/**\n * @brief Configures a GPIO pin as input or output.\n * \n * This function sets the mode of a specific GPIO pin on the STM32F407 board.\n * It calculates the pin position from the pin mask and configures the mode\n * in the GPIO mode register (MODER).\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n    // Set the mode: 0x1 for output, 0x0 for input\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n\n"
        },
        {
            "unique_id": "eec1d94b-3a10-4f94-be3f-93cb7020db7f",
            "timestamp": "2024-10-31T07:34:15.158482",
            "total time (seconds)": 7.8601226806640625,
            "compilation-success": true,
            "Similarity with Previous": 88.70813397129187,
            "Similarity with Original": 80.89780324737345,
            "Removed Element": "hardware_abstraction_layer_function_gpio_read_pin",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n/**\n * @brief Toggles the state of a specified GPIO pin.\n *\n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations using bitwise\n * XOR to flip the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Toggle the specified pin using XOR operation\n    *GPIO_ODR ^= (1 << pin_position);\n}\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n    // Enable the clock for GPIOA by setting the appropriate bit in the RCC AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n/**\n * @brief Configures a GPIO pin as input or output.\n * \n * This function sets the mode of a specific GPIO pin on the STM32F407 board.\n * It calculates the pin position from the pin mask and configures the mode\n * in the GPIO mode register (MODER).\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n    // Set the mode: 0x1 for output, 0x0 for input\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n\n/**\n * @brief Reads the state of a specified GPIO pin.\n *\n * This function reads the input data register (IDR) of a GPIO port to determine\n * the state of a specific pin. It calculates the pin position from the pin mask\n * and checks if the pin is set high or low.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return int Returns 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the input data register (IDR) for the given GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    \n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    \n    // Read the state of the pin from the IDR and return it\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n"
        },
        {
            "unique_id": "e70d2858-4029-416d-b0ff-5fa15e336c82",
            "timestamp": "2024-10-31T07:34:41.751063",
            "total time (seconds)": 6.122018098831177,
            "compilation-success": true,
            "Similarity with Previous": 92.73959341723138,
            "Similarity with Original": 75.51755175517552,
            "Removed Element": "hardware_abstraction_layer_function_gpio_toggle_pin",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n    // Enable the clock for GPIOA by setting the appropriate bit in the RCC AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n/**\n * @brief Configures a GPIO pin as input or output.\n * \n * This function sets the mode of a specific GPIO pin on the STM32F407 board.\n * It calculates the pin position from the pin mask and configures the mode\n * in the GPIO mode register (MODER).\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n    // Set the mode: 0x1 for output, 0x0 for input\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n/**\n * @brief Reads the state of a specified GPIO pin.\n *\n * This function reads the input data register (IDR) of a GPIO port to determine\n * the state of a specific pin. It calculates the pin position from the pin mask\n * and checks if the pin is set high or low.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return int Returns 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the input data register (IDR) for the given GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Read the state of the pin from the IDR and return it\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin on the STM32F407 board.\n * \n * This function directly manipulates the Output Data Register (ODR) of a given GPIO port\n * to toggle the state of a specified pin. It uses bitwise XOR operation to ensure atomic\n * and reliable toggling of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    \n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    \n    // Toggle the specified pin using XOR operation\n    *GPIO_ODR ^= (1 << pin_position);\n}\n\n"
        },
        {
            "unique_id": "8700b9fc-4cfe-462c-b94d-8a3bbe56cd2c",
            "timestamp": "2024-10-31T07:35:08.373818",
            "total time (seconds)": 6.624014616012573,
            "compilation-success": true,
            "Similarity with Previous": 100.0,
            "Similarity with Original": 75.51755175517552,
            "Removed Element": "hardware_abstraction_layer_function_gpio_toggle_pin",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n    // Enable the clock for GPIOA by setting the appropriate bit in the RCC AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n/**\n * @brief Configures a GPIO pin as input or output.\n * \n * This function sets the mode of a specific GPIO pin on the STM32F407 board.\n * It calculates the pin position from the pin mask and configures the mode\n * in the GPIO mode register (MODER).\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n    // Set the mode: 0x1 for output, 0x0 for input\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n/**\n * @brief Reads the state of a specified GPIO pin.\n *\n * This function reads the input data register (IDR) of a GPIO port to determine\n * the state of a specific pin. It calculates the pin position from the pin mask\n * and checks if the pin is set high or low.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return int Returns 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the input data register (IDR) for the given GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Read the state of the pin from the IDR and return it\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin on the STM32F407 board.\n * \n * This function directly manipulates the Output Data Register (ODR) of a given GPIO port\n * to toggle the state of a specified pin. It uses bitwise XOR operation to ensure atomic\n * and reliable toggling of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    \n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    \n    // Toggle the specified pin using XOR operation\n    *GPIO_ODR ^= (1 << pin_position);\n}\n\n"
        },
        {
            "unique_id": "b5fb1273-cf28-40cb-9358-7b542a23b946",
            "timestamp": "2024-10-31T07:35:34.257172",
            "total time (seconds)": 6.7286481857299805,
            "compilation-success": true,
            "Similarity with Previous": 98.30169830169831,
            "Similarity with Original": 74.28825622775801,
            "Removed Element": "set_input_output_mode",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n    // Enable the clock for GPIOA by setting the appropriate bit in the RCC AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n/**\n * @brief Reads the state of a specified GPIO pin.\n *\n * This function reads the input data register (IDR) of a GPIO port to determine\n * the state of a specific pin. It calculates the pin position from the pin mask\n * and checks if the pin is set high or low.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return int Returns 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the input data register (IDR) for the given GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Read the state of the pin from the IDR and return it\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n/**\n * @brief Toggles the state of a specified GPIO pin on the STM32F407 board.\n * \n * This function directly manipulates the Output Data Register (ODR) of a given GPIO port\n * to toggle the state of a specified pin. It uses bitwise XOR operation to ensure atomic\n * and reliable toggling of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Toggle the specified pin using XOR operation\n    *GPIO_ODR ^= (1 << pin_position);\n}\n\n/**\n * @brief Configures a GPIO pin as input or output.\n * \n * This function sets the mode of a specific GPIO pin on the STM32F407 board.\n * It calculates the pin position from the pin mask and configures the mode\n * in the GPIO mode register (MODER).\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    \n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n    \n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n    \n    // Set the mode (0 for input, 1 for output) at the calculated position\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n\n"
        },
        {
            "unique_id": "f5d63286-5525-4980-8c7d-095fd2bc80df",
            "timestamp": "2024-10-31T07:36:01.613231",
            "total time (seconds)": 7.473063945770264,
            "compilation-success": true,
            "Similarity with Previous": 100.0,
            "Similarity with Original": 74.28825622775801,
            "Removed Element": "set_input_output_mode",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n    // Enable the clock for GPIOA by setting the appropriate bit in the RCC AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n/**\n * @brief Reads the state of a specified GPIO pin.\n *\n * This function reads the input data register (IDR) of a GPIO port to determine\n * the state of a specific pin. It calculates the pin position from the pin mask\n * and checks if the pin is set high or low.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return int Returns 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the input data register (IDR) for the given GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Read the state of the pin from the IDR and return it\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n/**\n * @brief Toggles the state of a specified GPIO pin on the STM32F407 board.\n * \n * This function directly manipulates the Output Data Register (ODR) of a given GPIO port\n * to toggle the state of a specified pin. It uses bitwise XOR operation to ensure atomic\n * and reliable toggling of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Toggle the specified pin using XOR operation\n    *GPIO_ODR ^= (1 << pin_position);\n}\n\n/**\n * @brief Configures a GPIO pin as input or output.\n * \n * This function sets the mode of a specific GPIO pin on the STM32F407 board.\n * It calculates the pin position from the pin mask and configures the mode\n * in the GPIO mode register (MODER).\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    \n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n    \n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n    \n    // Set the mode (0 for input, 1 for output) at the calculated position\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n\n"
        },
        {
            "unique_id": "418a2736-7059-4ab0-b0c7-47f5a01b1edf",
            "timestamp": "2024-10-31T07:36:27.402967",
            "total time (seconds)": 6.287139177322388,
            "compilation-success": true,
            "Similarity with Previous": 82.6330532212885,
            "Similarity with Original": 64.87394957983193,
            "Removed Element": "hardware_abstraction_layer_function_gpio_write_pin",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n    // Enable the clock for GPIOA by setting the appropriate bit in the RCC AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n/**\n * @brief Reads the state of a specified GPIO pin.\n *\n * This function reads the input data register (IDR) of a GPIO port to determine\n * the state of a specific pin. It calculates the pin position from the pin mask\n * and checks if the pin is set high or low.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return int Returns 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the input data register (IDR) for the given GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Read the state of the pin from the IDR and return it\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n/**\n * @brief Toggles the state of a specified GPIO pin on the STM32F407 board.\n * \n * This function directly manipulates the Output Data Register (ODR) of a given GPIO port\n * to toggle the state of a specified pin. It uses bitwise XOR operation to ensure atomic\n * and reliable toggling of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Toggle the specified pin using XOR operation\n    *GPIO_ODR ^= (1 << pin_position);\n}\n/**\n * @brief Configures a GPIO pin as input or output.\n * \n * This function sets the mode of a specific GPIO pin on the STM32F407 board.\n * It calculates the pin position from the pin mask and configures the mode\n * in the GPIO mode register (MODER).\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n    // Set the mode (0 for input, 1 for output) at the calculated position\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the GPIO Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Use bitwise operations to set or reset the pin\n    if (value) {\n        // Set the pin to high\n        *GPIO_ODR |= (1 << pin_position);\n    } else {\n        // Set the pin to low\n        *GPIO_ODR &= ~(1 << pin_position);\n    }\n}\n\n"
        },
        {
            "unique_id": "28e7d7cd-5483-403e-a7ad-bae3f496bbbd",
            "timestamp": "2024-10-31T07:37:16.317349",
            "total time (seconds)": 29.092349767684937,
            "compilation-success": true,
            "Similarity with Previous": 100.0,
            "Similarity with Original": 64.76510067114094,
            "Removed Element": "set_input_output_mode",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n    // Enable the clock for GPIOA by setting the appropriate bit in the RCC AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n/**\n * @brief Reads the state of a specified GPIO pin.\n *\n * This function reads the input data register (IDR) of a GPIO port to determine\n * the state of a specific pin. It calculates the pin position from the pin mask\n * and checks if the pin is set high or low.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return int Returns 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the input data register (IDR) for the given GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Read the state of the pin from the IDR and return it\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n/**\n * @brief Toggles the state of a specified GPIO pin on the STM32F407 board.\n * \n * This function directly manipulates the Output Data Register (ODR) of a given GPIO port\n * to toggle the state of a specified pin. It uses bitwise XOR operation to ensure atomic\n * and reliable toggling of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Toggle the specified pin using XOR operation\n    *GPIO_ODR ^= (1 << pin_position);\n}\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the GPIO Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Use bitwise operations to set or reset the pin\n    if (value) {\n        // Set the pin to high\n        *GPIO_ODR |= (1 << pin_position);\n    } else {\n        // Set the pin to low\n        *GPIO_ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Configures a GPIO pin as input or output.\n * \n * This function sets the mode of a specific GPIO pin on the STM32F407 board.\n * It calculates the pin position from the pin mask and configures the mode\n * in the GPIO mode register (MODER).\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    \n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n    \n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n    \n    // Set the mode (0 for input, 1 for output) at the calculated position\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n\n"
        },
        {
            "unique_id": "e999020b-c203-489c-becf-7f20e4e22e9e",
            "timestamp": "2024-10-31T07:38:01.395174",
            "total time (seconds)": 6.160895824432373,
            "compilation-success": true,
            "Similarity with Previous": 94.14225941422593,
            "Similarity with Original": 65.29411764705883,
            "Removed Element": "set_input_output_mode",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n    // Enable the clock for GPIOA by setting the appropriate bit in the RCC AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n/**\n * @brief Reads the state of a specified GPIO pin.\n *\n * This function reads the input data register (IDR) of a GPIO port to determine\n * the state of a specific pin. It calculates the pin position from the pin mask\n * and checks if the pin is set high or low.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return int Returns 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the input data register (IDR) for the given GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Read the state of the pin from the IDR and return it\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n/**\n * @brief Toggles the state of a specified GPIO pin on the STM32F407 board.\n * \n * This function directly manipulates the Output Data Register (ODR) of a given GPIO port\n * to toggle the state of a specified pin. It uses bitwise XOR operation to ensure atomic\n * and reliable toggling of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Toggle the specified pin using XOR operation\n    *GPIO_ODR ^= (1 << pin_position);\n}\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the GPIO Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Use bitwise operations to set or reset the pin\n    if (value) {\n        // Set the pin to high\n        *GPIO_ODR |= (1 << pin_position);\n    } else {\n        // Set the pin to low\n        *GPIO_ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Sets the mode of a specific GPIO pin on the STM32F407 board.\n * \n * This function calculates the pin position from the pin mask and configures the mode\n * in the GPIO mode register (MODER). It allows setting the pin as input or output.\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    \n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n    \n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n    \n    // Set the mode (0 for input, 1 for output) at the calculated position\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n\n"
        },
        {
            "unique_id": "b689a2e9-6119-4ae4-9a3f-a977911c9b90",
            "timestamp": "2024-10-31T07:38:26.037475",
            "total time (seconds)": 6.664292097091675,
            "compilation-success": true,
            "Similarity with Previous": 98.37662337662337,
            "Similarity with Original": 64.578111946533,
            "Removed Element": "hardware_abstraction_layer_function_gpio_toggle_pin",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n    // Enable the clock for GPIOA by setting the appropriate bit in the RCC AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n/**\n * @brief Reads the state of a specified GPIO pin.\n *\n * This function reads the input data register (IDR) of a GPIO port to determine\n * the state of a specific pin. It calculates the pin position from the pin mask\n * and checks if the pin is set high or low.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return int Returns 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the input data register (IDR) for the given GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Read the state of the pin from the IDR and return it\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the GPIO Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Use bitwise operations to set or reset the pin\n    if (value) {\n        // Set the pin to high\n        *GPIO_ODR |= (1 << pin_position);\n    } else {\n        // Set the pin to low\n        *GPIO_ODR &= ~(1 << pin_position);\n    }\n}\n/**\n * @brief Sets the mode of a specific GPIO pin on the STM32F407 board.\n * \n * This function calculates the pin position from the pin mask and configures the mode\n * in the GPIO mode register (MODER). It allows setting the pin as input or output.\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n    // Set the mode (0 for input, 1 for output) at the calculated position\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin on the STM32F407 board.\n * \n * This function directly manipulates the Output Data Register (ODR) of a given GPIO port\n * to toggle the state of a specified pin. It uses bitwise XOR operation to ensure atomic\n * and reliable toggling of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    \n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    \n    // Toggle the pin by XORing the ODR with the pin mask\n    *GPIO_ODR ^= (1 << pin_position);\n}\n\n"
        },
        {
            "unique_id": "2aa58ff5-c058-40a3-ac2c-f2d48957089e",
            "timestamp": "2024-10-31T07:39:15.505204",
            "total time (seconds)": 9.997066497802734,
            "compilation-success": true,
            "Similarity with Previous": 100.0,
            "Similarity with Original": 64.68619246861924,
            "Removed Element": "ENABLE_GPIOA_CLOCK",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * @brief Reads the state of a specified GPIO pin.\n *\n * This function reads the input data register (IDR) of a GPIO port to determine\n * the state of a specific pin. It calculates the pin position from the pin mask\n * and checks if the pin is set high or low.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return int Returns 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the input data register (IDR) for the given GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Read the state of the pin from the IDR and return it\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the GPIO Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Use bitwise operations to set or reset the pin\n    if (value) {\n        // Set the pin to high\n        *GPIO_ODR |= (1 << pin_position);\n    } else {\n        // Set the pin to low\n        *GPIO_ODR &= ~(1 << pin_position);\n    }\n}\n/**\n * @brief Sets the mode of a specific GPIO pin on the STM32F407 board.\n * \n * This function calculates the pin position from the pin mask and configures the mode\n * in the GPIO mode register (MODER). It allows setting the pin as input or output.\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n    // Set the mode (0 for input, 1 for output) at the calculated position\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n/**\n * @brief Toggles the state of a specified GPIO pin on the STM32F407 board.\n * \n * This function directly manipulates the Output Data Register (ODR) of a given GPIO port\n * to toggle the state of a specified pin. It uses bitwise XOR operation to ensure atomic\n * and reliable toggling of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Toggle the pin by XORing the ODR with the pin mask\n    *GPIO_ODR ^= (1 << pin_position);\n}\n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n    // Enable the clock for GPIOA by setting the appropriate bit in the RCC AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n"
        },
        {
            "unique_id": "e30f6d0d-9759-4f58-a0a9-dfb796db377d",
            "timestamp": "2024-10-31T07:39:41.570991",
            "total time (seconds)": 7.001405715942383,
            "compilation-success": true,
            "Similarity with Previous": 89.08382066276803,
            "Similarity with Original": 61.735089078233926,
            "Removed Element": "hardware_abstraction_layer_function_gpio_write_pin",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * @brief Reads the state of a specified GPIO pin.\n *\n * This function reads the input data register (IDR) of a GPIO port to determine\n * the state of a specific pin. It calculates the pin position from the pin mask\n * and checks if the pin is set high or low.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return int Returns 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the input data register (IDR) for the given GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Read the state of the pin from the IDR and return it\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n/**\n * @brief Sets the mode of a specific GPIO pin on the STM32F407 board.\n * \n * This function calculates the pin position from the pin mask and configures the mode\n * in the GPIO mode register (MODER). It allows setting the pin as input or output.\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n    // Set the mode (0 for input, 1 for output) at the calculated position\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n/**\n * @brief Toggles the state of a specified GPIO pin on the STM32F407 board.\n * \n * This function directly manipulates the Output Data Register (ODR) of a given GPIO port\n * to toggle the state of a specified pin. It uses bitwise XOR operation to ensure atomic\n * and reliable toggling of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Toggle the pin by XORing the ODR with the pin mask\n    *GPIO_ODR ^= (1 << pin_position);\n}\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n    // Enable the clock for GPIOA by setting the appropriate bit in the RCC AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n/**\n * @brief Writes a value to a specified GPIO pin.\n *\n * This function writes a value to the output data register (ODR) of a GPIO port\n * to set or reset a specific pin. It calculates the pin position from the pin mask\n * and uses bitwise operations to ensure atomic and reliable pin state changes.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to write (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 to reset, 1 to set).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the GPIO Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    \n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    \n    // Use bitwise operations to set or reset the pin\n    if (value) {\n        // Set the pin by writing 1 to the corresponding bit in the ODR\n        *GPIO_ODR |= (1 << pin_position);\n    } else {\n        // Reset the pin by writing 0 to the corresponding bit in the ODR\n        *GPIO_ODR &= ~(1 << pin_position);\n    }\n}\n\n"
        },
        {
            "unique_id": "b127bb9a-e9de-4766-bdf9-67ccddb134be",
            "timestamp": "2024-10-31T07:40:11.641979",
            "total time (seconds)": 10.959958553314209,
            "compilation-success": true,
            "Similarity with Previous": 95.56412729026037,
            "Similarity with Original": 59.86342943854325,
            "Removed Element": "ENABLE_GPIOA_CLOCK",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * @brief Reads the state of a specified GPIO pin.\n *\n * This function reads the input data register (IDR) of a GPIO port to determine\n * the state of a specific pin. It calculates the pin position from the pin mask\n * and checks if the pin is set high or low.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return int Returns 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the input data register (IDR) for the given GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Read the state of the pin from the IDR and return it\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n/**\n * @brief Sets the mode of a specific GPIO pin on the STM32F407 board.\n * \n * This function calculates the pin position from the pin mask and configures the mode\n * in the GPIO mode register (MODER). It allows setting the pin as input or output.\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n    // Set the mode (0 for input, 1 for output) at the calculated position\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n/**\n * @brief Toggles the state of a specified GPIO pin on the STM32F407 board.\n * \n * This function directly manipulates the Output Data Register (ODR) of a given GPIO port\n * to toggle the state of a specified pin. It uses bitwise XOR operation to ensure atomic\n * and reliable toggling of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Toggle the pin by XORing the ODR with the pin mask\n    *GPIO_ODR ^= (1 << pin_position);\n}\n/**\n * @brief Writes a value to a specified GPIO pin.\n *\n * This function writes a value to the output data register (ODR) of a GPIO port\n * to set or reset a specific pin. It calculates the pin position from the pin mask\n * and uses bitwise operations to ensure atomic and reliable pin state changes.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to write (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 to reset, 1 to set).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the GPIO Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Use bitwise operations to set or reset the pin\n    if (value) {\n        // Set the pin by writing 1 to the corresponding bit in the ODR\n        *GPIO_ODR |= (1 << pin_position);\n    } else {\n        // Reset the pin by writing 0 to the corresponding bit in the ODR\n        *GPIO_ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n    \n    // Enable the clock for GPIOA by setting the appropriate bit in the RCC_AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n"
        },
        {
            "unique_id": "c820ed9d-6f66-4b5e-bd54-ecb9325de18f",
            "timestamp": "2024-10-31T07:41:02.368932",
            "total time (seconds)": 30.398763418197632,
            "compilation-success": true,
            "Similarity with Previous": 96.04628736740598,
            "Similarity with Original": 57.6837416481069,
            "Removed Element": "hardware_abstraction_layer_function_gpio_read_pin",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * @brief Sets the mode of a specific GPIO pin on the STM32F407 board.\n * \n * This function calculates the pin position from the pin mask and configures the mode\n * in the GPIO mode register (MODER). It allows setting the pin as input or output.\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n    // Set the mode (0 for input, 1 for output) at the calculated position\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n/**\n * @brief Toggles the state of a specified GPIO pin on the STM32F407 board.\n * \n * This function directly manipulates the Output Data Register (ODR) of a given GPIO port\n * to toggle the state of a specified pin. It uses bitwise XOR operation to ensure atomic\n * and reliable toggling of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Toggle the pin by XORing the ODR with the pin mask\n    *GPIO_ODR ^= (1 << pin_position);\n}\n/**\n * @brief Writes a value to a specified GPIO pin.\n *\n * This function writes a value to the output data register (ODR) of a GPIO port\n * to set or reset a specific pin. It calculates the pin position from the pin mask\n * and uses bitwise operations to ensure atomic and reliable pin state changes.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to write (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 to reset, 1 to set).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the GPIO Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Use bitwise operations to set or reset the pin\n    if (value) {\n        // Set the pin by writing 1 to the corresponding bit in the ODR\n        *GPIO_ODR |= (1 << pin_position);\n    } else {\n        // Reset the pin by writing 0 to the corresponding bit in the ODR\n        *GPIO_ODR &= ~(1 << pin_position);\n    }\n}\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n    // Enable the clock for GPIOA by setting the appropriate bit in the RCC_AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n/**\n * @brief Reads the state of a specified GPIO pin.\n *\n * This function reads the input data register (IDR) of a GPIO port to determine\n * the state of a specific pin. It calculates the pin position from the pin mask\n * and checks if the pin is set high or low.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return int Returns 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the GPIO Input Data Register (IDR)\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    \n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    \n    // Read the pin state from the IDR and return 1 if high, 0 if low\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n"
        },
        {
            "unique_id": "a583f883-3e9e-461e-ba14-97ce0560aa47",
            "timestamp": "2024-10-31T07:41:32.072353",
            "total time (seconds)": 8.631334066390991,
            "compilation-success": true,
            "Similarity with Previous": 100.0,
            "Similarity with Original": 57.6837416481069,
            "Removed Element": "set_input_output_mode",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * @brief Toggles the state of a specified GPIO pin on the STM32F407 board.\n * \n * This function directly manipulates the Output Data Register (ODR) of a given GPIO port\n * to toggle the state of a specified pin. It uses bitwise XOR operation to ensure atomic\n * and reliable toggling of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Toggle the pin by XORing the ODR with the pin mask\n    *GPIO_ODR ^= (1 << pin_position);\n}\n/**\n * @brief Writes a value to a specified GPIO pin.\n *\n * This function writes a value to the output data register (ODR) of a GPIO port\n * to set or reset a specific pin. It calculates the pin position from the pin mask\n * and uses bitwise operations to ensure atomic and reliable pin state changes.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to write (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 to reset, 1 to set).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the GPIO Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Use bitwise operations to set or reset the pin\n    if (value) {\n        // Set the pin by writing 1 to the corresponding bit in the ODR\n        *GPIO_ODR |= (1 << pin_position);\n    } else {\n        // Reset the pin by writing 0 to the corresponding bit in the ODR\n        *GPIO_ODR &= ~(1 << pin_position);\n    }\n}\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n    // Enable the clock for GPIOA by setting the appropriate bit in the RCC_AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n/**\n * @brief Reads the state of a specified GPIO pin.\n *\n * This function reads the input data register (IDR) of a GPIO port to determine\n * the state of a specific pin. It calculates the pin position from the pin mask\n * and checks if the pin is set high or low.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return int Returns 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the GPIO Input Data Register (IDR)\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Read the pin state from the IDR and return 1 if high, 0 if low\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Sets the mode of a specific GPIO pin on the STM32F407 board.\n * \n * This function calculates the pin position from the pin mask and configures the mode\n * in the GPIO mode register (MODER). It allows setting the pin as input or output.\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    \n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n    \n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n    \n    // Set the mode (0 for input, 1 for output) at the calculated position\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n\n"
        },
        {
            "unique_id": "a78bbf3c-9935-46a6-bcad-bdd6ed4bb2e0",
            "timestamp": "2024-10-31T07:41:59.276508",
            "total time (seconds)": 6.94607138633728,
            "compilation-success": true,
            "Similarity with Previous": 96.47404505386875,
            "Similarity with Original": 56.81818181818182,
            "Removed Element": "hardware_abstraction_layer_function_gpio_toggle_pin",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * @brief Writes a value to a specified GPIO pin.\n *\n * This function writes a value to the output data register (ODR) of a GPIO port\n * to set or reset a specific pin. It calculates the pin position from the pin mask\n * and uses bitwise operations to ensure atomic and reliable pin state changes.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to write (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 to reset, 1 to set).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the GPIO Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Use bitwise operations to set or reset the pin\n    if (value) {\n        // Set the pin by writing 1 to the corresponding bit in the ODR\n        *GPIO_ODR |= (1 << pin_position);\n    } else {\n        // Reset the pin by writing 0 to the corresponding bit in the ODR\n        *GPIO_ODR &= ~(1 << pin_position);\n    }\n}\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n    // Enable the clock for GPIOA by setting the appropriate bit in the RCC_AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n/**\n * @brief Reads the state of a specified GPIO pin.\n *\n * This function reads the input data register (IDR) of a GPIO port to determine\n * the state of a specific pin. It calculates the pin position from the pin mask\n * and checks if the pin is set high or low.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return int Returns 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the GPIO Input Data Register (IDR)\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Read the pin state from the IDR and return 1 if high, 0 if low\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n/**\n * @brief Sets the mode of a specific GPIO pin on the STM32F407 board.\n * \n * This function calculates the pin position from the pin mask and configures the mode\n * in the GPIO mode register (MODER). It allows setting the pin as input or output.\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n    // Set the mode (0 for input, 1 for output) at the calculated position\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin on the STM32F407 board.\n * \n * This function directly manipulates the Output Data Register (ODR) of a given GPIO port\n * to toggle the state of a specified pin. It uses bitwise XOR operation to ensure atomic\n * and reliable toggling of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the GPIO Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    \n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    \n    // Toggle the pin by using XOR operation on the corresponding bit in the ODR\n    *GPIO_ODR ^= (1 << pin_position);\n}\n\n"
        },
        {
            "unique_id": "a53f457a-125c-4ed4-b26f-246ac03f6a5c",
            "timestamp": "2024-10-31T07:42:23.408804",
            "total time (seconds)": 5.616369724273682,
            "compilation-success": true,
            "Similarity with Previous": 98.51485148514851,
            "Similarity with Original": 56.74486803519062,
            "Removed Element": "ENABLE_GPIOA_CLOCK",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * @brief Writes a value to a specified GPIO pin.\n *\n * This function writes a value to the output data register (ODR) of a GPIO port\n * to set or reset a specific pin. It calculates the pin position from the pin mask\n * and uses bitwise operations to ensure atomic and reliable pin state changes.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to write (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 to reset, 1 to set).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the GPIO Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Use bitwise operations to set or reset the pin\n    if (value) {\n        // Set the pin by writing 1 to the corresponding bit in the ODR\n        *GPIO_ODR |= (1 << pin_position);\n    } else {\n        // Reset the pin by writing 0 to the corresponding bit in the ODR\n        *GPIO_ODR &= ~(1 << pin_position);\n    }\n}\n/**\n * @brief Reads the state of a specified GPIO pin.\n *\n * This function reads the input data register (IDR) of a GPIO port to determine\n * the state of a specific pin. It calculates the pin position from the pin mask\n * and checks if the pin is set high or low.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return int Returns 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the GPIO Input Data Register (IDR)\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Read the pin state from the IDR and return 1 if high, 0 if low\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n/**\n * @brief Sets the mode of a specific GPIO pin on the STM32F407 board.\n * \n * This function calculates the pin position from the pin mask and configures the mode\n * in the GPIO mode register (MODER). It allows setting the pin as input or output.\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n    // Set the mode (0 for input, 1 for output) at the calculated position\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n/**\n * @brief Toggles the state of a specified GPIO pin on the STM32F407 board.\n * \n * This function directly manipulates the Output Data Register (ODR) of a given GPIO port\n * to toggle the state of a specified pin. It uses bitwise XOR operation to ensure atomic\n * and reliable toggling of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the GPIO Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Toggle the pin by using XOR operation on the corresponding bit in the ODR\n    *GPIO_ODR ^= (1 << pin_position);\n}\n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Enable the clock for GPIOA by setting the 0th bit in the RCC_AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n"
        },
        {
            "unique_id": "543e1918-77d9-4f40-aa28-819e7e0b4fa4",
            "timestamp": "2024-10-31T07:42:53.311650",
            "total time (seconds)": 11.259329557418823,
            "compilation-success": true,
            "Similarity with Previous": 100.0,
            "Similarity with Original": 56.74486803519062,
            "Removed Element": "hardware_abstraction_layer_function_gpio_toggle_pin",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * @brief Writes a value to a specified GPIO pin.\n *\n * This function writes a value to the output data register (ODR) of a GPIO port\n * to set or reset a specific pin. It calculates the pin position from the pin mask\n * and uses bitwise operations to ensure atomic and reliable pin state changes.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to write (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 to reset, 1 to set).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the GPIO Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Use bitwise operations to set or reset the pin\n    if (value) {\n        // Set the pin by writing 1 to the corresponding bit in the ODR\n        *GPIO_ODR |= (1 << pin_position);\n    } else {\n        // Reset the pin by writing 0 to the corresponding bit in the ODR\n        *GPIO_ODR &= ~(1 << pin_position);\n    }\n}\n/**\n * @brief Reads the state of a specified GPIO pin.\n *\n * This function reads the input data register (IDR) of a GPIO port to determine\n * the state of a specific pin. It calculates the pin position from the pin mask\n * and checks if the pin is set high or low.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return int Returns 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the GPIO Input Data Register (IDR)\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Read the pin state from the IDR and return 1 if high, 0 if low\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n/**\n * @brief Sets the mode of a specific GPIO pin on the STM32F407 board.\n * \n * This function calculates the pin position from the pin mask and configures the mode\n * in the GPIO mode register (MODER). It allows setting the pin as input or output.\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n    // Set the mode (0 for input, 1 for output) at the calculated position\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n    // Enable the clock for GPIOA by setting the 0th bit in the RCC_AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin on the STM32F407 board.\n * \n * This function directly manipulates the Output Data Register (ODR) of a given GPIO port\n * to toggle the state of a specified pin. It uses bitwise XOR operation to ensure atomic\n * and reliable toggling of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the GPIO Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    \n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    \n    // Toggle the pin by using XOR operation on the corresponding bit in the ODR\n    *GPIO_ODR ^= (1 << pin_position);\n}\n\n"
        },
        {
            "unique_id": "391d7e7b-c9b1-49b4-923b-3eb4355c900c",
            "timestamp": "2024-10-31T07:43:24.470685",
            "total time (seconds)": 13.034803628921509,
            "compilation-success": true,
            "Similarity with Previous": 98.69477911646585,
            "Similarity with Original": 57.29089563286455,
            "Removed Element": "set_input_output_mode",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * @brief Writes a value to a specified GPIO pin.\n *\n * This function writes a value to the output data register (ODR) of a GPIO port\n * to set or reset a specific pin. It calculates the pin position from the pin mask\n * and uses bitwise operations to ensure atomic and reliable pin state changes.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to write (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 to reset, 1 to set).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the GPIO Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Use bitwise operations to set or reset the pin\n    if (value) {\n        // Set the pin by writing 1 to the corresponding bit in the ODR\n        *GPIO_ODR |= (1 << pin_position);\n    } else {\n        // Reset the pin by writing 0 to the corresponding bit in the ODR\n        *GPIO_ODR &= ~(1 << pin_position);\n    }\n}\n/**\n * @brief Reads the state of a specified GPIO pin.\n *\n * This function reads the input data register (IDR) of a GPIO port to determine\n * the state of a specific pin. It calculates the pin position from the pin mask\n * and checks if the pin is set high or low.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return int Returns 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the GPIO Input Data Register (IDR)\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Read the pin state from the IDR and return 1 if high, 0 if low\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n    // Enable the clock for GPIOA by setting the 0th bit in the RCC_AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n/**\n * @brief Toggles the state of a specified GPIO pin on the STM32F407 board.\n * \n * This function directly manipulates the Output Data Register (ODR) of a given GPIO port\n * to toggle the state of a specified pin. It uses bitwise XOR operation to ensure atomic\n * and reliable toggling of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the GPIO Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Toggle the pin by using XOR operation on the corresponding bit in the ODR\n    *GPIO_ODR ^= (1 << pin_position);\n}\n\n/**\n * This function calculates the pin position from the pin mask and configures the mode\n * in the GPIO mode register (MODER). It allows setting the pin as input or output.\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    \n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n    \n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n    \n    // Set the mode (0 for input, 1 for output) at the calculated position\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n\n"
        },
        {
            "unique_id": "20aaa259-971f-4faf-8e55-e72aa7eaddb4",
            "timestamp": "2024-10-31T07:43:47.755299",
            "total time (seconds)": 4.988618612289429,
            "compilation-success": true,
            "Similarity with Previous": 97.51491053677933,
            "Similarity with Original": 56.63003663003663,
            "Removed Element": "ENABLE_GPIOA_CLOCK",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * @brief Writes a value to a specified GPIO pin.\n *\n * This function writes a value to the output data register (ODR) of a GPIO port\n * to set or reset a specific pin. It calculates the pin position from the pin mask\n * and uses bitwise operations to ensure atomic and reliable pin state changes.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to write (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 to reset, 1 to set).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the GPIO Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Use bitwise operations to set or reset the pin\n    if (value) {\n        // Set the pin by writing 1 to the corresponding bit in the ODR\n        *GPIO_ODR |= (1 << pin_position);\n    } else {\n        // Reset the pin by writing 0 to the corresponding bit in the ODR\n        *GPIO_ODR &= ~(1 << pin_position);\n    }\n}\n/**\n * @brief Reads the state of a specified GPIO pin.\n *\n * This function reads the input data register (IDR) of a GPIO port to determine\n * the state of a specific pin. It calculates the pin position from the pin mask\n * and checks if the pin is set high or low.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return int Returns 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the GPIO Input Data Register (IDR)\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Read the pin state from the IDR and return 1 if high, 0 if low\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n/**\n * @brief Toggles the state of a specified GPIO pin on the STM32F407 board.\n * \n * This function directly manipulates the Output Data Register (ODR) of a given GPIO port\n * to toggle the state of a specified pin. It uses bitwise XOR operation to ensure atomic\n * and reliable toggling of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the GPIO Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Toggle the pin by using XOR operation on the corresponding bit in the ODR\n    *GPIO_ODR ^= (1 << pin_position);\n}\n/**\n * This function calculates the pin position from the pin mask and configures the mode\n * in the GPIO mode register (MODER). It allows setting the pin as input or output.\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n    // Set the mode (0 for input, 1 for output) at the calculated position\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function sets the appropriate bit in the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n    \n    // Enable the clock for GPIOA by setting the 0th bit in the RCC_AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n"
        },
        {
            "unique_id": "c6d9d1a3-3803-46be-9297-8eb66f599ac5",
            "timestamp": "2024-10-31T07:44:20.126120",
            "total time (seconds)": 14.615550518035889,
            "compilation-success": true,
            "Similarity with Previous": 100.0,
            "Similarity with Original": 56.63003663003663,
            "Removed Element": "set_input_output_mode",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * @brief Writes a value to a specified GPIO pin.\n *\n * This function writes a value to the output data register (ODR) of a GPIO port\n * to set or reset a specific pin. It calculates the pin position from the pin mask\n * and uses bitwise operations to ensure atomic and reliable pin state changes.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to write (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 to reset, 1 to set).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the GPIO Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Use bitwise operations to set or reset the pin\n    if (value) {\n        // Set the pin by writing 1 to the corresponding bit in the ODR\n        *GPIO_ODR |= (1 << pin_position);\n    } else {\n        // Reset the pin by writing 0 to the corresponding bit in the ODR\n        *GPIO_ODR &= ~(1 << pin_position);\n    }\n}\n/**\n * @brief Reads the state of a specified GPIO pin.\n *\n * This function reads the input data register (IDR) of a GPIO port to determine\n * the state of a specific pin. It calculates the pin position from the pin mask\n * and checks if the pin is set high or low.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return int Returns 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the GPIO Input Data Register (IDR)\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Read the pin state from the IDR and return 1 if high, 0 if low\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n/**\n * @brief Toggles the state of a specified GPIO pin on the STM32F407 board.\n * \n * This function directly manipulates the Output Data Register (ODR) of a given GPIO port\n * to toggle the state of a specified pin. It uses bitwise XOR operation to ensure atomic\n * and reliable toggling of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the GPIO Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Toggle the pin by using XOR operation on the corresponding bit in the ODR\n    *GPIO_ODR ^= (1 << pin_position);\n}\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function sets the appropriate bit in the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n    // Enable the clock for GPIOA by setting the 0th bit in the RCC_AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n/**\n * This function calculates the pin position from the pin mask and configures the mode\n * in the GPIO mode register (MODER). It allows setting the pin as input or output.\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    \n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n    \n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n    \n    // Set the mode (0 for input, 1 for output) at the calculated position\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n\n"
        },
        {
            "unique_id": "c36990db-0db4-494b-8447-a2436e8ed486",
            "timestamp": "2024-10-31T07:44:43.101003",
            "total time (seconds)": 5.806538820266724,
            "compilation-success": true,
            "Similarity with Previous": 100.0,
            "Similarity with Original": 56.63003663003663,
            "Removed Element": "hardware_abstraction_layer_function_gpio_toggle_pin",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * @brief Writes a value to a specified GPIO pin.\n *\n * This function writes a value to the output data register (ODR) of a GPIO port\n * to set or reset a specific pin. It calculates the pin position from the pin mask\n * and uses bitwise operations to ensure atomic and reliable pin state changes.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to write (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 to reset, 1 to set).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the GPIO Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Use bitwise operations to set or reset the pin\n    if (value) {\n        // Set the pin by writing 1 to the corresponding bit in the ODR\n        *GPIO_ODR |= (1 << pin_position);\n    } else {\n        // Reset the pin by writing 0 to the corresponding bit in the ODR\n        *GPIO_ODR &= ~(1 << pin_position);\n    }\n}\n/**\n * @brief Reads the state of a specified GPIO pin.\n *\n * This function reads the input data register (IDR) of a GPIO port to determine\n * the state of a specific pin. It calculates the pin position from the pin mask\n * and checks if the pin is set high or low.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return int Returns 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the GPIO Input Data Register (IDR)\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Read the pin state from the IDR and return 1 if high, 0 if low\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function sets the appropriate bit in the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n    // Enable the clock for GPIOA by setting the 0th bit in the RCC_AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n/**\n * This function calculates the pin position from the pin mask and configures the mode\n * in the GPIO mode register (MODER). It allows setting the pin as input or output.\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n    // Set the mode (0 for input, 1 for output) at the calculated position\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin on the STM32F407 board.\n *\n * This function directly manipulates the Output Data Register (ODR) of a given GPIO port\n * to toggle the state of a specified pin. It uses bitwise XOR operation to ensure atomic\n * and reliable toggling of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the GPIO Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    \n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    \n    // Toggle the pin by using XOR operation on the corresponding bit in the ODR\n    *GPIO_ODR ^= (1 << pin_position);\n}\n\n"
        },
        {
            "unique_id": "9f91634f-329b-4b0f-b029-5b75852a8c8b",
            "timestamp": "2024-10-31T07:45:08.119165",
            "total time (seconds)": 4.689499616622925,
            "compilation-success": true,
            "Similarity with Previous": 93.6108422071636,
            "Similarity with Original": 54.121863799283155,
            "Removed Element": "ENABLE_GPIOA_CLOCK",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * @brief Writes a value to a specified GPIO pin.\n *\n * This function writes a value to the output data register (ODR) of a GPIO port\n * to set or reset a specific pin. It calculates the pin position from the pin mask\n * and uses bitwise operations to ensure atomic and reliable pin state changes.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to write (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 to reset, 1 to set).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the GPIO Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Use bitwise operations to set or reset the pin\n    if (value) {\n        // Set the pin by writing 1 to the corresponding bit in the ODR\n        *GPIO_ODR |= (1 << pin_position);\n    } else {\n        // Reset the pin by writing 0 to the corresponding bit in the ODR\n        *GPIO_ODR &= ~(1 << pin_position);\n    }\n}\n/**\n * @brief Reads the state of a specified GPIO pin.\n *\n * This function reads the input data register (IDR) of a GPIO port to determine\n * the state of a specific pin. It calculates the pin position from the pin mask\n * and checks if the pin is set high or low.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return int Returns 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the GPIO Input Data Register (IDR)\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Read the pin state from the IDR and return 1 if high, 0 if low\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n/**\n * This function calculates the pin position from the pin mask and configures the mode\n * in the GPIO mode register (MODER). It allows setting the pin as input or output.\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n    // Set the mode (0 for input, 1 for output) at the calculated position\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n/**\n * @brief Toggles the state of a specified GPIO pin on the STM32F407 board.\n *\n * This function directly manipulates the Output Data Register (ODR) of a given GPIO port\n * to toggle the state of a specified pin. It uses bitwise XOR operation to ensure atomic\n * and reliable toggling of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the GPIO Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Toggle the pin by using XOR operation on the corresponding bit in the ODR\n    *GPIO_ODR ^= (1 << pin_position);\n}\n\n/**\n * @brief Enables the clock for GPIOA.\n * \n * This function enables the clock for the GPIOA peripheral by setting the appropriate\n * bit in the RCC AHB1 peripheral clock enable register (RCC_AHB1ENR). This is necessary\n * before any GPIOA operations can be performed.\n * \n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n    \n    // Enable the clock for GPIOA by setting the 0th bit in the RCC_AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n"
        },
        {
            "unique_id": "534213d4-2dbc-45e9-9fe3-15c555ed034c",
            "timestamp": "2024-10-31T07:45:58.453863",
            "total time (seconds)": 32.62646484375,
            "compilation-success": true,
            "Similarity with Previous": 93.68318756073857,
            "Similarity with Original": 53.62731152204836,
            "Removed Element": "set_input_output_mode",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * @brief Writes a value to a specified GPIO pin.\n *\n * This function writes a value to the output data register (ODR) of a GPIO port\n * to set or reset a specific pin. It calculates the pin position from the pin mask\n * and uses bitwise operations to ensure atomic and reliable pin state changes.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to write (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 to reset, 1 to set).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the GPIO Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Use bitwise operations to set or reset the pin\n    if (value) {\n        // Set the pin by writing 1 to the corresponding bit in the ODR\n        *GPIO_ODR |= (1 << pin_position);\n    } else {\n        // Reset the pin by writing 0 to the corresponding bit in the ODR\n        *GPIO_ODR &= ~(1 << pin_position);\n    }\n}\n/**\n * @brief Reads the state of a specified GPIO pin.\n *\n * This function reads the input data register (IDR) of a GPIO port to determine\n * the state of a specific pin. It calculates the pin position from the pin mask\n * and checks if the pin is set high or low.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return int Returns 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the GPIO Input Data Register (IDR)\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Read the pin state from the IDR and return 1 if high, 0 if low\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n/**\n * @brief Toggles the state of a specified GPIO pin on the STM32F407 board.\n *\n * This function directly manipulates the Output Data Register (ODR) of a given GPIO port\n * to toggle the state of a specified pin. It uses bitwise XOR operation to ensure atomic\n * and reliable toggling of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the GPIO Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Toggle the pin by using XOR operation on the corresponding bit in the ODR\n    *GPIO_ODR ^= (1 << pin_position);\n}\n/**\n * @brief Enables the clock for GPIOA.\n * \n * This function enables the clock for the GPIOA peripheral by setting the appropriate\n * bit in the RCC AHB1 peripheral clock enable register (RCC_AHB1ENR). This is necessary\n * before any GPIOA operations can be performed.\n * \n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n    // Enable the clock for GPIOA by setting the 0th bit in the RCC_AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n/**\n * @brief Configures the mode of a specific GPIO pin on the STM32F407 board.\n * \n * This function sets a GPIO pin as either input or output by modifying the\n * GPIO mode register (MODER). It uses direct register manipulation to ensure\n * atomic operations.\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    \n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n    \n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n    \n    // Set the mode (0 for input, 1 for output) at the calculated position\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n\n"
        },
        {
            "unique_id": "00d77ef9-7aab-48b5-96fe-694b8846a9eb",
            "timestamp": "2024-10-31T07:46:36.322960",
            "total time (seconds)": 20.609910011291504,
            "compilation-success": true,
            "Similarity with Previous": 100.0,
            "Similarity with Original": 53.62731152204836,
            "Removed Element": "set_input_output_mode",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * @brief Writes a value to a specified GPIO pin.\n *\n * This function writes a value to the output data register (ODR) of a GPIO port\n * to set or reset a specific pin. It calculates the pin position from the pin mask\n * and uses bitwise operations to ensure atomic and reliable pin state changes.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to write (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 to reset, 1 to set).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the GPIO Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Use bitwise operations to set or reset the pin\n    if (value) {\n        // Set the pin by writing 1 to the corresponding bit in the ODR\n        *GPIO_ODR |= (1 << pin_position);\n    } else {\n        // Reset the pin by writing 0 to the corresponding bit in the ODR\n        *GPIO_ODR &= ~(1 << pin_position);\n    }\n}\n/**\n * @brief Reads the state of a specified GPIO pin.\n *\n * This function reads the input data register (IDR) of a GPIO port to determine\n * the state of a specific pin. It calculates the pin position from the pin mask\n * and checks if the pin is set high or low.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return int Returns 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the GPIO Input Data Register (IDR)\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Read the pin state from the IDR and return 1 if high, 0 if low\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n/**\n * @brief Toggles the state of a specified GPIO pin on the STM32F407 board.\n *\n * This function directly manipulates the Output Data Register (ODR) of a given GPIO port\n * to toggle the state of a specified pin. It uses bitwise XOR operation to ensure atomic\n * and reliable toggling of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the GPIO Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Toggle the pin by using XOR operation on the corresponding bit in the ODR\n    *GPIO_ODR ^= (1 << pin_position);\n}\n/**\n * @brief Enables the clock for GPIOA.\n * \n * This function enables the clock for the GPIOA peripheral by setting the appropriate\n * bit in the RCC AHB1 peripheral clock enable register (RCC_AHB1ENR). This is necessary\n * before any GPIOA operations can be performed.\n * \n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n    // Enable the clock for GPIOA by setting the 0th bit in the RCC_AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n/**\n * @brief Configures the mode of a specific GPIO pin on the STM32F407 board.\n * \n * This function sets a GPIO pin as either input or output by modifying the\n * GPIO mode register (MODER). It uses direct register manipulation to ensure\n * atomic operations.\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    \n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n    \n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n    \n    // Set the mode (0 for input, 1 for output) at the calculated position\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n\n"
        },
        {
            "unique_id": "913cd1b8-f10c-4404-86d0-1fb4f24dd0bc",
            "timestamp": "2024-10-31T07:46:59.111357",
            "total time (seconds)": 6.371506452560425,
            "compilation-success": true,
            "Similarity with Previous": 100.0,
            "Similarity with Original": 53.62731152204836,
            "Removed Element": "hardware_abstraction_layer_function_gpio_toggle_pin",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * @brief Writes a value to a specified GPIO pin.\n *\n * This function writes a value to the output data register (ODR) of a GPIO port\n * to set or reset a specific pin. It calculates the pin position from the pin mask\n * and uses bitwise operations to ensure atomic and reliable pin state changes.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to write (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 to reset, 1 to set).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the GPIO Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Use bitwise operations to set or reset the pin\n    if (value) {\n        // Set the pin by writing 1 to the corresponding bit in the ODR\n        *GPIO_ODR |= (1 << pin_position);\n    } else {\n        // Reset the pin by writing 0 to the corresponding bit in the ODR\n        *GPIO_ODR &= ~(1 << pin_position);\n    }\n}\n/**\n * @brief Reads the state of a specified GPIO pin.\n *\n * This function reads the input data register (IDR) of a GPIO port to determine\n * the state of a specific pin. It calculates the pin position from the pin mask\n * and checks if the pin is set high or low.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return int Returns 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the GPIO Input Data Register (IDR)\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Read the pin state from the IDR and return 1 if high, 0 if low\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n/**\n * @brief Enables the clock for GPIOA.\n * \n * This function enables the clock for the GPIOA peripheral by setting the appropriate\n * bit in the RCC AHB1 peripheral clock enable register (RCC_AHB1ENR). This is necessary\n * before any GPIOA operations can be performed.\n * \n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n    // Enable the clock for GPIOA by setting the 0th bit in the RCC_AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n/**\n * @brief Configures the mode of a specific GPIO pin on the STM32F407 board.\n * \n * This function sets a GPIO pin as either input or output by modifying the\n * GPIO mode register (MODER). It uses direct register manipulation to ensure\n * atomic operations.\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n    // Set the mode (0 for input, 1 for output) at the calculated position\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin on the STM32F407 board.\n *\n * This function directly manipulates the Output Data Register (ODR) of a given GPIO port\n * to toggle the state of a specified pin. It uses bitwise XOR operation to ensure atomic\n * and reliable toggling of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the GPIO Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    \n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    \n    // Toggle the pin by using XOR operation on the corresponding bit in the ODR\n    *GPIO_ODR ^= (1 << pin_position);\n}\n\n"
        },
        {
            "unique_id": "613537f3-cc12-43d2-be71-5ea2d7c515a8",
            "timestamp": "2024-10-31T07:47:23.851718",
            "total time (seconds)": 7.760174751281738,
            "compilation-success": true,
            "Similarity with Previous": 94.7267497603068,
            "Similarity with Original": 52.991452991452995,
            "Removed Element": "hardware_abstraction_layer_function_gpio_write_pin",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * @brief Reads the state of a specified GPIO pin.\n *\n * This function reads the input data register (IDR) of a GPIO port to determine\n * the state of a specific pin. It calculates the pin position from the pin mask\n * and checks if the pin is set high or low.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return int Returns 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the GPIO Input Data Register (IDR)\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Read the pin state from the IDR and return 1 if high, 0 if low\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n/**\n * @brief Enables the clock for GPIOA.\n * \n * This function enables the clock for the GPIOA peripheral by setting the appropriate\n * bit in the RCC AHB1 peripheral clock enable register (RCC_AHB1ENR). This is necessary\n * before any GPIOA operations can be performed.\n * \n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n    // Enable the clock for GPIOA by setting the 0th bit in the RCC_AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n/**\n * @brief Configures the mode of a specific GPIO pin on the STM32F407 board.\n * \n * This function sets a GPIO pin as either input or output by modifying the\n * GPIO mode register (MODER). It uses direct register manipulation to ensure\n * atomic operations.\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n    // Set the mode (0 for input, 1 for output) at the calculated position\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n/**\n * @brief Toggles the state of a specified GPIO pin on the STM32F407 board.\n *\n * This function directly manipulates the Output Data Register (ODR) of a given GPIO port\n * to toggle the state of a specified pin. It uses bitwise XOR operation to ensure atomic\n * and reliable toggling of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the GPIO Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Toggle the pin by using XOR operation on the corresponding bit in the ODR\n    *GPIO_ODR ^= (1 << pin_position);\n}\n\n/**\n * @brief Writes a value to a specified GPIO pin.\n *\n * This function directly manipulates the output data register (ODR) of a GPIO port\n * to set or reset a specific pin. It calculates the pin position from the pin mask\n * and uses bitwise operations to ensure atomic and reliable pin state changes.\n *\n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to write (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 to reset, non-zero to set).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the GPIO Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    \n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    \n    // Use bitwise operations to set or reset the pin\n    if (value) {\n        // Set the pin by writing 1 to the corresponding bit in the ODR\n        *GPIO_ODR |= (1 << pin_position);\n    } else {\n        // Reset the pin by writing 0 to the corresponding bit in the ODR\n        *GPIO_ODR &= ~(1 << pin_position);\n    }\n}\n\n"
        },
        {
            "unique_id": "ce03cc5a-a0c9-4aa5-8470-4202159b2f79",
            "timestamp": "2024-10-31T07:47:49.410325",
            "total time (seconds)": 7.314349412918091,
            "compilation-success": true,
            "Similarity with Previous": 94.44976076555024,
            "Similarity with Original": 52.957947255880256,
            "Removed Element": "hardware_abstraction_layer_function_gpio_write_pin",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * @brief Reads the state of a specified GPIO pin.\n *\n * This function reads the input data register (IDR) of a GPIO port to determine\n * the state of a specific pin. It calculates the pin position from the pin mask\n * and checks if the pin is set high or low.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return int Returns 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the GPIO Input Data Register (IDR)\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Read the pin state from the IDR and return 1 if high, 0 if low\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n/**\n * @brief Enables the clock for GPIOA.\n * \n * This function enables the clock for the GPIOA peripheral by setting the appropriate\n * bit in the RCC AHB1 peripheral clock enable register (RCC_AHB1ENR). This is necessary\n * before any GPIOA operations can be performed.\n * \n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n    // Enable the clock for GPIOA by setting the 0th bit in the RCC_AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n/**\n * @brief Configures the mode of a specific GPIO pin on the STM32F407 board.\n * \n * This function sets a GPIO pin as either input or output by modifying the\n * GPIO mode register (MODER). It uses direct register manipulation to ensure\n * atomic operations.\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n    // Set the mode (0 for input, 1 for output) at the calculated position\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n/**\n * @brief Toggles the state of a specified GPIO pin on the STM32F407 board.\n *\n * This function directly manipulates the Output Data Register (ODR) of a given GPIO port\n * to toggle the state of a specified pin. It uses bitwise XOR operation to ensure atomic\n * and reliable toggling of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the GPIO Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Toggle the pin by using XOR operation on the corresponding bit in the ODR\n    *GPIO_ODR ^= (1 << pin_position);\n}\n\n/**\n * @brief Writes a value to a specified GPIO pin.\n *\n * This function directly manipulates the output data register (ODR) of a GPIO port\n * to set or reset a specific pin. It calculates the pin position from the pin mask\n * and uses bitwise operations to ensure atomic and reliable pin state changes.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to write (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (1 to set high, 0 to set low).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, int value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    \n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    \n    // Use bitwise operations to set or reset the pin\n    if (value) {\n        // Set the pin by writing 1 to the corresponding bit in the ODR\n        *GPIO_ODR |= (1 << pin_position);\n    } else {\n        // Reset the pin by writing 0 to the corresponding bit in the ODR\n        *GPIO_ODR &= ~(1 << pin_position);\n    }\n}\n\n"
        },
        {
            "unique_id": "0cee74ce-551c-4e11-a200-0e859b1ef045",
            "timestamp": "2024-10-31T07:48:14.536180",
            "total time (seconds)": 7.82192325592041,
            "compilation-success": true,
            "Similarity with Previous": 100.0,
            "Similarity with Original": 52.957947255880256,
            "Removed Element": "hardware_abstraction_layer_function_gpio_toggle_pin",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * @brief Reads the state of a specified GPIO pin.\n *\n * This function reads the input data register (IDR) of a GPIO port to determine\n * the state of a specific pin. It calculates the pin position from the pin mask\n * and checks if the pin is set high or low.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return int Returns 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the GPIO Input Data Register (IDR)\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Read the pin state from the IDR and return 1 if high, 0 if low\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n/**\n * @brief Enables the clock for GPIOA.\n * \n * This function enables the clock for the GPIOA peripheral by setting the appropriate\n * bit in the RCC AHB1 peripheral clock enable register (RCC_AHB1ENR). This is necessary\n * before any GPIOA operations can be performed.\n * \n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n    // Enable the clock for GPIOA by setting the 0th bit in the RCC_AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n/**\n * @brief Configures the mode of a specific GPIO pin on the STM32F407 board.\n * \n * This function sets a GPIO pin as either input or output by modifying the\n * GPIO mode register (MODER). It uses direct register manipulation to ensure\n * atomic operations.\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n    // Set the mode (0 for input, 1 for output) at the calculated position\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n/**\n * @brief Writes a value to a specified GPIO pin.\n *\n * This function directly manipulates the output data register (ODR) of a GPIO port\n * to set or reset a specific pin. It calculates the pin position from the pin mask\n * and uses bitwise operations to ensure atomic and reliable pin state changes.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to write (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (1 to set high, 0 to set low).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, int value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Use bitwise operations to set or reset the pin\n    if (value) {\n        // Set the pin by writing 1 to the corresponding bit in the ODR\n        *GPIO_ODR |= (1 << pin_position);\n    } else {\n        // Reset the pin by writing 0 to the corresponding bit in the ODR\n        *GPIO_ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin on the STM32F407 board.\n *\n * This function directly manipulates the Output Data Register (ODR) of a given GPIO port\n * to toggle the state of a specified pin. It uses bitwise XOR operation to ensure atomic\n * and reliable toggling of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the GPIO Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    \n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    \n    // Toggle the pin by using XOR operation on the corresponding bit in the ODR\n    *GPIO_ODR ^= (1 << pin_position);\n}\n\n"
        },
        {
            "unique_id": "0b2e7f13-b572-4531-99ea-5f11d9ce4972",
            "timestamp": "2024-10-31T07:48:40.314257",
            "total time (seconds)": 6.937768220901489,
            "compilation-success": true,
            "Similarity with Previous": 97.6470588235294,
            "Similarity with Original": 52.92857142857142,
            "Removed Element": "hardware_abstraction_layer_function_gpio_read_pin",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * @brief Enables the clock for GPIOA.\n * \n * This function enables the clock for the GPIOA peripheral by setting the appropriate\n * bit in the RCC AHB1 peripheral clock enable register (RCC_AHB1ENR). This is necessary\n * before any GPIOA operations can be performed.\n * \n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n    // Enable the clock for GPIOA by setting the 0th bit in the RCC_AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n/**\n * @brief Configures the mode of a specific GPIO pin on the STM32F407 board.\n * \n * This function sets a GPIO pin as either input or output by modifying the\n * GPIO mode register (MODER). It uses direct register manipulation to ensure\n * atomic operations.\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n    // Set the mode (0 for input, 1 for output) at the calculated position\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n/**\n * @brief Writes a value to a specified GPIO pin.\n *\n * This function directly manipulates the output data register (ODR) of a GPIO port\n * to set or reset a specific pin. It calculates the pin position from the pin mask\n * and uses bitwise operations to ensure atomic and reliable pin state changes.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to write (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (1 to set high, 0 to set low).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, int value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Use bitwise operations to set or reset the pin\n    if (value) {\n        // Set the pin by writing 1 to the corresponding bit in the ODR\n        *GPIO_ODR |= (1 << pin_position);\n    } else {\n        // Reset the pin by writing 0 to the corresponding bit in the ODR\n        *GPIO_ODR &= ~(1 << pin_position);\n    }\n}\n/**\n * @brief Toggles the state of a specified GPIO pin on the STM32F407 board.\n *\n * This function directly manipulates the Output Data Register (ODR) of a given GPIO port\n * to toggle the state of a specified pin. It uses bitwise XOR operation to ensure atomic\n * and reliable toggling of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the GPIO Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Toggle the pin by using XOR operation on the corresponding bit in the ODR\n    *GPIO_ODR ^= (1 << pin_position);\n}\n\n/**\n * @brief Reads the state of a specified GPIO pin.\n *\n * This function reads the input data register (IDR) of a GPIO port to determine\n * the state of a specific pin. It calculates the pin position from the pin mask\n * and checks if the pin is set high or low.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return int Returns 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the GPIO Input Data Register (IDR)\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    \n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    \n    // Read the pin state by checking the corresponding bit in the IDR\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n"
        },
        {
            "unique_id": "b532e930-31bd-475b-b0d5-67607a09b217",
            "timestamp": "2024-10-31T07:49:03.499610",
            "total time (seconds)": 4.969129800796509,
            "compilation-success": true,
            "Similarity with Previous": 100.0,
            "Similarity with Original": 52.92857142857142,
            "Removed Element": "ENABLE_GPIOA_CLOCK",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * @brief Configures the mode of a specific GPIO pin on the STM32F407 board.\n * \n * This function sets a GPIO pin as either input or output by modifying the\n * GPIO mode register (MODER). It uses direct register manipulation to ensure\n * atomic operations.\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n    // Set the mode (0 for input, 1 for output) at the calculated position\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n/**\n * @brief Writes a value to a specified GPIO pin.\n *\n * This function directly manipulates the output data register (ODR) of a GPIO port\n * to set or reset a specific pin. It calculates the pin position from the pin mask\n * and uses bitwise operations to ensure atomic and reliable pin state changes.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to write (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (1 to set high, 0 to set low).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, int value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Use bitwise operations to set or reset the pin\n    if (value) {\n        // Set the pin by writing 1 to the corresponding bit in the ODR\n        *GPIO_ODR |= (1 << pin_position);\n    } else {\n        // Reset the pin by writing 0 to the corresponding bit in the ODR\n        *GPIO_ODR &= ~(1 << pin_position);\n    }\n}\n/**\n * @brief Toggles the state of a specified GPIO pin on the STM32F407 board.\n *\n * This function directly manipulates the Output Data Register (ODR) of a given GPIO port\n * to toggle the state of a specified pin. It uses bitwise XOR operation to ensure atomic\n * and reliable toggling of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the GPIO Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Toggle the pin by using XOR operation on the corresponding bit in the ODR\n    *GPIO_ODR ^= (1 << pin_position);\n}\n/**\n * @brief Reads the state of a specified GPIO pin.\n *\n * This function reads the input data register (IDR) of a GPIO port to determine\n * the state of a specific pin. It calculates the pin position from the pin mask\n * and checks if the pin is set high or low.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return int Returns 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the GPIO Input Data Register (IDR)\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Read the pin state by checking the corresponding bit in the IDR\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Enables the clock for GPIOA.\n * \n * This function enables the clock for the GPIOA peripheral by setting the appropriate\n * bit in the RCC AHB1 peripheral clock enable register (RCC_AHB1ENR). This is necessary\n * before any GPIOA operations can be performed.\n * \n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n    // Enable the clock for GPIOA by setting the 0th bit in the RCC_AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n"
        },
        {
            "unique_id": "57d388c3-c7f9-47d7-a691-05098f43cef0",
            "timestamp": "2024-10-31T07:49:30.667814",
            "total time (seconds)": 7.2051050662994385,
            "compilation-success": true,
            "Similarity with Previous": 89.91517436380772,
            "Similarity with Original": 53.49500713266762,
            "Removed Element": "hardware_abstraction_layer_function_gpio_write_pin",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * @brief Configures the mode of a specific GPIO pin on the STM32F407 board.\n * \n * This function sets a GPIO pin as either input or output by modifying the\n * GPIO mode register (MODER). It uses direct register manipulation to ensure\n * atomic operations.\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n    // Set the mode (0 for input, 1 for output) at the calculated position\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n/**\n * @brief Toggles the state of a specified GPIO pin on the STM32F407 board.\n *\n * This function directly manipulates the Output Data Register (ODR) of a given GPIO port\n * to toggle the state of a specified pin. It uses bitwise XOR operation to ensure atomic\n * and reliable toggling of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the GPIO Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Toggle the pin by using XOR operation on the corresponding bit in the ODR\n    *GPIO_ODR ^= (1 << pin_position);\n}\n/**\n * @brief Reads the state of a specified GPIO pin.\n *\n * This function reads the input data register (IDR) of a GPIO port to determine\n * the state of a specific pin. It calculates the pin position from the pin mask\n * and checks if the pin is set high or low.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return int Returns 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the GPIO Input Data Register (IDR)\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Read the pin state by checking the corresponding bit in the IDR\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n/**\n * @brief Enables the clock for GPIOA.\n * \n * This function enables the clock for the GPIOA peripheral by setting the appropriate\n * bit in the RCC AHB1 peripheral clock enable register (RCC_AHB1ENR). This is necessary\n * before any GPIOA operations can be performed.\n * \n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n    // Enable the clock for GPIOA by setting the 0th bit in the RCC_AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n/**\n * @brief Writes a specified value to a GPIO pin on the STM32F407 board.\n *\n * This function directly manipulates the Output Data Register (ODR) of a given GPIO port\n * to set or reset a specified pin. It uses bitwise operations to ensure atomic and reliable\n * setting or resetting of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to write to (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (1 to set high, 0 to set low).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, int value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Use bitwise operations to set or reset the pin\n    if (value) {\n        // Set the pin by writing 1 to the corresponding bit in the ODR\n        *GPIO_ODR |= (1 << pin_position);\n    } else {\n        // Reset the pin by writing 0 to the corresponding bit in the ODR\n        *GPIO_ODR &= ~(1 << pin_position);\n    }\n}\n\n"
        },
        {
            "unique_id": "8701b8e8-3b55-4741-82d4-99e287cbcd58",
            "timestamp": "2024-10-31T07:49:58.565811",
            "total time (seconds)": 4.930469512939453,
            "compilation-success": true,
            "Similarity with Previous": 96.54150197628458,
            "Similarity with Original": 52.49643366619116,
            "Removed Element": "ENABLE_GPIOA_CLOCK",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * @brief Configures the mode of a specific GPIO pin on the STM32F407 board.\n * \n * This function sets a GPIO pin as either input or output by modifying the\n * GPIO mode register (MODER). It uses direct register manipulation to ensure\n * atomic operations.\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n    // Set the mode (0 for input, 1 for output) at the calculated position\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n/**\n * @brief Toggles the state of a specified GPIO pin on the STM32F407 board.\n *\n * This function directly manipulates the Output Data Register (ODR) of a given GPIO port\n * to toggle the state of a specified pin. It uses bitwise XOR operation to ensure atomic\n * and reliable toggling of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the GPIO Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Toggle the pin by using XOR operation on the corresponding bit in the ODR\n    *GPIO_ODR ^= (1 << pin_position);\n}\n/**\n * @brief Reads the state of a specified GPIO pin.\n *\n * This function reads the input data register (IDR) of a GPIO port to determine\n * the state of a specific pin. It calculates the pin position from the pin mask\n * and checks if the pin is set high or low.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return int Returns 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the GPIO Input Data Register (IDR)\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Read the pin state by checking the corresponding bit in the IDR\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n/**\n * @brief Writes a specified value to a GPIO pin on the STM32F407 board.\n *\n * This function directly manipulates the Output Data Register (ODR) of a given GPIO port\n * to set or reset a specified pin. It uses bitwise operations to ensure atomic and reliable\n * setting or resetting of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to write to (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (1 to set high, 0 to set low).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, int value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Use bitwise operations to set or reset the pin\n    if (value) {\n        // Set the pin by writing 1 to the corresponding bit in the ODR\n        *GPIO_ODR |= (1 << pin_position);\n    } else {\n        // Reset the pin by writing 0 to the corresponding bit in the ODR\n        *GPIO_ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Enables the clock for GPIOA.\n * \n * This function enables the clock for the GPIOA peripheral by setting the appropriate\n * bit in the RCC AHB1 peripheral clock enable register (RCC_AHB1ENR). This is necessary\n * before any GPIOA operations can be performed.\n * \n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n    \n    // Set the bit 0 in RCC_AHB1ENR to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n"
        },
        {
            "unique_id": "c60f128d-01ff-4894-850c-c0637489ff50",
            "timestamp": "2024-10-31T07:50:46.115317",
            "total time (seconds)": 9.381321907043457,
            "compilation-success": true,
            "Similarity with Previous": 98.79638916750251,
            "Similarity with Original": 53.30935251798561,
            "Removed Element": "ENABLE_GPIOA_CLOCK",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * @brief Configures the mode of a specific GPIO pin on the STM32F407 board.\n * \n * This function sets a GPIO pin as either input or output by modifying the\n * GPIO mode register (MODER). It uses direct register manipulation to ensure\n * atomic operations.\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n    // Set the mode (0 for input, 1 for output) at the calculated position\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n/**\n * @brief Toggles the state of a specified GPIO pin on the STM32F407 board.\n *\n * This function directly manipulates the Output Data Register (ODR) of a given GPIO port\n * to toggle the state of a specified pin. It uses bitwise XOR operation to ensure atomic\n * and reliable toggling of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the GPIO Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Toggle the pin by using XOR operation on the corresponding bit in the ODR\n    *GPIO_ODR ^= (1 << pin_position);\n}\n/**\n * @brief Reads the state of a specified GPIO pin.\n *\n * This function reads the input data register (IDR) of a GPIO port to determine\n * the state of a specific pin. It calculates the pin position from the pin mask\n * and checks if the pin is set high or low.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return int Returns 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the GPIO Input Data Register (IDR)\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Read the pin state by checking the corresponding bit in the IDR\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n/**\n * @brief Writes a specified value to a GPIO pin on the STM32F407 board.\n *\n * This function directly manipulates the Output Data Register (ODR) of a given GPIO port\n * to set or reset a specified pin. It uses bitwise operations to ensure atomic and reliable\n * setting or resetting of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to write to (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (1 to set high, 0 to set low).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, int value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Use bitwise operations to set or reset the pin\n    if (value) {\n        // Set the pin by writing 1 to the corresponding bit in the ODR\n        *GPIO_ODR |= (1 << pin_position);\n    } else {\n        // Reset the pin by writing 0 to the corresponding bit in the ODR\n        *GPIO_ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Enables the clock for GPIOA.\n * \n * This function enables the clock for the GPIOA peripheral by setting the appropriate\n * bit in the RCC AHB1 peripheral clock enable register (RCC_AHB1ENR). This is necessary\n * before any GPIOA operations can be performed.\n * \n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n    \n    // Set the bit 0 in RCC_AHB1ENR to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n"
        },
        {
            "unique_id": "2c753701-3855-452b-978f-10b771422d95",
            "timestamp": "2024-10-31T07:51:10.776149",
            "total time (seconds)": 6.173539638519287,
            "compilation-success": true,
            "Similarity with Previous": 92.92543021032505,
            "Similarity with Original": 53.96363636363637,
            "Removed Element": "hardware_abstraction_layer_function_gpio_toggle_pin",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * @brief Configures the mode of a specific GPIO pin on the STM32F407 board.\n * \n * This function sets a GPIO pin as either input or output by modifying the\n * GPIO mode register (MODER). It uses direct register manipulation to ensure\n * atomic operations.\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n    // Set the mode (0 for input, 1 for output) at the calculated position\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n/**\n * @brief Reads the state of a specified GPIO pin.\n *\n * This function reads the input data register (IDR) of a GPIO port to determine\n * the state of a specific pin. It calculates the pin position from the pin mask\n * and checks if the pin is set high or low.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return int Returns 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the GPIO Input Data Register (IDR)\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Read the pin state by checking the corresponding bit in the IDR\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n/**\n * @brief Writes a specified value to a GPIO pin on the STM32F407 board.\n *\n * This function directly manipulates the Output Data Register (ODR) of a given GPIO port\n * to set or reset a specified pin. It uses bitwise operations to ensure atomic and reliable\n * setting or resetting of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to write to (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (1 to set high, 0 to set low).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, int value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Use bitwise operations to set or reset the pin\n    if (value) {\n        // Set the pin by writing 1 to the corresponding bit in the ODR\n        *GPIO_ODR |= (1 << pin_position);\n    } else {\n        // Reset the pin by writing 0 to the corresponding bit in the ODR\n        *GPIO_ODR &= ~(1 << pin_position);\n    }\n}\n/**\n * @brief Enables the clock for GPIOA.\n * \n * This function enables the clock for the GPIOA peripheral by setting the appropriate\n * bit in the RCC AHB1 peripheral clock enable register (RCC_AHB1ENR). This is necessary\n * before any GPIOA operations can be performed.\n * \n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n    // Set the bit 0 in RCC_AHB1ENR to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n *\n * This function toggles the state of a specific GPIO pin by directly manipulating\n * the Output Data Register (ODR) of the GPIO port. It calculates the pin position\n * from the pin mask and uses bitwise XOR to toggle the pin state.\n *\n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the GPIO Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Toggle the pin by using XOR operation on the corresponding bit in the ODR\n    *GPIO_ODR ^= (1 << pin_position);\n}\n\n"
        },
        {
            "unique_id": "eb453b0b-0ff7-40ff-80f5-a3db48cc4ba8",
            "timestamp": "2024-10-31T07:51:40.993911",
            "total time (seconds)": 6.609296798706055,
            "compilation-success": true,
            "Similarity with Previous": 91.55597722960151,
            "Similarity with Original": 53.449527959331874,
            "Removed Element": "hardware_abstraction_layer_function_gpio_toggle_pin",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * @brief Configures the mode of a specific GPIO pin on the STM32F407 board.\n * \n * This function sets a GPIO pin as either input or output by modifying the\n * GPIO mode register (MODER). It uses direct register manipulation to ensure\n * atomic operations.\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n    // Set the mode (0 for input, 1 for output) at the calculated position\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n/**\n * @brief Reads the state of a specified GPIO pin.\n *\n * This function reads the input data register (IDR) of a GPIO port to determine\n * the state of a specific pin. It calculates the pin position from the pin mask\n * and checks if the pin is set high or low.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return int Returns 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the GPIO Input Data Register (IDR)\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Read the pin state by checking the corresponding bit in the IDR\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n/**\n * @brief Writes a specified value to a GPIO pin on the STM32F407 board.\n *\n * This function directly manipulates the Output Data Register (ODR) of a given GPIO port\n * to set or reset a specified pin. It uses bitwise operations to ensure atomic and reliable\n * setting or resetting of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to write to (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (1 to set high, 0 to set low).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, int value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Use bitwise operations to set or reset the pin\n    if (value) {\n        // Set the pin by writing 1 to the corresponding bit in the ODR\n        *GPIO_ODR |= (1 << pin_position);\n    } else {\n        // Reset the pin by writing 0 to the corresponding bit in the ODR\n        *GPIO_ODR &= ~(1 << pin_position);\n    }\n}\n/**\n * @brief Enables the clock for GPIOA.\n * \n * This function enables the clock for the GPIOA peripheral by setting the appropriate\n * bit in the RCC AHB1 peripheral clock enable register (RCC_AHB1ENR). This is necessary\n * before any GPIOA operations can be performed.\n * \n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n    // Set the bit 0 in RCC_AHB1ENR to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n/**\n * @brief Toggles a specified GPIO pin on the STM32F407 board.\n *\n * This function directly manipulates the Output Data Register (ODR) of a given GPIO port\n * to toggle a specified pin. It uses bitwise operations to ensure atomic and reliable\n * toggling of the pin state.\n *\n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the GPIO Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    \n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    \n    // Toggle the pin by using XOR operation on the corresponding bit in the ODR\n    *GPIO_ODR ^= (1 << pin_position);\n}\n\n"
        },
        {
            "unique_id": "d1ee64b1-6f82-4352-88ea-ef1846be66cc",
            "timestamp": "2024-10-31T07:52:06.341538",
            "total time (seconds)": 6.613245248794556,
            "compilation-success": true,
            "Similarity with Previous": 88.45437616387338,
            "Similarity with Original": 53.94641564083997,
            "Removed Element": "hardware_abstraction_layer_function_gpio_read_pin",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * @brief Configures the mode of a specific GPIO pin on the STM32F407 board.\n * \n * This function sets a GPIO pin as either input or output by modifying the\n * GPIO mode register (MODER). It uses direct register manipulation to ensure\n * atomic operations.\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n    // Set the mode (0 for input, 1 for output) at the calculated position\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n/**\n * @brief Writes a specified value to a GPIO pin on the STM32F407 board.\n *\n * This function directly manipulates the Output Data Register (ODR) of a given GPIO port\n * to set or reset a specified pin. It uses bitwise operations to ensure atomic and reliable\n * setting or resetting of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to write to (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (1 to set high, 0 to set low).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, int value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Use bitwise operations to set or reset the pin\n    if (value) {\n        // Set the pin by writing 1 to the corresponding bit in the ODR\n        *GPIO_ODR |= (1 << pin_position);\n    } else {\n        // Reset the pin by writing 0 to the corresponding bit in the ODR\n        *GPIO_ODR &= ~(1 << pin_position);\n    }\n}\n/**\n * @brief Enables the clock for GPIOA.\n * \n * This function enables the clock for the GPIOA peripheral by setting the appropriate\n * bit in the RCC AHB1 peripheral clock enable register (RCC_AHB1ENR). This is necessary\n * before any GPIOA operations can be performed.\n * \n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n    // Set the bit 0 in RCC_AHB1ENR to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n/**\n * @brief Toggles a specified GPIO pin on the STM32F407 board.\n *\n * This function directly manipulates the Output Data Register (ODR) of a given GPIO port\n * to toggle a specified pin. It uses bitwise operations to ensure atomic and reliable\n * toggling of the pin state.\n *\n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the GPIO Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Toggle the pin by using XOR operation on the corresponding bit in the ODR\n    *GPIO_ODR ^= (1 << pin_position);\n}\n\n/**\n * @brief Reads the state of a specified GPIO pin on the STM32F407 board.\n *\n * This function directly accesses the Input Data Register (IDR) of a given GPIO port\n * to read the state of a specified pin. It uses bitwise operations to determine the\n * state of the pin.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to be read (e.g., 1 << 5 for pin 5).\n * @return int Returns 1 if the pin is set (high), 0 if the pin is reset (low).\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the GPIO Input Data Register (IDR)\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    \n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    \n    // Read the pin state by checking the corresponding bit in the IDR\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n"
        },
        {
            "unique_id": "954e8482-9b81-47b7-8940-00f91de5b7be",
            "timestamp": "2024-10-31T07:52:38.897437",
            "total time (seconds)": 5.759170055389404,
            "compilation-success": true,
            "Similarity with Previous": 93.14938154138915,
            "Similarity with Original": 53.935018050541515,
            "Removed Element": "hardware_abstraction_layer_function_gpio_toggle_pin",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * @brief Configures the mode of a specific GPIO pin on the STM32F407 board.\n * \n * This function sets a GPIO pin as either input or output by modifying the\n * GPIO mode register (MODER). It uses direct register manipulation to ensure\n * atomic operations.\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n    // Set the mode (0 for input, 1 for output) at the calculated position\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n/**\n * @brief Writes a specified value to a GPIO pin on the STM32F407 board.\n *\n * This function directly manipulates the Output Data Register (ODR) of a given GPIO port\n * to set or reset a specified pin. It uses bitwise operations to ensure atomic and reliable\n * setting or resetting of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to write to (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (1 to set high, 0 to set low).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, int value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Use bitwise operations to set or reset the pin\n    if (value) {\n        // Set the pin by writing 1 to the corresponding bit in the ODR\n        *GPIO_ODR |= (1 << pin_position);\n    } else {\n        // Reset the pin by writing 0 to the corresponding bit in the ODR\n        *GPIO_ODR &= ~(1 << pin_position);\n    }\n}\n/**\n * @brief Enables the clock for GPIOA.\n * \n * This function enables the clock for the GPIOA peripheral by setting the appropriate\n * bit in the RCC AHB1 peripheral clock enable register (RCC_AHB1ENR). This is necessary\n * before any GPIOA operations can be performed.\n * \n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n    // Set the bit 0 in RCC_AHB1ENR to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n/**\n * @brief Reads the state of a specified GPIO pin on the STM32F407 board.\n *\n * This function directly accesses the Input Data Register (IDR) of a given GPIO port\n * to read the state of a specified pin. It uses bitwise operations to determine the\n * state of the pin.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to be read (e.g., 1 << 5 for pin 5).\n * @return int Returns 1 if the pin is set (high), 0 if the pin is reset (low).\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the GPIO Input Data Register (IDR)\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Read the pin state by checking the corresponding bit in the IDR\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin on the STM32F407 board.\n *\n * This function directly accesses the Output Data Register (ODR) of a given GPIO port\n * to toggle the state of a specified pin. It uses bitwise XOR operation to ensure\n * atomic and reliable toggling of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to be toggled (e.g., 1 << 5 for pin 5).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the GPIO Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    \n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    \n    // Toggle the pin by using XOR operation on the corresponding bit in the ODR\n    *GPIO_ODR ^= (1 << pin_position);\n}\n\n"
        },
        {
            "unique_id": "96778657-a1de-49f7-86a6-23ae586a772f",
            "timestamp": "2024-10-31T07:53:03.512268",
            "total time (seconds)": 6.843870401382446,
            "compilation-success": true,
            "Similarity with Previous": 92.95112781954887,
            "Similarity with Original": 51.18881118881119,
            "Removed Element": "set_input_output_mode",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * @brief Writes a specified value to a GPIO pin on the STM32F407 board.\n *\n * This function directly manipulates the Output Data Register (ODR) of a given GPIO port\n * to set or reset a specified pin. It uses bitwise operations to ensure atomic and reliable\n * setting or resetting of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to write to (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (1 to set high, 0 to set low).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, int value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Use bitwise operations to set or reset the pin\n    if (value) {\n        // Set the pin by writing 1 to the corresponding bit in the ODR\n        *GPIO_ODR |= (1 << pin_position);\n    } else {\n        // Reset the pin by writing 0 to the corresponding bit in the ODR\n        *GPIO_ODR &= ~(1 << pin_position);\n    }\n}\n/**\n * @brief Enables the clock for GPIOA.\n * \n * This function enables the clock for the GPIOA peripheral by setting the appropriate\n * bit in the RCC AHB1 peripheral clock enable register (RCC_AHB1ENR). This is necessary\n * before any GPIOA operations can be performed.\n * \n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n    // Set the bit 0 in RCC_AHB1ENR to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n/**\n * @brief Reads the state of a specified GPIO pin on the STM32F407 board.\n *\n * This function directly accesses the Input Data Register (IDR) of a given GPIO port\n * to read the state of a specified pin. It uses bitwise operations to determine the\n * state of the pin.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to be read (e.g., 1 << 5 for pin 5).\n * @return int Returns 1 if the pin is set (high), 0 if the pin is reset (low).\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the GPIO Input Data Register (IDR)\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Read the pin state by checking the corresponding bit in the IDR\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n/**\n * @brief Toggles the state of a specified GPIO pin on the STM32F407 board.\n *\n * This function directly accesses the Output Data Register (ODR) of a given GPIO port\n * to toggle the state of a specified pin. It uses bitwise XOR operation to ensure\n * atomic and reliable toggling of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to be toggled (e.g., 1 << 5 for pin 5).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the GPIO Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Toggle the pin by using XOR operation on the corresponding bit in the ODR\n    *GPIO_ODR ^= (1 << pin_position);\n}\n\n/**\n * @brief Configures the mode of a specific GPIO pin on the STM32F407 board.\n * \n * This function sets a GPIO pin as either input or output by modifying the\n * GPIO mode register (MODER). It uses direct register manipulation to ensure\n * atomic operations.\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Pointer to the GPIO MODER register\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base);\n\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Each pin has 2 bits in the MODER register\n    uint32_t moder_position = pin_position * 2;\n\n    // Clear the 2 bits corresponding to the pin\n    *GPIO_MODER &= ~(0x3 << moder_position);\n\n    // Set the mode (0 for input, 1 for output)\n    *GPIO_MODER |= (mode << moder_position);\n}\n\n"
        },
        {
            "unique_id": "277d0df5-2eda-41db-b94a-c2c294b10ed6",
            "timestamp": "2024-10-31T07:53:32.307696",
            "total time (seconds)": 8.26948618888855,
            "compilation-success": true,
            "Similarity with Previous": 97.48062015503875,
            "Similarity with Original": 51.25698324022346,
            "Removed Element": "hardware_abstraction_layer_function_gpio_read_pin",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * @brief Writes a specified value to a GPIO pin on the STM32F407 board.\n *\n * This function directly manipulates the Output Data Register (ODR) of a given GPIO port\n * to set or reset a specified pin. It uses bitwise operations to ensure atomic and reliable\n * setting or resetting of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to write to (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (1 to set high, 0 to set low).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, int value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Use bitwise operations to set or reset the pin\n    if (value) {\n        // Set the pin by writing 1 to the corresponding bit in the ODR\n        *GPIO_ODR |= (1 << pin_position);\n    } else {\n        // Reset the pin by writing 0 to the corresponding bit in the ODR\n        *GPIO_ODR &= ~(1 << pin_position);\n    }\n}\n/**\n * @brief Enables the clock for GPIOA.\n * \n * This function enables the clock for the GPIOA peripheral by setting the appropriate\n * bit in the RCC AHB1 peripheral clock enable register (RCC_AHB1ENR). This is necessary\n * before any GPIOA operations can be performed.\n * \n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n    // Set the bit 0 in RCC_AHB1ENR to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n/**\n * @brief Toggles the state of a specified GPIO pin on the STM32F407 board.\n *\n * This function directly accesses the Output Data Register (ODR) of a given GPIO port\n * to toggle the state of a specified pin. It uses bitwise XOR operation to ensure\n * atomic and reliable toggling of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to be toggled (e.g., 1 << 5 for pin 5).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the GPIO Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Toggle the pin by using XOR operation on the corresponding bit in the ODR\n    *GPIO_ODR ^= (1 << pin_position);\n}\n/**\n * @brief Configures the mode of a specific GPIO pin on the STM32F407 board.\n * \n * This function sets a GPIO pin as either input or output by modifying the\n * GPIO mode register (MODER). It uses direct register manipulation to ensure\n * atomic operations.\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Pointer to the GPIO MODER register\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base);\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Each pin has 2 bits in the MODER register\n    uint32_t moder_position = pin_position * 2;\n    // Clear the 2 bits corresponding to the pin\n    *GPIO_MODER &= ~(0x3 << moder_position);\n    // Set the mode (0 for input, 1 for output)\n    *GPIO_MODER |= (mode << moder_position);\n}\n\n/**\n * @brief Reads the state of a specified GPIO pin on the STM32F407 board.\n *\n * This function directly accesses the Input Data Register (IDR) of a given GPIO port\n * to read the state of a specified pin. It uses bitwise operations to determine the\n * state of the pin.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to be read (e.g., 1 << 5 for pin 5).\n * @return int Returns 1 if the pin is set (high), 0 if the pin is reset (low).\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Input Data Register (IDR)\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    \n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    \n    // Read the state of the pin by checking the corresponding bit in the IDR\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n"
        },
        {
            "unique_id": "2c3fd298-d10d-4093-beec-9914b15e527a",
            "timestamp": "2024-10-31T07:53:57.590280",
            "total time (seconds)": 7.160392999649048,
            "compilation-success": true,
            "Similarity with Previous": 88.85844748858447,
            "Similarity with Original": 51.77304964539007,
            "Removed Element": "hardware_abstraction_layer_function_gpio_write_pin",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * @brief Enables the clock for GPIOA.\n * \n * This function enables the clock for the GPIOA peripheral by setting the appropriate\n * bit in the RCC AHB1 peripheral clock enable register (RCC_AHB1ENR). This is necessary\n * before any GPIOA operations can be performed.\n * \n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n    // Set the bit 0 in RCC_AHB1ENR to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n/**\n * @brief Toggles the state of a specified GPIO pin on the STM32F407 board.\n *\n * This function directly accesses the Output Data Register (ODR) of a given GPIO port\n * to toggle the state of a specified pin. It uses bitwise XOR operation to ensure\n * atomic and reliable toggling of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to be toggled (e.g., 1 << 5 for pin 5).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the GPIO Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Toggle the pin by using XOR operation on the corresponding bit in the ODR\n    *GPIO_ODR ^= (1 << pin_position);\n}\n/**\n * @brief Configures the mode of a specific GPIO pin on the STM32F407 board.\n * \n * This function sets a GPIO pin as either input or output by modifying the\n * GPIO mode register (MODER). It uses direct register manipulation to ensure\n * atomic operations.\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Pointer to the GPIO MODER register\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base);\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Each pin has 2 bits in the MODER register\n    uint32_t moder_position = pin_position * 2;\n    // Clear the 2 bits corresponding to the pin\n    *GPIO_MODER &= ~(0x3 << moder_position);\n    // Set the mode (0 for input, 1 for output)\n    *GPIO_MODER |= (mode << moder_position);\n}\n/**\n * @brief Reads the state of a specified GPIO pin on the STM32F407 board.\n *\n * This function directly accesses the Input Data Register (IDR) of a given GPIO port\n * to read the state of a specified pin. It uses bitwise operations to determine the\n * state of the pin.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to be read (e.g., 1 << 5 for pin 5).\n * @return int Returns 1 if the pin is set (high), 0 if the pin is reset (low).\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Input Data Register (IDR)\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Read the state of the pin by checking the corresponding bit in the IDR\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function sets or resets a specific GPIO pin by directly manipulating\n * the Output Data Register (ODR) of the GPIO port. It ensures atomic operations\n * by using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (1 to set the pin, 0 to reset the pin).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, int value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    \n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    \n    // Use bitwise operations to set or reset the pin\n    if (value) {\n        // Set the pin by writing 1 to the corresponding bit in the ODR\n        *GPIO_ODR |= (1 << pin_position);\n    } else {\n        // Reset the pin by writing 0 to the corresponding bit in the ODR\n        *GPIO_ODR &= ~(1 << pin_position);\n    }\n}\n\n"
        },
        {
            "unique_id": "8432fd88-d78e-4b4e-bcb9-d3d2fd25294a",
            "timestamp": "2024-10-31T07:54:24.171639",
            "total time (seconds)": 9.781143426895142,
            "compilation-success": true,
            "Similarity with Previous": 98.3218163869694,
            "Similarity with Original": 51.70454545454546,
            "Removed Element": "hardware_abstraction_layer_function_gpio_read_pin",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * @brief Enables the clock for GPIOA.\n * \n * This function enables the clock for the GPIOA peripheral by setting the appropriate\n * bit in the RCC AHB1 peripheral clock enable register (RCC_AHB1ENR). This is necessary\n * before any GPIOA operations can be performed.\n * \n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n    // Set the bit 0 in RCC_AHB1ENR to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n/**\n * @brief Toggles the state of a specified GPIO pin on the STM32F407 board.\n *\n * This function directly accesses the Output Data Register (ODR) of a given GPIO port\n * to toggle the state of a specified pin. It uses bitwise XOR operation to ensure\n * atomic and reliable toggling of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to be toggled (e.g., 1 << 5 for pin 5).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the GPIO Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Toggle the pin by using XOR operation on the corresponding bit in the ODR\n    *GPIO_ODR ^= (1 << pin_position);\n}\n/**\n * @brief Configures the mode of a specific GPIO pin on the STM32F407 board.\n * \n * This function sets a GPIO pin as either input or output by modifying the\n * GPIO mode register (MODER). It uses direct register manipulation to ensure\n * atomic operations.\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Pointer to the GPIO MODER register\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base);\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Each pin has 2 bits in the MODER register\n    uint32_t moder_position = pin_position * 2;\n    // Clear the 2 bits corresponding to the pin\n    *GPIO_MODER &= ~(0x3 << moder_position);\n    // Set the mode (0 for input, 1 for output)\n    *GPIO_MODER |= (mode << moder_position);\n}\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function sets or resets a specific GPIO pin by directly manipulating\n * the Output Data Register (ODR) of the GPIO port. It ensures atomic operations\n * by using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (1 to set the pin, 0 to reset the pin).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, int value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Use bitwise operations to set or reset the pin\n    if (value) {\n        // Set the pin by writing 1 to the corresponding bit in the ODR\n        *GPIO_ODR |= (1 << pin_position);\n    } else {\n        // Reset the pin by writing 0 to the corresponding bit in the ODR\n        *GPIO_ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specified GPIO pin on the STM32F407 board.\n *\n * This function directly accesses the Input Data Register (IDR) of a given GPIO port\n * to read the state of a specified pin. It uses bitwise operations to determine the\n * state of the pin.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to be read (e.g., 1 << 5 for pin 5).\n * @return int Returns 1 if the pin is set (high), 0 if the pin is reset (low).\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Input Data Register (IDR)\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    \n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    \n    // Read the pin state by checking the corresponding bit in the IDR\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n"
        },
        {
            "unique_id": "764def7d-5981-43ac-bcf1-f8e75ad11f70",
            "timestamp": "2024-10-31T07:54:52.533070",
            "total time (seconds)": 6.3548338413238525,
            "compilation-success": true,
            "Similarity with Previous": 98.69608826479438,
            "Similarity with Original": 51.971326164874554,
            "Removed Element": "hardware_abstraction_layer_function_gpio_toggle_pin",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * @brief Enables the clock for GPIOA.\n * \n * This function enables the clock for the GPIOA peripheral by setting the appropriate\n * bit in the RCC AHB1 peripheral clock enable register (RCC_AHB1ENR). This is necessary\n * before any GPIOA operations can be performed.\n * \n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n    // Set the bit 0 in RCC_AHB1ENR to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n/**\n * @brief Configures the mode of a specific GPIO pin on the STM32F407 board.\n * \n * This function sets a GPIO pin as either input or output by modifying the\n * GPIO mode register (MODER). It uses direct register manipulation to ensure\n * atomic operations.\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Pointer to the GPIO MODER register\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base);\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Each pin has 2 bits in the MODER register\n    uint32_t moder_position = pin_position * 2;\n    // Clear the 2 bits corresponding to the pin\n    *GPIO_MODER &= ~(0x3 << moder_position);\n    // Set the mode (0 for input, 1 for output)\n    *GPIO_MODER |= (mode << moder_position);\n}\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function sets or resets a specific GPIO pin by directly manipulating\n * the Output Data Register (ODR) of the GPIO port. It ensures atomic operations\n * by using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (1 to set the pin, 0 to reset the pin).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, int value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Use bitwise operations to set or reset the pin\n    if (value) {\n        // Set the pin by writing 1 to the corresponding bit in the ODR\n        *GPIO_ODR |= (1 << pin_position);\n    } else {\n        // Reset the pin by writing 0 to the corresponding bit in the ODR\n        *GPIO_ODR &= ~(1 << pin_position);\n    }\n}\n/**\n * @brief Reads the state of a specified GPIO pin on the STM32F407 board.\n *\n * This function directly accesses the Input Data Register (IDR) of a given GPIO port\n * to read the state of a specified pin. It uses bitwise operations to determine the\n * state of the pin.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to be read (e.g., 1 << 5 for pin 5).\n * @return int Returns 1 if the pin is set (high), 0 if the pin is reset (low).\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Input Data Register (IDR)\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Read the pin state by checking the corresponding bit in the IDR\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * This function directly accesses the Output Data Register (ODR) of a given GPIO port\n * to toggle the state of a specified pin. It uses bitwise XOR operation to ensure\n * atomic and reliable toggling of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to be toggled (e.g., 1 << 5 for pin 5).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the GPIO Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    \n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    \n    // Toggle the pin by using XOR operation on the corresponding bit in the ODR\n    *GPIO_ODR ^= (1 << pin_position);\n}\n\n"
        },
        {
            "unique_id": "b4bf755e-1f3b-44fa-8fa5-026f878e16e7",
            "timestamp": "2024-10-31T07:55:24.985234",
            "total time (seconds)": 12.958686590194702,
            "compilation-success": true,
            "Similarity with Previous": 92.87109375,
            "Similarity with Original": 51.76385889128869,
            "Removed Element": "hardware_abstraction_layer_function_gpio_read_pin",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * @brief Enables the clock for GPIOA.\n * \n * This function enables the clock for the GPIOA peripheral by setting the appropriate\n * bit in the RCC AHB1 peripheral clock enable register (RCC_AHB1ENR). This is necessary\n * before any GPIOA operations can be performed.\n * \n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n    // Set the bit 0 in RCC_AHB1ENR to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n/**\n * @brief Configures the mode of a specific GPIO pin on the STM32F407 board.\n * \n * This function sets a GPIO pin as either input or output by modifying the\n * GPIO mode register (MODER). It uses direct register manipulation to ensure\n * atomic operations.\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Pointer to the GPIO MODER register\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base);\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Each pin has 2 bits in the MODER register\n    uint32_t moder_position = pin_position * 2;\n    // Clear the 2 bits corresponding to the pin\n    *GPIO_MODER &= ~(0x3 << moder_position);\n    // Set the mode (0 for input, 1 for output)\n    *GPIO_MODER |= (mode << moder_position);\n}\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function sets or resets a specific GPIO pin by directly manipulating\n * the Output Data Register (ODR) of the GPIO port. It ensures atomic operations\n * by using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (1 to set the pin, 0 to reset the pin).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, int value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Use bitwise operations to set or reset the pin\n    if (value) {\n        // Set the pin by writing 1 to the corresponding bit in the ODR\n        *GPIO_ODR |= (1 << pin_position);\n    } else {\n        // Reset the pin by writing 0 to the corresponding bit in the ODR\n        *GPIO_ODR &= ~(1 << pin_position);\n    }\n}\n/**\n * This function directly accesses the Output Data Register (ODR) of a given GPIO port\n * to toggle the state of a specified pin. It uses bitwise XOR operation to ensure\n * atomic and reliable toggling of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to be toggled (e.g., 1 << 5 for pin 5).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the GPIO Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Toggle the pin by using XOR operation on the corresponding bit in the ODR\n    *GPIO_ODR ^= (1 << pin_position);\n}\n\n/**\n * This function reads the state of a specified GPIO pin by accessing the Input Data Register (IDR)\n * of a given GPIO port. It determines the pin position using a loop to find the first set bit in the pin mask.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to be read (e.g., 1 << 5 for pin 5).\n * @return int Returns 1 if the pin is set (high), 0 if the pin is reset (low).\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Input Data Register (IDR)\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    \n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    \n    // Read the pin state by checking the corresponding bit in the IDR\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n"
        },
        {
            "unique_id": "d2b67125-582d-47ee-adf2-ea4e54147b93",
            "timestamp": "2024-10-31T07:56:09.745788",
            "total time (seconds)": 5.714649677276611,
            "compilation-success": true,
            "Similarity with Previous": 100.0,
            "Similarity with Original": 51.76385889128869,
            "Removed Element": "ENABLE_GPIOA_CLOCK",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * @brief Configures the mode of a specific GPIO pin on the STM32F407 board.\n * \n * This function sets a GPIO pin as either input or output by modifying the\n * GPIO mode register (MODER). It uses direct register manipulation to ensure\n * atomic operations.\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Pointer to the GPIO MODER register\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base);\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Each pin has 2 bits in the MODER register\n    uint32_t moder_position = pin_position * 2;\n    // Clear the 2 bits corresponding to the pin\n    *GPIO_MODER &= ~(0x3 << moder_position);\n    // Set the mode (0 for input, 1 for output)\n    *GPIO_MODER |= (mode << moder_position);\n}\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function sets or resets a specific GPIO pin by directly manipulating\n * the Output Data Register (ODR) of the GPIO port. It ensures atomic operations\n * by using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (1 to set the pin, 0 to reset the pin).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, int value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Use bitwise operations to set or reset the pin\n    if (value) {\n        // Set the pin by writing 1 to the corresponding bit in the ODR\n        *GPIO_ODR |= (1 << pin_position);\n    } else {\n        // Reset the pin by writing 0 to the corresponding bit in the ODR\n        *GPIO_ODR &= ~(1 << pin_position);\n    }\n}\n/**\n * This function directly accesses the Output Data Register (ODR) of a given GPIO port\n * to toggle the state of a specified pin. It uses bitwise XOR operation to ensure\n * atomic and reliable toggling of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to be toggled (e.g., 1 << 5 for pin 5).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the GPIO Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Toggle the pin by using XOR operation on the corresponding bit in the ODR\n    *GPIO_ODR ^= (1 << pin_position);\n}\n/**\n * This function reads the state of a specified GPIO pin by accessing the Input Data Register (IDR)\n * of a given GPIO port. It determines the pin position using a loop to find the first set bit in the pin mask.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to be read (e.g., 1 << 5 for pin 5).\n * @return int Returns 1 if the pin is set (high), 0 if the pin is reset (low).\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Input Data Register (IDR)\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Read the pin state by checking the corresponding bit in the IDR\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Enables the clock for GPIOA.\n * \n * This function enables the clock for the GPIOA peripheral by setting the appropriate\n * bit in the RCC AHB1 peripheral clock enable register (RCC_AHB1ENR). This is necessary\n * before any GPIOA operations can be performed.\n * \n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n    // Set the bit 0 in RCC_AHB1ENR to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n"
        },
        {
            "unique_id": "f3752cb4-ced8-4990-822b-1b20e913d1ad",
            "timestamp": "2024-10-31T07:56:37.464465",
            "total time (seconds)": 6.773464202880859,
            "compilation-success": true,
            "Similarity with Previous": 93.84309831181727,
            "Similarity with Original": 50.17818959372773,
            "Removed Element": "hardware_abstraction_layer_function_gpio_write_pin",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * @brief Configures the mode of a specific GPIO pin on the STM32F407 board.\n * \n * This function sets a GPIO pin as either input or output by modifying the\n * GPIO mode register (MODER). It uses direct register manipulation to ensure\n * atomic operations.\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Pointer to the GPIO MODER register\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base);\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Each pin has 2 bits in the MODER register\n    uint32_t moder_position = pin_position * 2;\n    // Clear the 2 bits corresponding to the pin\n    *GPIO_MODER &= ~(0x3 << moder_position);\n    // Set the mode (0 for input, 1 for output)\n    *GPIO_MODER |= (mode << moder_position);\n}\n/**\n * This function directly accesses the Output Data Register (ODR) of a given GPIO port\n * to toggle the state of a specified pin. It uses bitwise XOR operation to ensure\n * atomic and reliable toggling of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to be toggled (e.g., 1 << 5 for pin 5).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the GPIO Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Toggle the pin by using XOR operation on the corresponding bit in the ODR\n    *GPIO_ODR ^= (1 << pin_position);\n}\n/**\n * This function reads the state of a specified GPIO pin by accessing the Input Data Register (IDR)\n * of a given GPIO port. It determines the pin position using a loop to find the first set bit in the pin mask.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to be read (e.g., 1 << 5 for pin 5).\n * @return int Returns 1 if the pin is set (high), 0 if the pin is reset (low).\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Input Data Register (IDR)\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Read the pin state by checking the corresponding bit in the IDR\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n/**\n * @brief Enables the clock for GPIOA.\n * \n * This function enables the clock for the GPIOA peripheral by setting the appropriate\n * bit in the RCC AHB1 peripheral clock enable register (RCC_AHB1ENR). This is necessary\n * before any GPIOA operations can be performed.\n * \n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n    // Set the bit 0 in RCC_AHB1ENR to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n/**\n * This function directly accesses the Output Data Register (ODR) of a given GPIO port\n * to set or reset a specific pin. It uses bitwise operations to ensure atomic and reliable\n * manipulation of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (1 to set the pin, 0 to reset the pin).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, int value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    \n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    \n    // Use bitwise operations to set or reset the pin\n    if (value) {\n        // Set the pin by writing 1 to the corresponding bit in the ODR\n        *GPIO_ODR |= (1 << pin_position);\n    } else {\n        // Reset the pin by writing 0 to the corresponding bit in the ODR\n        *GPIO_ODR &= ~(1 << pin_position);\n    }\n}\n\n"
        },
        {
            "unique_id": "63417819-cda7-4c0b-b189-a728f18d832d",
            "timestamp": "2024-10-31T07:57:12.141292",
            "total time (seconds)": 13.026094675064087,
            "compilation-success": true,
            "Similarity with Previous": 93.57707509881423,
            "Similarity with Original": 50.49575070821529,
            "Removed Element": "hardware_abstraction_layer_function_gpio_toggle_pin",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * @brief Configures the mode of a specific GPIO pin on the STM32F407 board.\n * \n * This function sets a GPIO pin as either input or output by modifying the\n * GPIO mode register (MODER). It uses direct register manipulation to ensure\n * atomic operations.\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Pointer to the GPIO MODER register\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base);\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Each pin has 2 bits in the MODER register\n    uint32_t moder_position = pin_position * 2;\n    // Clear the 2 bits corresponding to the pin\n    *GPIO_MODER &= ~(0x3 << moder_position);\n    // Set the mode (0 for input, 1 for output)\n    *GPIO_MODER |= (mode << moder_position);\n}\n/**\n * This function reads the state of a specified GPIO pin by accessing the Input Data Register (IDR)\n * of a given GPIO port. It determines the pin position using a loop to find the first set bit in the pin mask.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to be read (e.g., 1 << 5 for pin 5).\n * @return int Returns 1 if the pin is set (high), 0 if the pin is reset (low).\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Input Data Register (IDR)\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Read the pin state by checking the corresponding bit in the IDR\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n/**\n * @brief Enables the clock for GPIOA.\n * \n * This function enables the clock for the GPIOA peripheral by setting the appropriate\n * bit in the RCC AHB1 peripheral clock enable register (RCC_AHB1ENR). This is necessary\n * before any GPIOA operations can be performed.\n * \n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n    // Set the bit 0 in RCC_AHB1ENR to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n/**\n * This function directly accesses the Output Data Register (ODR) of a given GPIO port\n * to set or reset a specific pin. It uses bitwise operations to ensure atomic and reliable\n * manipulation of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (1 to set the pin, 0 to reset the pin).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, int value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Use bitwise operations to set or reset the pin\n    if (value) {\n        // Set the pin by writing 1 to the corresponding bit in the ODR\n        *GPIO_ODR |= (1 << pin_position);\n    } else {\n        // Reset the pin by writing 0 to the corresponding bit in the ODR\n        *GPIO_ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin by directly manipulating the Output Data Register (ODR).\n * \n * This function calculates the pin position from the provided pin mask and toggles the corresponding bit\n * in the ODR of the specified GPIO port. It ensures atomic and reliable operations by using bitwise XOR.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to be toggled (e.g., 1 << 5 for pin 5).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the GPIO Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    \n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    \n    // Toggle the pin by using XOR operation on the corresponding bit in the ODR\n    *GPIO_ODR ^= (1 << pin_position);\n}\n\n"
        },
        {
            "unique_id": "89d1b1f0-f237-484c-ab9b-c8b2f4b099ce",
            "timestamp": "2024-10-31T07:57:42.195064",
            "total time (seconds)": 9.121497392654419,
            "compilation-success": true,
            "Similarity with Previous": 91.5157292659676,
            "Similarity with Original": 51.45907473309609,
            "Removed Element": "hardware_abstraction_layer_function_gpio_toggle_pin",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * @brief Configures the mode of a specific GPIO pin on the STM32F407 board.\n * \n * This function sets a GPIO pin as either input or output by modifying the\n * GPIO mode register (MODER). It uses direct register manipulation to ensure\n * atomic operations.\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Pointer to the GPIO MODER register\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base);\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Each pin has 2 bits in the MODER register\n    uint32_t moder_position = pin_position * 2;\n    // Clear the 2 bits corresponding to the pin\n    *GPIO_MODER &= ~(0x3 << moder_position);\n    // Set the mode (0 for input, 1 for output)\n    *GPIO_MODER |= (mode << moder_position);\n}\n/**\n * This function reads the state of a specified GPIO pin by accessing the Input Data Register (IDR)\n * of a given GPIO port. It determines the pin position using a loop to find the first set bit in the pin mask.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to be read (e.g., 1 << 5 for pin 5).\n * @return int Returns 1 if the pin is set (high), 0 if the pin is reset (low).\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Input Data Register (IDR)\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Read the pin state by checking the corresponding bit in the IDR\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n/**\n * @brief Enables the clock for GPIOA.\n * \n * This function enables the clock for the GPIOA peripheral by setting the appropriate\n * bit in the RCC AHB1 peripheral clock enable register (RCC_AHB1ENR). This is necessary\n * before any GPIOA operations can be performed.\n * \n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n    // Set the bit 0 in RCC_AHB1ENR to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n/**\n * This function directly accesses the Output Data Register (ODR) of a given GPIO port\n * to set or reset a specific pin. It uses bitwise operations to ensure atomic and reliable\n * manipulation of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (1 to set the pin, 0 to reset the pin).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, int value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Use bitwise operations to set or reset the pin\n    if (value) {\n        // Set the pin by writing 1 to the corresponding bit in the ODR\n        *GPIO_ODR |= (1 << pin_position);\n    } else {\n        // Reset the pin by writing 0 to the corresponding bit in the ODR\n        *GPIO_ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function toggles the state of a GPIO pin by directly manipulating the\n * Output Data Register (ODR) of the specified GPIO port. It uses bitwise XOR\n * to flip the state of the pin, ensuring atomic and reliable operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to be toggled (e.g., 1 << 5 for pin 5).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the GPIO Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    \n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    \n    // Toggle the pin by using XOR operation on the corresponding bit in the ODR\n    *GPIO_ODR ^= (1 << pin_position);\n}\n\n"
        },
        {
            "unique_id": "645e3eaf-9362-43ff-8fec-a1a380bc64dd",
            "timestamp": "2024-10-31T07:58:05.511089",
            "total time (seconds)": 4.340450763702393,
            "compilation-success": true,
            "Similarity with Previous": 98.29488465396189,
            "Similarity with Original": 50.67043048694425,
            "Removed Element": "ENABLE_GPIOA_CLOCK",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * @brief Configures the mode of a specific GPIO pin on the STM32F407 board.\n * \n * This function sets a GPIO pin as either input or output by modifying the\n * GPIO mode register (MODER). It uses direct register manipulation to ensure\n * atomic operations.\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Pointer to the GPIO MODER register\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base);\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Each pin has 2 bits in the MODER register\n    uint32_t moder_position = pin_position * 2;\n    // Clear the 2 bits corresponding to the pin\n    *GPIO_MODER &= ~(0x3 << moder_position);\n    // Set the mode (0 for input, 1 for output)\n    *GPIO_MODER |= (mode << moder_position);\n}\n/**\n * This function reads the state of a specified GPIO pin by accessing the Input Data Register (IDR)\n * of a given GPIO port. It determines the pin position using a loop to find the first set bit in the pin mask.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to be read (e.g., 1 << 5 for pin 5).\n * @return int Returns 1 if the pin is set (high), 0 if the pin is reset (low).\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Input Data Register (IDR)\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Read the pin state by checking the corresponding bit in the IDR\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n/**\n * This function directly accesses the Output Data Register (ODR) of a given GPIO port\n * to set or reset a specific pin. It uses bitwise operations to ensure atomic and reliable\n * manipulation of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (1 to set the pin, 0 to reset the pin).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, int value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Use bitwise operations to set or reset the pin\n    if (value) {\n        // Set the pin by writing 1 to the corresponding bit in the ODR\n        *GPIO_ODR |= (1 << pin_position);\n    } else {\n        // Reset the pin by writing 0 to the corresponding bit in the ODR\n        *GPIO_ODR &= ~(1 << pin_position);\n    }\n}\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function toggles the state of a GPIO pin by directly manipulating the\n * Output Data Register (ODR) of the specified GPIO port. It uses bitwise XOR\n * to flip the state of the pin, ensuring atomic and reliable operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to be toggled (e.g., 1 << 5 for pin 5).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the GPIO Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Toggle the pin by using XOR operation on the corresponding bit in the ODR\n    *GPIO_ODR ^= (1 << pin_position);\n}\n\n/**\n * @brief Enables the clock for GPIOA.\n * \n * This function enables the clock for the GPIOA peripheral by setting the appropriate\n * bit in the RCC AHB1 peripheral clock enable register (RCC_AHB1ENR). This is necessary\n * before any GPIOA operations can be performed.\n * \n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n    \n    // Set the bit 0 in RCC_AHB1ENR to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n"
        },
        {
            "unique_id": "cbd6c768-8d71-4127-b090-cab9f76ab540",
            "timestamp": "2024-10-31T07:58:30.521016",
            "total time (seconds)": 6.32563328742981,
            "compilation-success": true,
            "Similarity with Previous": 100.0,
            "Similarity with Original": 50.67043048694425,
            "Removed Element": "hardware_abstraction_layer_function_gpio_toggle_pin",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * @brief Configures the mode of a specific GPIO pin on the STM32F407 board.\n * \n * This function sets a GPIO pin as either input or output by modifying the\n * GPIO mode register (MODER). It uses direct register manipulation to ensure\n * atomic operations.\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Pointer to the GPIO MODER register\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base);\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Each pin has 2 bits in the MODER register\n    uint32_t moder_position = pin_position * 2;\n    // Clear the 2 bits corresponding to the pin\n    *GPIO_MODER &= ~(0x3 << moder_position);\n    // Set the mode (0 for input, 1 for output)\n    *GPIO_MODER |= (mode << moder_position);\n}\n/**\n * This function reads the state of a specified GPIO pin by accessing the Input Data Register (IDR)\n * of a given GPIO port. It determines the pin position using a loop to find the first set bit in the pin mask.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to be read (e.g., 1 << 5 for pin 5).\n * @return int Returns 1 if the pin is set (high), 0 if the pin is reset (low).\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Input Data Register (IDR)\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Read the pin state by checking the corresponding bit in the IDR\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n/**\n * This function directly accesses the Output Data Register (ODR) of a given GPIO port\n * to set or reset a specific pin. It uses bitwise operations to ensure atomic and reliable\n * manipulation of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (1 to set the pin, 0 to reset the pin).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, int value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Use bitwise operations to set or reset the pin\n    if (value) {\n        // Set the pin by writing 1 to the corresponding bit in the ODR\n        *GPIO_ODR |= (1 << pin_position);\n    } else {\n        // Reset the pin by writing 0 to the corresponding bit in the ODR\n        *GPIO_ODR &= ~(1 << pin_position);\n    }\n}\n/**\n * @brief Enables the clock for GPIOA.\n * \n * This function enables the clock for the GPIOA peripheral by setting the appropriate\n * bit in the RCC AHB1 peripheral clock enable register (RCC_AHB1ENR). This is necessary\n * before any GPIOA operations can be performed.\n * \n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n    // Set the bit 0 in RCC_AHB1ENR to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function toggles the state of a GPIO pin by directly manipulating the\n * Output Data Register (ODR) of the specified GPIO port. It uses bitwise XOR\n * to flip the state of the pin, ensuring atomic and reliable operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to be toggled (e.g., 1 << 5 for pin 5).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the GPIO Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    \n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    \n    // Toggle the pin by using XOR operation on the corresponding bit in the ODR\n    *GPIO_ODR ^= (1 << pin_position);\n}\n\n"
        },
        {
            "unique_id": "5a7bf958-5f62-4117-88d9-c72c8f3555cb",
            "timestamp": "2024-10-31T07:59:23.122403",
            "total time (seconds)": 28.942768096923828,
            "compilation-success": true,
            "Similarity with Previous": 100.0,
            "Similarity with Original": 51.13636363636363,
            "Removed Element": "set_input_output_mode",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * This function reads the state of a specified GPIO pin by accessing the Input Data Register (IDR)\n * of a given GPIO port. It determines the pin position using a loop to find the first set bit in the pin mask.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to be read (e.g., 1 << 5 for pin 5).\n * @return int Returns 1 if the pin is set (high), 0 if the pin is reset (low).\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Input Data Register (IDR)\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Read the pin state by checking the corresponding bit in the IDR\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n/**\n * This function directly accesses the Output Data Register (ODR) of a given GPIO port\n * to set or reset a specific pin. It uses bitwise operations to ensure atomic and reliable\n * manipulation of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (1 to set the pin, 0 to reset the pin).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, int value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Use bitwise operations to set or reset the pin\n    if (value) {\n        // Set the pin by writing 1 to the corresponding bit in the ODR\n        *GPIO_ODR |= (1 << pin_position);\n    } else {\n        // Reset the pin by writing 0 to the corresponding bit in the ODR\n        *GPIO_ODR &= ~(1 << pin_position);\n    }\n}\n/**\n * @brief Enables the clock for GPIOA.\n * \n * This function enables the clock for the GPIOA peripheral by setting the appropriate\n * bit in the RCC AHB1 peripheral clock enable register (RCC_AHB1ENR). This is necessary\n * before any GPIOA operations can be performed.\n * \n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n    // Set the bit 0 in RCC_AHB1ENR to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function toggles the state of a GPIO pin by directly manipulating the\n * Output Data Register (ODR) of the specified GPIO port. It uses bitwise XOR\n * to flip the state of the pin, ensuring atomic and reliable operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to be toggled (e.g., 1 << 5 for pin 5).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the GPIO Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Toggle the pin by using XOR operation on the corresponding bit in the ODR\n    *GPIO_ODR ^= (1 << pin_position);\n}\n\n/**\n * @brief Configures the mode of a specific GPIO pin on the STM32F407 board.\n * \n * This function sets a GPIO pin as either input or output by modifying the\n * GPIO mode register (MODER). It uses direct register manipulation to ensure\n * atomic operations.\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Pointer to the GPIO MODER register\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base);\n\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Each pin has 2 bits in the MODER register\n    uint32_t moder_position = pin_position * 2;\n\n    // Clear the 2 bits corresponding to the pin\n    *GPIO_MODER &= ~(0x3 << moder_position);\n\n    // Set the mode (0 for input, 1 for output)\n    *GPIO_MODER |= (mode << moder_position);\n}\n\n"
        },
        {
            "unique_id": "b25b6bb5-6ac4-4571-a133-a608d4bf39c1",
            "timestamp": "2024-10-31T07:59:49.787846",
            "total time (seconds)": 7.383918046951294,
            "compilation-success": true,
            "Similarity with Previous": 90.23696682464455,
            "Similarity with Original": 50.71022727272727,
            "Removed Element": "hardware_abstraction_layer_function_gpio_toggle_pin",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * This function reads the state of a specified GPIO pin by accessing the Input Data Register (IDR)\n * of a given GPIO port. It determines the pin position using a loop to find the first set bit in the pin mask.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to be read (e.g., 1 << 5 for pin 5).\n * @return int Returns 1 if the pin is set (high), 0 if the pin is reset (low).\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Input Data Register (IDR)\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Read the pin state by checking the corresponding bit in the IDR\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n/**\n * This function directly accesses the Output Data Register (ODR) of a given GPIO port\n * to set or reset a specific pin. It uses bitwise operations to ensure atomic and reliable\n * manipulation of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (1 to set the pin, 0 to reset the pin).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, int value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Use bitwise operations to set or reset the pin\n    if (value) {\n        // Set the pin by writing 1 to the corresponding bit in the ODR\n        *GPIO_ODR |= (1 << pin_position);\n    } else {\n        // Reset the pin by writing 0 to the corresponding bit in the ODR\n        *GPIO_ODR &= ~(1 << pin_position);\n    }\n}\n/**\n * @brief Enables the clock for GPIOA.\n * \n * This function enables the clock for the GPIOA peripheral by setting the appropriate\n * bit in the RCC AHB1 peripheral clock enable register (RCC_AHB1ENR). This is necessary\n * before any GPIOA operations can be performed.\n * \n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n    // Set the bit 0 in RCC_AHB1ENR to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n/**\n * @brief Configures the mode of a specific GPIO pin on the STM32F407 board.\n * \n * This function sets a GPIO pin as either input or output by modifying the\n * GPIO mode register (MODER). It uses direct register manipulation to ensure\n * atomic operations.\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Pointer to the GPIO MODER register\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base);\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Each pin has 2 bits in the MODER register\n    uint32_t moder_position = pin_position * 2;\n    // Clear the 2 bits corresponding to the pin\n    *GPIO_MODER &= ~(0x3 << moder_position);\n    // Set the mode (0 for input, 1 for output)\n    *GPIO_MODER |= (mode << moder_position);\n}\n\n/**\n * @brief Toggles the state of a GPIO pin.\n * \n * This function toggles the state of a specified GPIO pin by directly manipulating\n * the Output Data Register (ODR) of the GPIO port. It calculates the pin position\n * using a loop to ensure the correct bit is toggled.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    \n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    \n    // Toggle the pin by using XOR operation on the corresponding bit in the ODR\n    *GPIO_ODR ^= (1 << pin_position);\n}\n\n"
        },
        {
            "unique_id": "8e800600-995f-4e2a-ac69-0d2e4d090403",
            "timestamp": "2024-10-31T08:00:37.650558",
            "total time (seconds)": 28.814541578292847,
            "compilation-success": true,
            "Similarity with Previous": 91.56159068865179,
            "Similarity with Original": 50.35360678925035,
            "Removed Element": "hardware_abstraction_layer_function_gpio_write_pin",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * This function reads the state of a specified GPIO pin by accessing the Input Data Register (IDR)\n * of a given GPIO port. It determines the pin position using a loop to find the first set bit in the pin mask.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to be read (e.g., 1 << 5 for pin 5).\n * @return int Returns 1 if the pin is set (high), 0 if the pin is reset (low).\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Input Data Register (IDR)\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Read the pin state by checking the corresponding bit in the IDR\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n/**\n * @brief Enables the clock for GPIOA.\n * \n * This function enables the clock for the GPIOA peripheral by setting the appropriate\n * bit in the RCC AHB1 peripheral clock enable register (RCC_AHB1ENR). This is necessary\n * before any GPIOA operations can be performed.\n * \n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n    // Set the bit 0 in RCC_AHB1ENR to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n/**\n * @brief Configures the mode of a specific GPIO pin on the STM32F407 board.\n * \n * This function sets a GPIO pin as either input or output by modifying the\n * GPIO mode register (MODER). It uses direct register manipulation to ensure\n * atomic operations.\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Pointer to the GPIO MODER register\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base);\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Each pin has 2 bits in the MODER register\n    uint32_t moder_position = pin_position * 2;\n    // Clear the 2 bits corresponding to the pin\n    *GPIO_MODER &= ~(0x3 << moder_position);\n    // Set the mode (0 for input, 1 for output)\n    *GPIO_MODER |= (mode << moder_position);\n}\n/**\n * @brief Toggles the state of a GPIO pin.\n * \n * This function toggles the state of a specified GPIO pin by directly manipulating\n * the Output Data Register (ODR) of the GPIO port. It calculates the pin position\n * using a loop to ensure the correct bit is toggled.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Toggle the pin by using XOR operation on the corresponding bit in the ODR\n    *GPIO_ODR ^= (1 << pin_position);\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function sets or resets a specific GPIO pin on the STM32F407 board by directly\n * manipulating the Output Data Register (ODR) of the GPIO port. It uses bitwise operations\n * to ensure atomic and reliable pin state changes.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (1 to set the pin, 0 to reset the pin).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, int value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    \n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    \n    // Use bitwise operations to set or reset the pin\n    if (value) {\n        // Set the pin by writing 1 to the corresponding bit in the ODR\n        *GPIO_ODR |= (1 << pin_position);\n    } else {\n        // Reset the pin by writing 0 to the corresponding bit in the ODR\n        *GPIO_ODR &= ~(1 << pin_position);\n    }\n}\n\n"
        },
        {
            "unique_id": "70eceeaa-f865-4f6e-ab6a-995ca2aa813c",
            "timestamp": "2024-10-31T08:01:05.918513",
            "total time (seconds)": 9.809307098388672,
            "compilation-success": true,
            "Similarity with Previous": 100.0,
            "Similarity with Original": 50.35360678925035,
            "Removed Element": "hardware_abstraction_layer_function_gpio_toggle_pin",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * This function reads the state of a specified GPIO pin by accessing the Input Data Register (IDR)\n * of a given GPIO port. It determines the pin position using a loop to find the first set bit in the pin mask.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to be read (e.g., 1 << 5 for pin 5).\n * @return int Returns 1 if the pin is set (high), 0 if the pin is reset (low).\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Input Data Register (IDR)\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Read the pin state by checking the corresponding bit in the IDR\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n/**\n * @brief Enables the clock for GPIOA.\n * \n * This function enables the clock for the GPIOA peripheral by setting the appropriate\n * bit in the RCC AHB1 peripheral clock enable register (RCC_AHB1ENR). This is necessary\n * before any GPIOA operations can be performed.\n * \n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n    // Set the bit 0 in RCC_AHB1ENR to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n/**\n * @brief Configures the mode of a specific GPIO pin on the STM32F407 board.\n * \n * This function sets a GPIO pin as either input or output by modifying the\n * GPIO mode register (MODER). It uses direct register manipulation to ensure\n * atomic operations.\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Pointer to the GPIO MODER register\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base);\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Each pin has 2 bits in the MODER register\n    uint32_t moder_position = pin_position * 2;\n    // Clear the 2 bits corresponding to the pin\n    *GPIO_MODER &= ~(0x3 << moder_position);\n    // Set the mode (0 for input, 1 for output)\n    *GPIO_MODER |= (mode << moder_position);\n}\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function sets or resets a specific GPIO pin on the STM32F407 board by directly\n * manipulating the Output Data Register (ODR) of the GPIO port. It uses bitwise operations\n * to ensure atomic and reliable pin state changes.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (1 to set the pin, 0 to reset the pin).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, int value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Use bitwise operations to set or reset the pin\n    if (value) {\n        // Set the pin by writing 1 to the corresponding bit in the ODR\n        *GPIO_ODR |= (1 << pin_position);\n    } else {\n        // Reset the pin by writing 0 to the corresponding bit in the ODR\n        *GPIO_ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Toggles the state of a GPIO pin.\n * \n * This function toggles the state of a specified GPIO pin by directly manipulating\n * the Output Data Register (ODR) of the GPIO port. It calculates the pin position\n * using a loop to ensure the correct bit is toggled.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    \n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    \n    // Toggle the pin by using XOR operation on the corresponding bit in the ODR\n    *GPIO_ODR ^= (1 << pin_position);\n}\n\n"
        },
        {
            "unique_id": "3b7b4608-d806-4d63-8083-4cae2f447da7",
            "timestamp": "2024-10-31T08:01:34.377039",
            "total time (seconds)": 11.517862319946289,
            "compilation-success": true,
            "Similarity with Previous": 85.53149606299213,
            "Similarity with Original": 50.77605321507761,
            "Removed Element": "hardware_abstraction_layer_function_gpio_write_pin",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * This function reads the state of a specified GPIO pin by accessing the Input Data Register (IDR)\n * of a given GPIO port. It determines the pin position using a loop to find the first set bit in the pin mask.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to be read (e.g., 1 << 5 for pin 5).\n * @return int Returns 1 if the pin is set (high), 0 if the pin is reset (low).\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Input Data Register (IDR)\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Read the pin state by checking the corresponding bit in the IDR\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n/**\n * @brief Enables the clock for GPIOA.\n * \n * This function enables the clock for the GPIOA peripheral by setting the appropriate\n * bit in the RCC AHB1 peripheral clock enable register (RCC_AHB1ENR). This is necessary\n * before any GPIOA operations can be performed.\n * \n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n    // Set the bit 0 in RCC_AHB1ENR to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n/**\n * @brief Configures the mode of a specific GPIO pin on the STM32F407 board.\n * \n * This function sets a GPIO pin as either input or output by modifying the\n * GPIO mode register (MODER). It uses direct register manipulation to ensure\n * atomic operations.\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Pointer to the GPIO MODER register\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base);\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Each pin has 2 bits in the MODER register\n    uint32_t moder_position = pin_position * 2;\n    // Clear the 2 bits corresponding to the pin\n    *GPIO_MODER &= ~(0x3 << moder_position);\n    // Set the mode (0 for input, 1 for output)\n    *GPIO_MODER |= (mode << moder_position);\n}\n/**\n * @brief Toggles the state of a GPIO pin.\n * \n * This function toggles the state of a specified GPIO pin by directly manipulating\n * the Output Data Register (ODR) of the GPIO port. It calculates the pin position\n * using a loop to ensure the correct bit is toggled.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Toggle the pin by using XOR operation on the corresponding bit in the ODR\n    *GPIO_ODR ^= (1 << pin_position);\n}\n\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, int value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin\n    if (value) {\n        // Set the pin by using OR operation on the corresponding bit in the ODR\n        *GPIO_ODR |= (1 << pin_position);\n    } else {\n        // Reset the pin by using AND operation with the negated bit in the ODR\n        *GPIO_ODR &= ~(1 << pin_position);\n    }\n}\n\n"
        },
        {
            "unique_id": "da62e2ea-329d-4d9c-8f3c-a2506baf3c65",
            "timestamp": "2024-10-31T08:01:58.051112",
            "total time (seconds)": 5.6664040088653564,
            "compilation-success": true,
            "Similarity with Previous": 87.80748663101605,
            "Similarity with Original": 50.0,
            "Removed Element": "hardware_abstraction_layer_function_gpio_read_pin",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * @brief Enables the clock for GPIOA.\n * \n * This function enables the clock for the GPIOA peripheral by setting the appropriate\n * bit in the RCC AHB1 peripheral clock enable register (RCC_AHB1ENR). This is necessary\n * before any GPIOA operations can be performed.\n * \n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n    // Set the bit 0 in RCC_AHB1ENR to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n/**\n * @brief Configures the mode of a specific GPIO pin on the STM32F407 board.\n * \n * This function sets a GPIO pin as either input or output by modifying the\n * GPIO mode register (MODER). It uses direct register manipulation to ensure\n * atomic operations.\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Pointer to the GPIO MODER register\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base);\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Each pin has 2 bits in the MODER register\n    uint32_t moder_position = pin_position * 2;\n    // Clear the 2 bits corresponding to the pin\n    *GPIO_MODER &= ~(0x3 << moder_position);\n    // Set the mode (0 for input, 1 for output)\n    *GPIO_MODER |= (mode << moder_position);\n}\n/**\n * @brief Toggles the state of a GPIO pin.\n * \n * This function toggles the state of a specified GPIO pin by directly manipulating\n * the Output Data Register (ODR) of the GPIO port. It calculates the pin position\n * using a loop to ensure the correct bit is toggled.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Toggle the pin by using XOR operation on the corresponding bit in the ODR\n    *GPIO_ODR ^= (1 << pin_position);\n}\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, int value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Write the value to the pin\n    if (value) {\n        // Set the pin by using OR operation on the corresponding bit in the ODR\n        *GPIO_ODR |= (1 << pin_position);\n    } else {\n        // Reset the pin by using AND operation with the negated bit in the ODR\n        *GPIO_ODR &= ~(1 << pin_position);\n    }\n}\n\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Input Data Register (IDR)\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the state of the pin by checking the corresponding bit in the IDR\n    // Return 1 if the pin is set (high), 0 if the pin is reset (low)\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n"
        },
        {
            "unique_id": "6cf199ae-e5ea-4d2f-a33f-363bf8fc9524",
            "timestamp": "2024-10-31T08:02:22.232224",
            "total time (seconds)": 6.127903938293457,
            "compilation-success": true,
            "Similarity with Previous": 97.41480611045829,
            "Similarity with Original": 49.65622612681436,
            "Removed Element": "set_input_output_mode",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * @brief Enables the clock for GPIOA.\n * \n * This function enables the clock for the GPIOA peripheral by setting the appropriate\n * bit in the RCC AHB1 peripheral clock enable register (RCC_AHB1ENR). This is necessary\n * before any GPIOA operations can be performed.\n * \n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n    // Set the bit 0 in RCC_AHB1ENR to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n/**\n * @brief Toggles the state of a GPIO pin.\n * \n * This function toggles the state of a specified GPIO pin by directly manipulating\n * the Output Data Register (ODR) of the GPIO port. It calculates the pin position\n * using a loop to ensure the correct bit is toggled.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Toggle the pin by using XOR operation on the corresponding bit in the ODR\n    *GPIO_ODR ^= (1 << pin_position);\n}\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, int value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Write the value to the pin\n    if (value) {\n        // Set the pin by using OR operation on the corresponding bit in the ODR\n        *GPIO_ODR |= (1 << pin_position);\n    } else {\n        // Reset the pin by using AND operation with the negated bit in the ODR\n        *GPIO_ODR &= ~(1 << pin_position);\n    }\n}\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Input Data Register (IDR)\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Read the state of the pin by checking the corresponding bit in the IDR\n    // Return 1 if the pin is set (high), 0 if the pin is reset (low)\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Sets a GPIO pin as either input or output.\n * \n * This function sets a GPIO pin as either input or output by modifying the\n * GPIO mode register (MODER). It uses direct register manipulation to ensure\n * atomic operations.\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Pointer to the GPIO MODER register\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base);\n    \n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    \n    // Each pin has 2 bits in the MODER register\n    uint32_t moder_position = pin_position * 2;\n    \n    // Clear the 2 bits corresponding to the pin\n    *GPIO_MODER &= ~(0x3 << moder_position);\n    \n    // Set the mode (0 for input, 1 for output)\n    *GPIO_MODER |= (mode << moder_position);\n}\n\n"
        },
        {
            "unique_id": "ed343512-6465-400e-9059-7560c2be2f7c",
            "timestamp": "2024-10-31T08:02:51.129188",
            "total time (seconds)": 7.2194719314575195,
            "compilation-success": true,
            "Similarity with Previous": 100.0,
            "Similarity with Original": 50.0,
            "Removed Element": "set_input_output_mode",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * @brief Enables the clock for GPIOA.\n * \n * This function enables the clock for the GPIOA peripheral by setting the appropriate\n * bit in the RCC AHB1 peripheral clock enable register (RCC_AHB1ENR). This is necessary\n * before any GPIOA operations can be performed.\n * \n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n    // Set the bit 0 in RCC_AHB1ENR to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n/**\n * @brief Toggles the state of a GPIO pin.\n * \n * This function toggles the state of a specified GPIO pin by directly manipulating\n * the Output Data Register (ODR) of the GPIO port. It calculates the pin position\n * using a loop to ensure the correct bit is toggled.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Toggle the pin by using XOR operation on the corresponding bit in the ODR\n    *GPIO_ODR ^= (1 << pin_position);\n}\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, int value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Write the value to the pin\n    if (value) {\n        // Set the pin by using OR operation on the corresponding bit in the ODR\n        *GPIO_ODR |= (1 << pin_position);\n    } else {\n        // Reset the pin by using AND operation with the negated bit in the ODR\n        *GPIO_ODR &= ~(1 << pin_position);\n    }\n}\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Input Data Register (IDR)\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Read the state of the pin by checking the corresponding bit in the IDR\n    // Return 1 if the pin is set (high), 0 if the pin is reset (low)\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Sets a GPIO pin as either input or output.\n * \n * This function sets a GPIO pin as either input or output by modifying the\n * GPIO mode register (MODER). It uses direct register manipulation to ensure\n * atomic operations.\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Pointer to the GPIO MODER register\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base);\n\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Each pin has 2 bits in the MODER register\n    uint32_t moder_position = pin_position * 2;\n\n    // Clear the 2 bits corresponding to the pin\n    *GPIO_MODER &= ~(0x3 << moder_position);\n\n    // Set the mode (0 for input, 1 for output)\n    *GPIO_MODER |= (mode << moder_position);\n}\n\n"
        },
        {
            "unique_id": "f393fbe4-51e0-4b15-af89-812494414446",
            "timestamp": "2024-10-31T08:03:17.869578",
            "total time (seconds)": 6.743730306625366,
            "compilation-success": true,
            "Similarity with Previous": 91.83222958057395,
            "Similarity with Original": 50.22288261515602,
            "Removed Element": "hardware_abstraction_layer_function_gpio_read_pin",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * @brief Enables the clock for GPIOA.\n * \n * This function enables the clock for the GPIOA peripheral by setting the appropriate\n * bit in the RCC AHB1 peripheral clock enable register (RCC_AHB1ENR). This is necessary\n * before any GPIOA operations can be performed.\n * \n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n    // Set the bit 0 in RCC_AHB1ENR to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n/**\n * @brief Toggles the state of a GPIO pin.\n * \n * This function toggles the state of a specified GPIO pin by directly manipulating\n * the Output Data Register (ODR) of the GPIO port. It calculates the pin position\n * using a loop to ensure the correct bit is toggled.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Toggle the pin by using XOR operation on the corresponding bit in the ODR\n    *GPIO_ODR ^= (1 << pin_position);\n}\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, int value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Write the value to the pin\n    if (value) {\n        // Set the pin by using OR operation on the corresponding bit in the ODR\n        *GPIO_ODR |= (1 << pin_position);\n    } else {\n        // Reset the pin by using AND operation with the negated bit in the ODR\n        *GPIO_ODR &= ~(1 << pin_position);\n    }\n}\n/**\n * @brief Sets a GPIO pin as either input or output.\n * \n * This function sets a GPIO pin as either input or output by modifying the\n * GPIO mode register (MODER). It uses direct register manipulation to ensure\n * atomic operations.\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Pointer to the GPIO MODER register\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base);\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Each pin has 2 bits in the MODER register\n    uint32_t moder_position = pin_position * 2;\n    // Clear the 2 bits corresponding to the pin\n    *GPIO_MODER &= ~(0x3 << moder_position);\n    // Set the mode (0 for input, 1 for output)\n    *GPIO_MODER |= (mode << moder_position);\n}\n\n/**\n * This function reads the state of a specified GPIO pin by directly accessing\n * the Input Data Register (IDR) of the GPIO port. It calculates the pin position\n * using a loop to ensure the correct bit is read.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to read (e.g., 1 << 5 for pin 5).\n * @return The state of the pin: 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Input Data Register (IDR)\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Read the state of the pin by checking the corresponding bit in the IDR\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n"
        },
        {
            "unique_id": "859ca95a-67e5-49e4-8d5c-ed7c81ccbb5d",
            "timestamp": "2024-10-31T08:03:45.366058",
            "total time (seconds)": 9.701470375061035,
            "compilation-success": true,
            "Similarity with Previous": 100.0,
            "Similarity with Original": 50.22288261515602,
            "Removed Element": "set_input_output_mode",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * @brief Enables the clock for GPIOA.\n * \n * This function enables the clock for the GPIOA peripheral by setting the appropriate\n * bit in the RCC AHB1 peripheral clock enable register (RCC_AHB1ENR). This is necessary\n * before any GPIOA operations can be performed.\n * \n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n    // Set the bit 0 in RCC_AHB1ENR to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n/**\n * @brief Toggles the state of a GPIO pin.\n * \n * This function toggles the state of a specified GPIO pin by directly manipulating\n * the Output Data Register (ODR) of the GPIO port. It calculates the pin position\n * using a loop to ensure the correct bit is toggled.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Toggle the pin by using XOR operation on the corresponding bit in the ODR\n    *GPIO_ODR ^= (1 << pin_position);\n}\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, int value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Write the value to the pin\n    if (value) {\n        // Set the pin by using OR operation on the corresponding bit in the ODR\n        *GPIO_ODR |= (1 << pin_position);\n    } else {\n        // Reset the pin by using AND operation with the negated bit in the ODR\n        *GPIO_ODR &= ~(1 << pin_position);\n    }\n}\n/**\n * This function reads the state of a specified GPIO pin by directly accessing\n * the Input Data Register (IDR) of the GPIO port. It calculates the pin position\n * using a loop to ensure the correct bit is read.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to read (e.g., 1 << 5 for pin 5).\n * @return The state of the pin: 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Input Data Register (IDR)\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Read the state of the pin by checking the corresponding bit in the IDR\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Sets a GPIO pin as either input or output.\n * \n * This function sets a GPIO pin as either input or output by modifying the\n * GPIO mode register (MODER). It uses direct register manipulation to ensure\n * atomic operations.\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Pointer to the GPIO MODER register\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base);\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Each pin has 2 bits in the MODER register\n    uint32_t moder_position = pin_position * 2;\n    // Clear the 2 bits corresponding to the pin\n    *GPIO_MODER &= ~(0x3 << moder_position);\n    // Set the mode (0 for input, 1 for output)\n    *GPIO_MODER |= (mode << moder_position);\n}\n\n"
        },
        {
            "unique_id": "46cf4c9c-090f-437c-819d-fc6e4ae8c0ff",
            "timestamp": "2024-10-31T08:04:13.080985",
            "total time (seconds)": 8.373550653457642,
            "compilation-success": true,
            "Similarity with Previous": 93.88830347734456,
            "Similarity with Original": 49.68017057569296,
            "Removed Element": "hardware_abstraction_layer_function_gpio_write_pin",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * @brief Enables the clock for GPIOA.\n * \n * This function enables the clock for the GPIOA peripheral by setting the appropriate\n * bit in the RCC AHB1 peripheral clock enable register (RCC_AHB1ENR). This is necessary\n * before any GPIOA operations can be performed.\n * \n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n    // Set the bit 0 in RCC_AHB1ENR to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n/**\n * @brief Toggles the state of a GPIO pin.\n * \n * This function toggles the state of a specified GPIO pin by directly manipulating\n * the Output Data Register (ODR) of the GPIO port. It calculates the pin position\n * using a loop to ensure the correct bit is toggled.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Toggle the pin by using XOR operation on the corresponding bit in the ODR\n    *GPIO_ODR ^= (1 << pin_position);\n}\n/**\n * This function reads the state of a specified GPIO pin by directly accessing\n * the Input Data Register (IDR) of the GPIO port. It calculates the pin position\n * using a loop to ensure the correct bit is read.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to read (e.g., 1 << 5 for pin 5).\n * @return The state of the pin: 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Input Data Register (IDR)\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Read the state of the pin by checking the corresponding bit in the IDR\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n/**\n * @brief Sets a GPIO pin as either input or output.\n * \n * This function sets a GPIO pin as either input or output by modifying the\n * GPIO mode register (MODER). It uses direct register manipulation to ensure\n * atomic operations.\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Pointer to the GPIO MODER register\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base);\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Each pin has 2 bits in the MODER register\n    uint32_t moder_position = pin_position * 2;\n    // Clear the 2 bits corresponding to the pin\n    *GPIO_MODER &= ~(0x3 << moder_position);\n    // Set the mode (0 for input, 1 for output)\n    *GPIO_MODER |= (mode << moder_position);\n}\n\n/**\n * This function writes a specified value to a GPIO pin by directly accessing\n * the Output Data Register (ODR) of the GPIO port. It calculates the pin position\n * using a loop to ensure the correct bit is set or reset.\n *\n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to write to (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, non-zero for high).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, int value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Write the value to the pin\n    if (value) {\n        // Set the pin by using OR operation on the corresponding bit in the ODR\n        *GPIO_ODR |= (1 << pin_position);\n    } else {\n        // Reset the pin by using AND operation with the negated bit in the ODR\n        *GPIO_ODR &= ~(1 << pin_position);\n    }\n}\n\n"
        },
        {
            "unique_id": "efe1cf00-0280-42e3-83bd-1d899dbada9e",
            "timestamp": "2024-10-31T08:04:37.612826",
            "total time (seconds)": 6.314953088760376,
            "compilation-success": true,
            "Similarity with Previous": 96.60144181256437,
            "Similarity with Original": 49.21875,
            "Removed Element": "set_input_output_mode",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * @brief Enables the clock for GPIOA.\n * \n * This function enables the clock for the GPIOA peripheral by setting the appropriate\n * bit in the RCC AHB1 peripheral clock enable register (RCC_AHB1ENR). This is necessary\n * before any GPIOA operations can be performed.\n * \n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n    // Set the bit 0 in RCC_AHB1ENR to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n/**\n * @brief Toggles the state of a GPIO pin.\n * \n * This function toggles the state of a specified GPIO pin by directly manipulating\n * the Output Data Register (ODR) of the GPIO port. It calculates the pin position\n * using a loop to ensure the correct bit is toggled.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Toggle the pin by using XOR operation on the corresponding bit in the ODR\n    *GPIO_ODR ^= (1 << pin_position);\n}\n/**\n * This function reads the state of a specified GPIO pin by directly accessing\n * the Input Data Register (IDR) of the GPIO port. It calculates the pin position\n * using a loop to ensure the correct bit is read.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to read (e.g., 1 << 5 for pin 5).\n * @return The state of the pin: 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Input Data Register (IDR)\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Read the state of the pin by checking the corresponding bit in the IDR\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n/**\n * This function writes a specified value to a GPIO pin by directly accessing\n * the Output Data Register (ODR) of the GPIO port. It calculates the pin position\n * using a loop to ensure the correct bit is set or reset.\n *\n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to write to (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, non-zero for high).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, int value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Write the value to the pin\n    if (value) {\n        // Set the pin by using OR operation on the corresponding bit in the ODR\n        *GPIO_ODR |= (1 << pin_position);\n    } else {\n        // Reset the pin by using AND operation with the negated bit in the ODR\n        *GPIO_ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Sets a GPIO pin as either input or output.\n * \n * This function sets a GPIO pin as either input or output by modifying the\n * GPIO mode register (MODER). It uses direct register manipulation to ensure\n * atomic operations.\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Pointer to the GPIO MODER register\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base);\n\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Each pin has 2 bits in the MODER register\n    uint32_t moder_position = pin_position * 2;\n\n    // Clear the current mode for the pin by setting the two bits to 0\n    *GPIO_MODER &= ~(0x3 << moder_position);\n\n    // Set the new mode for the pin\n    *GPIO_MODER |= (mode << moder_position);\n}\n\n"
        },
        {
            "unique_id": "f784c414-8fdc-4dd4-8540-88c360d2da63",
            "timestamp": "2024-10-31T08:05:09.230065",
            "total time (seconds)": 8.208981990814209,
            "compilation-success": true,
            "Similarity with Previous": 98.33506763787722,
            "Similarity with Original": 48.90148830616584,
            "Removed Element": "hardware_abstraction_layer_function_gpio_toggle_pin",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * @brief Enables the clock for GPIOA.\n * \n * This function enables the clock for the GPIOA peripheral by setting the appropriate\n * bit in the RCC AHB1 peripheral clock enable register (RCC_AHB1ENR). This is necessary\n * before any GPIOA operations can be performed.\n * \n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n    // Set the bit 0 in RCC_AHB1ENR to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n/**\n * This function reads the state of a specified GPIO pin by directly accessing\n * the Input Data Register (IDR) of the GPIO port. It calculates the pin position\n * using a loop to ensure the correct bit is read.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to read (e.g., 1 << 5 for pin 5).\n * @return The state of the pin: 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Input Data Register (IDR)\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Read the state of the pin by checking the corresponding bit in the IDR\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n/**\n * This function writes a specified value to a GPIO pin by directly accessing\n * the Output Data Register (ODR) of the GPIO port. It calculates the pin position\n * using a loop to ensure the correct bit is set or reset.\n *\n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to write to (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, non-zero for high).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, int value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Write the value to the pin\n    if (value) {\n        // Set the pin by using OR operation on the corresponding bit in the ODR\n        *GPIO_ODR |= (1 << pin_position);\n    } else {\n        // Reset the pin by using AND operation with the negated bit in the ODR\n        *GPIO_ODR &= ~(1 << pin_position);\n    }\n}\n/**\n * @brief Sets a GPIO pin as either input or output.\n * \n * This function sets a GPIO pin as either input or output by modifying the\n * GPIO mode register (MODER). It uses direct register manipulation to ensure\n * atomic operations.\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Pointer to the GPIO MODER register\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base);\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Each pin has 2 bits in the MODER register\n    uint32_t moder_position = pin_position * 2;\n    // Clear the current mode for the pin by setting the two bits to 0\n    *GPIO_MODER &= ~(0x3 << moder_position);\n    // Set the new mode for the pin\n    *GPIO_MODER |= (mode << moder_position);\n}\n\n/**\n * This function toggles the state of a specified GPIO pin by directly manipulating\n * the Output Data Register (ODR) of the GPIO port. It calculates the pin position\n * using a loop to ensure the correct bit is toggled.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    \n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    \n    // Toggle the pin by using XOR operation on the corresponding bit in the ODR\n    *GPIO_ODR ^= (1 << pin_position);\n}\n\n"
        },
        {
            "unique_id": "eccb70e9-b8d5-458c-a940-18f5e9a03e8f",
            "timestamp": "2024-10-31T08:05:35.806780",
            "total time (seconds)": 7.539416551589966,
            "compilation-success": true,
            "Similarity with Previous": 96.09455292908531,
            "Similarity with Original": 49.677881173944165,
            "Removed Element": "hardware_abstraction_layer_function_gpio_write_pin",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * @brief Enables the clock for GPIOA.\n * \n * This function enables the clock for the GPIOA peripheral by setting the appropriate\n * bit in the RCC AHB1 peripheral clock enable register (RCC_AHB1ENR). This is necessary\n * before any GPIOA operations can be performed.\n * \n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n    // Set the bit 0 in RCC_AHB1ENR to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n/**\n * This function reads the state of a specified GPIO pin by directly accessing\n * the Input Data Register (IDR) of the GPIO port. It calculates the pin position\n * using a loop to ensure the correct bit is read.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to read (e.g., 1 << 5 for pin 5).\n * @return The state of the pin: 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Input Data Register (IDR)\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Read the state of the pin by checking the corresponding bit in the IDR\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n/**\n * @brief Sets a GPIO pin as either input or output.\n * \n * This function sets a GPIO pin as either input or output by modifying the\n * GPIO mode register (MODER). It uses direct register manipulation to ensure\n * atomic operations.\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Pointer to the GPIO MODER register\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base);\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Each pin has 2 bits in the MODER register\n    uint32_t moder_position = pin_position * 2;\n    // Clear the current mode for the pin by setting the two bits to 0\n    *GPIO_MODER &= ~(0x3 << moder_position);\n    // Set the new mode for the pin\n    *GPIO_MODER |= (mode << moder_position);\n}\n/**\n * This function toggles the state of a specified GPIO pin by directly manipulating\n * the Output Data Register (ODR) of the GPIO port. It calculates the pin position\n * using a loop to ensure the correct bit is toggled.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Toggle the pin by using XOR operation on the corresponding bit in the ODR\n    *GPIO_ODR ^= (1 << pin_position);\n}\n\n/**\n * This function writes a specified value to a GPIO pin by directly accessing\n * the Output Data Register (ODR) of the GPIO port. It calculates the pin position\n * using a loop to ensure the correct bit is set or reset.\n *\n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to write to (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, non-zero for high).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, int value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    \n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    \n    // Write the value to the pin\n    if (value) {\n        // Set the pin high by setting the corresponding bit in the ODR\n        *GPIO_ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low by clearing the corresponding bit in the ODR\n        *GPIO_ODR &= ~(1 << pin_position);\n    }\n}\n\n"
        },
        {
            "unique_id": "c6b0eb58-e3d1-4050-873f-eb3539d5cbfb",
            "timestamp": "2024-10-31T08:06:06.003543",
            "total time (seconds)": 11.251786708831787,
            "compilation-success": true,
            "Similarity with Previous": 86.6474543707973,
            "Similarity with Original": 50.361271676300575,
            "Removed Element": "hardware_abstraction_layer_function_gpio_write_pin",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * @brief Enables the clock for GPIOA.\n * \n * This function enables the clock for the GPIOA peripheral by setting the appropriate\n * bit in the RCC AHB1 peripheral clock enable register (RCC_AHB1ENR). This is necessary\n * before any GPIOA operations can be performed.\n * \n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n    // Set the bit 0 in RCC_AHB1ENR to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n/**\n * This function reads the state of a specified GPIO pin by directly accessing\n * the Input Data Register (IDR) of the GPIO port. It calculates the pin position\n * using a loop to ensure the correct bit is read.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to read (e.g., 1 << 5 for pin 5).\n * @return The state of the pin: 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Input Data Register (IDR)\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Read the state of the pin by checking the corresponding bit in the IDR\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n/**\n * @brief Sets a GPIO pin as either input or output.\n * \n * This function sets a GPIO pin as either input or output by modifying the\n * GPIO mode register (MODER). It uses direct register manipulation to ensure\n * atomic operations.\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Pointer to the GPIO MODER register\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base);\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Each pin has 2 bits in the MODER register\n    uint32_t moder_position = pin_position * 2;\n    // Clear the current mode for the pin by setting the two bits to 0\n    *GPIO_MODER &= ~(0x3 << moder_position);\n    // Set the new mode for the pin\n    *GPIO_MODER |= (mode << moder_position);\n}\n/**\n * This function toggles the state of a specified GPIO pin by directly manipulating\n * the Output Data Register (ODR) of the GPIO port. It calculates the pin position\n * using a loop to ensure the correct bit is toggled.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Toggle the pin by using XOR operation on the corresponding bit in the ODR\n    *GPIO_ODR ^= (1 << pin_position);\n}\n\n/**\n * This function writes a specified value to a GPIO pin by directly manipulating\n * the Output Data Register (ODR) of the GPIO port. It calculates the pin position\n * using a loop to ensure the correct bit is set or cleared.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to write (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin: 1 to set the pin high, 0 to set it low.\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Write the value to the pin by setting or clearing the corresponding bit in the ODR\n    if (value) {\n        *GPIO_ODR |= (1 << pin_position);  // Set the pin high\n    } else {\n        *GPIO_ODR &= ~(1 << pin_position); // Set the pin low\n    }\n}\n\n"
        },
        {
            "unique_id": "472c2e86-b97c-4008-809a-f72fe2fe1660",
            "timestamp": "2024-10-31T08:06:30.428435",
            "total time (seconds)": 6.401948928833008,
            "compilation-success": true,
            "Similarity with Previous": 98.21989528795811,
            "Similarity with Original": 50.323974082073434,
            "Removed Element": "hardware_abstraction_layer_function_gpio_toggle_pin",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * @brief Enables the clock for GPIOA.\n * \n * This function enables the clock for the GPIOA peripheral by setting the appropriate\n * bit in the RCC AHB1 peripheral clock enable register (RCC_AHB1ENR). This is necessary\n * before any GPIOA operations can be performed.\n * \n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n    // Set the bit 0 in RCC_AHB1ENR to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n/**\n * This function reads the state of a specified GPIO pin by directly accessing\n * the Input Data Register (IDR) of the GPIO port. It calculates the pin position\n * using a loop to ensure the correct bit is read.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to read (e.g., 1 << 5 for pin 5).\n * @return The state of the pin: 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Input Data Register (IDR)\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Read the state of the pin by checking the corresponding bit in the IDR\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n/**\n * @brief Sets a GPIO pin as either input or output.\n * \n * This function sets a GPIO pin as either input or output by modifying the\n * GPIO mode register (MODER). It uses direct register manipulation to ensure\n * atomic operations.\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Pointer to the GPIO MODER register\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base);\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Each pin has 2 bits in the MODER register\n    uint32_t moder_position = pin_position * 2;\n    // Clear the current mode for the pin by setting the two bits to 0\n    *GPIO_MODER &= ~(0x3 << moder_position);\n    // Set the new mode for the pin\n    *GPIO_MODER |= (mode << moder_position);\n}\n/**\n * This function writes a specified value to a GPIO pin by directly manipulating\n * the Output Data Register (ODR) of the GPIO port. It calculates the pin position\n * using a loop to ensure the correct bit is set or cleared.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to write (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin: 1 to set the pin high, 0 to set it low.\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Write the value to the pin by setting or clearing the corresponding bit in the ODR\n    if (value) {\n        *GPIO_ODR |= (1 << pin_position);  // Set the pin high\n    } else {\n        *GPIO_ODR &= ~(1 << pin_position); // Set the pin low\n    }\n}\n\n/**\n * This function toggles the state of a specified GPIO pin by directly manipulating\n * the Output Data Register (ODR) of the GPIO port. It calculates the pin position\n * using a loop to ensure the correct bit is toggled.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    \n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    \n    // Toggle the state of the pin by using XOR operation on the corresponding bit in the ODR\n    *GPIO_ODR ^= (1 << pin_position);\n}\n\n"
        },
        {
            "unique_id": "a93d448f-5f64-4f03-b618-8339161691d1",
            "timestamp": "2024-10-31T08:06:58.022589",
            "total time (seconds)": 7.751482963562012,
            "compilation-success": true,
            "Similarity with Previous": 100.0,
            "Similarity with Original": 50.396539293439076,
            "Removed Element": "hardware_abstraction_layer_function_gpio_toggle_pin",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * @brief Enables the clock for GPIOA.\n * \n * This function enables the clock for the GPIOA peripheral by setting the appropriate\n * bit in the RCC AHB1 peripheral clock enable register (RCC_AHB1ENR). This is necessary\n * before any GPIOA operations can be performed.\n * \n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n    // Set the bit 0 in RCC_AHB1ENR to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n/**\n * This function reads the state of a specified GPIO pin by directly accessing\n * the Input Data Register (IDR) of the GPIO port. It calculates the pin position\n * using a loop to ensure the correct bit is read.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to read (e.g., 1 << 5 for pin 5).\n * @return The state of the pin: 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Input Data Register (IDR)\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Read the state of the pin by checking the corresponding bit in the IDR\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n/**\n * @brief Sets a GPIO pin as either input or output.\n * \n * This function sets a GPIO pin as either input or output by modifying the\n * GPIO mode register (MODER). It uses direct register manipulation to ensure\n * atomic operations.\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Pointer to the GPIO MODER register\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base);\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Each pin has 2 bits in the MODER register\n    uint32_t moder_position = pin_position * 2;\n    // Clear the current mode for the pin by setting the two bits to 0\n    *GPIO_MODER &= ~(0x3 << moder_position);\n    // Set the new mode for the pin\n    *GPIO_MODER |= (mode << moder_position);\n}\n/**\n * This function writes a specified value to a GPIO pin by directly manipulating\n * the Output Data Register (ODR) of the GPIO port. It calculates the pin position\n * using a loop to ensure the correct bit is set or cleared.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to write (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin: 1 to set the pin high, 0 to set it low.\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Write the value to the pin by setting or clearing the corresponding bit in the ODR\n    if (value) {\n        *GPIO_ODR |= (1 << pin_position);  // Set the pin high\n    } else {\n        *GPIO_ODR &= ~(1 << pin_position); // Set the pin low\n    }\n}\n\n/**\n * This function toggles the state of a specified GPIO pin by directly manipulating\n * the Output Data Register (ODR) of the GPIO port. It calculates the pin position\n * using a loop to ensure the correct bit is toggled.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Toggle the state of the pin by using XOR operation on the corresponding bit in the ODR\n    *GPIO_ODR ^= (1 << pin_position);\n}\n\n"
        },
        {
            "unique_id": "87b2a59d-fef3-4925-9c1b-1ad047c7f467",
            "timestamp": "2024-10-31T08:07:44.270436",
            "total time (seconds)": 6.703697204589844,
            "compilation-success": true,
            "Similarity with Previous": 100.0,
            "Similarity with Original": 50.396539293439076,
            "Removed Element": "hardware_abstraction_layer_function_gpio_toggle_pin",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * @brief Enables the clock for GPIOA.\n * \n * This function enables the clock for the GPIOA peripheral by setting the appropriate\n * bit in the RCC AHB1 peripheral clock enable register (RCC_AHB1ENR). This is necessary\n * before any GPIOA operations can be performed.\n * \n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n    // Set the bit 0 in RCC_AHB1ENR to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n/**\n * This function reads the state of a specified GPIO pin by directly accessing\n * the Input Data Register (IDR) of the GPIO port. It calculates the pin position\n * using a loop to ensure the correct bit is read.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to read (e.g., 1 << 5 for pin 5).\n * @return The state of the pin: 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Input Data Register (IDR)\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Read the state of the pin by checking the corresponding bit in the IDR\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n/**\n * @brief Sets a GPIO pin as either input or output.\n * \n * This function sets a GPIO pin as either input or output by modifying the\n * GPIO mode register (MODER). It uses direct register manipulation to ensure\n * atomic operations.\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Pointer to the GPIO MODER register\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base);\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Each pin has 2 bits in the MODER register\n    uint32_t moder_position = pin_position * 2;\n    // Clear the current mode for the pin by setting the two bits to 0\n    *GPIO_MODER &= ~(0x3 << moder_position);\n    // Set the new mode for the pin\n    *GPIO_MODER |= (mode << moder_position);\n}\n/**\n * This function writes a specified value to a GPIO pin by directly manipulating\n * the Output Data Register (ODR) of the GPIO port. It calculates the pin position\n * using a loop to ensure the correct bit is set or cleared.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to write (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin: 1 to set the pin high, 0 to set it low.\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Write the value to the pin by setting or clearing the corresponding bit in the ODR\n    if (value) {\n        *GPIO_ODR |= (1 << pin_position);  // Set the pin high\n    } else {\n        *GPIO_ODR &= ~(1 << pin_position); // Set the pin low\n    }\n}\n\n/**\n * This function toggles the state of a specified GPIO pin by directly manipulating\n * the Output Data Register (ODR) of the GPIO port. It calculates the pin position\n * using a loop to ensure the correct bit is toggled.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Toggle the state of the pin by using XOR operation on the corresponding bit in the ODR\n    *GPIO_ODR ^= (1 << pin_position);\n}\n\n"
        },
        {
            "unique_id": "dde962c6-883e-43ec-8c8f-9318354a67ea",
            "timestamp": "2024-10-31T08:08:08.596033",
            "total time (seconds)": 5.223474502563477,
            "compilation-success": true,
            "Similarity with Previous": 86.98564593301435,
            "Similarity with Original": 50.32074126870991,
            "Removed Element": "ENABLE_GPIOA_CLOCK",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * This function reads the state of a specified GPIO pin by directly accessing\n * the Input Data Register (IDR) of the GPIO port. It calculates the pin position\n * using a loop to ensure the correct bit is read.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to read (e.g., 1 << 5 for pin 5).\n * @return The state of the pin: 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Input Data Register (IDR)\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Read the state of the pin by checking the corresponding bit in the IDR\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n/**\n * @brief Sets a GPIO pin as either input or output.\n * \n * This function sets a GPIO pin as either input or output by modifying the\n * GPIO mode register (MODER). It uses direct register manipulation to ensure\n * atomic operations.\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Pointer to the GPIO MODER register\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base);\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Each pin has 2 bits in the MODER register\n    uint32_t moder_position = pin_position * 2;\n    // Clear the current mode for the pin by setting the two bits to 0\n    *GPIO_MODER &= ~(0x3 << moder_position);\n    // Set the new mode for the pin\n    *GPIO_MODER |= (mode << moder_position);\n}\n/**\n * This function writes a specified value to a GPIO pin by directly manipulating\n * the Output Data Register (ODR) of the GPIO port. It calculates the pin position\n * using a loop to ensure the correct bit is set or cleared.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to write (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin: 1 to set the pin high, 0 to set it low.\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Write the value to the pin by setting or clearing the corresponding bit in the ODR\n    if (value) {\n        *GPIO_ODR |= (1 << pin_position);  // Set the pin high\n    } else {\n        *GPIO_ODR &= ~(1 << pin_position); // Set the pin low\n    }\n}\n/**\n * This function toggles the state of a specified GPIO pin by directly manipulating\n * the Output Data Register (ODR) of the GPIO port. It calculates the pin position\n * using a loop to ensure the correct bit is toggled.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Toggle the state of the pin by using XOR operation on the corresponding bit in the ODR\n    *GPIO_ODR ^= (1 << pin_position);\n}\n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC_AHB1ENR register to enable the clock for GPIOA.\n * It ensures that the clock is enabled by setting the appropriate bit in the register.\n * \n * @return 1 if the clock was successfully enabled, 0 otherwise.\n */\nint ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC and the offset for the AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(RCC_BASE + RCC_AHB1ENR_OFFSET);\n\n    // Enable the clock for GPIOA by setting the 0th bit in the RCC_AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n\n    // Return 1 if the clock is enabled, 0 otherwise\n    return ((*RCC_AHB1ENR & (1 << 0)) != 0) ? 1 : 0;\n}\n\n"
        },
        {
            "unique_id": "d855c733-ebf7-4a4e-9e07-4277003eea31",
            "timestamp": "2024-10-31T08:08:38.749689",
            "total time (seconds)": 12.335223197937012,
            "compilation-success": true,
            "Similarity with Previous": 91.71428571428571,
            "Similarity with Original": 50.92067988668555,
            "Removed Element": "hardware_abstraction_layer_function_gpio_write_pin",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * This function reads the state of a specified GPIO pin by directly accessing\n * the Input Data Register (IDR) of the GPIO port. It calculates the pin position\n * using a loop to ensure the correct bit is read.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to read (e.g., 1 << 5 for pin 5).\n * @return The state of the pin: 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Input Data Register (IDR)\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Read the state of the pin by checking the corresponding bit in the IDR\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n/**\n * @brief Sets a GPIO pin as either input or output.\n * \n * This function sets a GPIO pin as either input or output by modifying the\n * GPIO mode register (MODER). It uses direct register manipulation to ensure\n * atomic operations.\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Pointer to the GPIO MODER register\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base);\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Each pin has 2 bits in the MODER register\n    uint32_t moder_position = pin_position * 2;\n    // Clear the current mode for the pin by setting the two bits to 0\n    *GPIO_MODER &= ~(0x3 << moder_position);\n    // Set the new mode for the pin\n    *GPIO_MODER |= (mode << moder_position);\n}\n/**\n * This function toggles the state of a specified GPIO pin by directly manipulating\n * the Output Data Register (ODR) of the GPIO port. It calculates the pin position\n * using a loop to ensure the correct bit is toggled.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Toggle the state of the pin by using XOR operation on the corresponding bit in the ODR\n    *GPIO_ODR ^= (1 << pin_position);\n}\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC_AHB1ENR register to enable the clock for GPIOA.\n * It ensures that the clock is enabled by setting the appropriate bit in the register.\n * \n * @return 1 if the clock was successfully enabled, 0 otherwise.\n */\nint ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC and the offset for the AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(RCC_BASE + RCC_AHB1ENR_OFFSET);\n    // Enable the clock for GPIOA by setting the 0th bit in the RCC_AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n    // Return 1 if the clock is enabled, 0 otherwise\n    return ((*RCC_AHB1ENR & (1 << 0)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Writes a value to a specified GPIO pin on the STM32F407 board.\n * \n * This function directly manipulates the Output Data Register (ODR) of the GPIO port\n * to set or clear a specific pin. It calculates the pin position using a loop to ensure\n * the correct bit is modified.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to write to (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin: 1 to set the pin high, 0 to set it low.\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Write the value to the pin by setting or clearing the corresponding bit in the ODR\n    if (value) {\n        *GPIO_ODR |= (1 << pin_position);  // Set the pin high\n    } else {\n        *GPIO_ODR &= ~(1 << pin_position); // Set the pin low\n    }\n}\n\n"
        },
        {
            "unique_id": "8dc24348-fd3f-417a-87e9-8f64f05adcf7",
            "timestamp": "2024-10-31T08:09:05.299563",
            "total time (seconds)": 8.384400606155396,
            "compilation-success": true,
            "Similarity with Previous": 100.0,
            "Similarity with Original": 50.84865629420084,
            "Removed Element": "hardware_abstraction_layer_function_gpio_read_pin",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * @brief Sets a GPIO pin as either input or output.\n * \n * This function sets a GPIO pin as either input or output by modifying the\n * GPIO mode register (MODER). It uses direct register manipulation to ensure\n * atomic operations.\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Pointer to the GPIO MODER register\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base);\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Each pin has 2 bits in the MODER register\n    uint32_t moder_position = pin_position * 2;\n    // Clear the current mode for the pin by setting the two bits to 0\n    *GPIO_MODER &= ~(0x3 << moder_position);\n    // Set the new mode for the pin\n    *GPIO_MODER |= (mode << moder_position);\n}\n/**\n * This function toggles the state of a specified GPIO pin by directly manipulating\n * the Output Data Register (ODR) of the GPIO port. It calculates the pin position\n * using a loop to ensure the correct bit is toggled.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Toggle the state of the pin by using XOR operation on the corresponding bit in the ODR\n    *GPIO_ODR ^= (1 << pin_position);\n}\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC_AHB1ENR register to enable the clock for GPIOA.\n * It ensures that the clock is enabled by setting the appropriate bit in the register.\n * \n * @return 1 if the clock was successfully enabled, 0 otherwise.\n */\nint ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC and the offset for the AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(RCC_BASE + RCC_AHB1ENR_OFFSET);\n    // Enable the clock for GPIOA by setting the 0th bit in the RCC_AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n    // Return 1 if the clock is enabled, 0 otherwise\n    return ((*RCC_AHB1ENR & (1 << 0)) != 0) ? 1 : 0;\n}\n/**\n * @brief Writes a value to a specified GPIO pin on the STM32F407 board.\n * \n * This function directly manipulates the Output Data Register (ODR) of the GPIO port\n * to set or clear a specific pin. It calculates the pin position using a loop to ensure\n * the correct bit is modified.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to write to (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin: 1 to set the pin high, 0 to set it low.\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Write the value to the pin by setting or clearing the corresponding bit in the ODR\n    if (value) {\n        *GPIO_ODR |= (1 << pin_position);  // Set the pin high\n    } else {\n        *GPIO_ODR &= ~(1 << pin_position); // Set the pin low\n    }\n}\n\n/**\n * This function reads the state of a specified GPIO pin by directly accessing\n * the Input Data Register (IDR) of the GPIO port. It calculates the pin position\n * using a loop to ensure the correct bit is read.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to read (e.g., 1 << 5 for pin 5).\n * @return The state of the pin: 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Input Data Register (IDR)\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    \n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    \n    // Read the state of the pin by checking the corresponding bit in the IDR\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n"
        },
        {
            "unique_id": "222e8185-ccf4-4010-8305-3bf609e25b17",
            "timestamp": "2024-10-31T08:09:29.741815",
            "total time (seconds)": 5.917735576629639,
            "compilation-success": true,
            "Similarity with Previous": 93.07400379506642,
            "Similarity with Original": 51.39584824624195,
            "Removed Element": "hardware_abstraction_layer_function_gpio_toggle_pin",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * @brief Sets a GPIO pin as either input or output.\n * \n * This function sets a GPIO pin as either input or output by modifying the\n * GPIO mode register (MODER). It uses direct register manipulation to ensure\n * atomic operations.\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Pointer to the GPIO MODER register\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base);\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Each pin has 2 bits in the MODER register\n    uint32_t moder_position = pin_position * 2;\n    // Clear the current mode for the pin by setting the two bits to 0\n    *GPIO_MODER &= ~(0x3 << moder_position);\n    // Set the new mode for the pin\n    *GPIO_MODER |= (mode << moder_position);\n}\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC_AHB1ENR register to enable the clock for GPIOA.\n * It ensures that the clock is enabled by setting the appropriate bit in the register.\n * \n * @return 1 if the clock was successfully enabled, 0 otherwise.\n */\nint ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC and the offset for the AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(RCC_BASE + RCC_AHB1ENR_OFFSET);\n    // Enable the clock for GPIOA by setting the 0th bit in the RCC_AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n    // Return 1 if the clock is enabled, 0 otherwise\n    return ((*RCC_AHB1ENR & (1 << 0)) != 0) ? 1 : 0;\n}\n/**\n * @brief Writes a value to a specified GPIO pin on the STM32F407 board.\n * \n * This function directly manipulates the Output Data Register (ODR) of the GPIO port\n * to set or clear a specific pin. It calculates the pin position using a loop to ensure\n * the correct bit is modified.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to write to (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin: 1 to set the pin high, 0 to set it low.\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Write the value to the pin by setting or clearing the corresponding bit in the ODR\n    if (value) {\n        *GPIO_ODR |= (1 << pin_position);  // Set the pin high\n    } else {\n        *GPIO_ODR &= ~(1 << pin_position); // Set the pin low\n    }\n}\n/**\n * This function reads the state of a specified GPIO pin by directly accessing\n * the Input Data Register (IDR) of the GPIO port. It calculates the pin position\n * using a loop to ensure the correct bit is read.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to read (e.g., 1 << 5 for pin 5).\n * @return The state of the pin: 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Input Data Register (IDR)\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Read the state of the pin by checking the corresponding bit in the IDR\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin on the STM32F407 board.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specified pin. It uses bitwise XOR operation to ensure\n * atomic and reliable toggling of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    \n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    \n    // Toggle the state of the pin by using XOR operation on the corresponding bit in the ODR\n    *GPIO_ODR ^= (1 << pin_position);\n}\n\n"
        },
        {
            "unique_id": "0ed362a3-d3eb-4ec9-9699-4c990396fc80",
            "timestamp": "2024-10-31T08:10:15.394138",
            "total time (seconds)": 26.925262928009033,
            "compilation-success": true,
            "Similarity with Previous": 97.47081712062257,
            "Similarity with Original": 51.536812008577556,
            "Removed Element": "ENABLE_GPIOA_CLOCK",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * @brief Sets a GPIO pin as either input or output.\n * \n * This function sets a GPIO pin as either input or output by modifying the\n * GPIO mode register (MODER). It uses direct register manipulation to ensure\n * atomic operations.\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Pointer to the GPIO MODER register\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base);\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Each pin has 2 bits in the MODER register\n    uint32_t moder_position = pin_position * 2;\n    // Clear the current mode for the pin by setting the two bits to 0\n    *GPIO_MODER &= ~(0x3 << moder_position);\n    // Set the new mode for the pin\n    *GPIO_MODER |= (mode << moder_position);\n}\n/**\n * @brief Writes a value to a specified GPIO pin on the STM32F407 board.\n * \n * This function directly manipulates the Output Data Register (ODR) of the GPIO port\n * to set or clear a specific pin. It calculates the pin position using a loop to ensure\n * the correct bit is modified.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to write to (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin: 1 to set the pin high, 0 to set it low.\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Write the value to the pin by setting or clearing the corresponding bit in the ODR\n    if (value) {\n        *GPIO_ODR |= (1 << pin_position);  // Set the pin high\n    } else {\n        *GPIO_ODR &= ~(1 << pin_position); // Set the pin low\n    }\n}\n/**\n * This function reads the state of a specified GPIO pin by directly accessing\n * the Input Data Register (IDR) of the GPIO port. It calculates the pin position\n * using a loop to ensure the correct bit is read.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to read (e.g., 1 << 5 for pin 5).\n * @return The state of the pin: 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Input Data Register (IDR)\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Read the state of the pin by checking the corresponding bit in the IDR\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n/**\n * @brief Toggles the state of a specified GPIO pin on the STM32F407 board.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specified pin. It uses bitwise XOR operation to ensure\n * atomic and reliable toggling of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Toggle the state of the pin by using XOR operation on the corresponding bit in the ODR\n    *GPIO_ODR ^= (1 << pin_position);\n}\n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC_AHB1ENR register to enable the clock for GPIOA.\n * It ensures that the clock is enabled by setting the appropriate bit in the register.\n * \n * @return 1 if the clock was successfully enabled, 0 otherwise.\n */\nint ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC and the offset for the AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(RCC_BASE + RCC_AHB1ENR_OFFSET);\n\n    // Set the bit corresponding to GPIOA (bit 0) to enable its clock\n    *RCC_AHB1ENR |= (1 << 0);\n\n    // Return 1 if the clock is enabled, 0 otherwise\n    return ((*RCC_AHB1ENR & (1 << 0)) != 0) ? 1 : 0;\n}\n\n"
        },
        {
            "unique_id": "63775ee0-21b4-420d-b432-69f6e2d242e5",
            "timestamp": "2024-10-31T08:10:40.374465",
            "total time (seconds)": 5.4887471199035645,
            "compilation-success": true,
            "Similarity with Previous": 100.0,
            "Similarity with Original": 51.536812008577556,
            "Removed Element": "ENABLE_GPIOA_CLOCK",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * @brief Sets a GPIO pin as either input or output.\n * \n * This function sets a GPIO pin as either input or output by modifying the\n * GPIO mode register (MODER). It uses direct register manipulation to ensure\n * atomic operations.\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Pointer to the GPIO MODER register\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base);\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Each pin has 2 bits in the MODER register\n    uint32_t moder_position = pin_position * 2;\n    // Clear the current mode for the pin by setting the two bits to 0\n    *GPIO_MODER &= ~(0x3 << moder_position);\n    // Set the new mode for the pin\n    *GPIO_MODER |= (mode << moder_position);\n}\n/**\n * @brief Writes a value to a specified GPIO pin on the STM32F407 board.\n * \n * This function directly manipulates the Output Data Register (ODR) of the GPIO port\n * to set or clear a specific pin. It calculates the pin position using a loop to ensure\n * the correct bit is modified.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to write to (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin: 1 to set the pin high, 0 to set it low.\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Write the value to the pin by setting or clearing the corresponding bit in the ODR\n    if (value) {\n        *GPIO_ODR |= (1 << pin_position);  // Set the pin high\n    } else {\n        *GPIO_ODR &= ~(1 << pin_position); // Set the pin low\n    }\n}\n/**\n * This function reads the state of a specified GPIO pin by directly accessing\n * the Input Data Register (IDR) of the GPIO port. It calculates the pin position\n * using a loop to ensure the correct bit is read.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to read (e.g., 1 << 5 for pin 5).\n * @return The state of the pin: 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Input Data Register (IDR)\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Read the state of the pin by checking the corresponding bit in the IDR\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n/**\n * @brief Toggles the state of a specified GPIO pin on the STM32F407 board.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specified pin. It uses bitwise XOR operation to ensure\n * atomic and reliable toggling of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Toggle the state of the pin by using XOR operation on the corresponding bit in the ODR\n    *GPIO_ODR ^= (1 << pin_position);\n}\n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC_AHB1ENR register to enable the clock for GPIOA.\n * It ensures that the clock is enabled by setting the appropriate bit in the register.\n * \n * @return 1 if the clock was successfully enabled, 0 otherwise.\n */\nint ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC and the offset for the AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(RCC_BASE + RCC_AHB1ENR_OFFSET);\n    // Set the bit corresponding to GPIOA (bit 0) to enable its clock\n    *RCC_AHB1ENR |= (1 << 0);\n    // Return 1 if the clock is enabled, 0 otherwise\n    return ((*RCC_AHB1ENR & (1 << 0)) != 0) ? 1 : 0;\n}\n\n"
        },
        {
            "unique_id": "fb7f709d-0a84-4a5d-be3d-89a5cdcf0c62",
            "timestamp": "2024-10-31T08:11:08.943869",
            "total time (seconds)": 10.837141513824463,
            "compilation-success": true,
            "Similarity with Previous": 100.0,
            "Similarity with Original": 51.536812008577556,
            "Removed Element": "hardware_abstraction_layer_function_gpio_toggle_pin",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * @brief Sets a GPIO pin as either input or output.\n * \n * This function sets a GPIO pin as either input or output by modifying the\n * GPIO mode register (MODER). It uses direct register manipulation to ensure\n * atomic operations.\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Pointer to the GPIO MODER register\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base);\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Each pin has 2 bits in the MODER register\n    uint32_t moder_position = pin_position * 2;\n    // Clear the current mode for the pin by setting the two bits to 0\n    *GPIO_MODER &= ~(0x3 << moder_position);\n    // Set the new mode for the pin\n    *GPIO_MODER |= (mode << moder_position);\n}\n/**\n * @brief Writes a value to a specified GPIO pin on the STM32F407 board.\n * \n * This function directly manipulates the Output Data Register (ODR) of the GPIO port\n * to set or clear a specific pin. It calculates the pin position using a loop to ensure\n * the correct bit is modified.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to write to (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin: 1 to set the pin high, 0 to set it low.\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Write the value to the pin by setting or clearing the corresponding bit in the ODR\n    if (value) {\n        *GPIO_ODR |= (1 << pin_position);  // Set the pin high\n    } else {\n        *GPIO_ODR &= ~(1 << pin_position); // Set the pin low\n    }\n}\n/**\n * This function reads the state of a specified GPIO pin by directly accessing\n * the Input Data Register (IDR) of the GPIO port. It calculates the pin position\n * using a loop to ensure the correct bit is read.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to read (e.g., 1 << 5 for pin 5).\n * @return The state of the pin: 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Input Data Register (IDR)\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Read the state of the pin by checking the corresponding bit in the IDR\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC_AHB1ENR register to enable the clock for GPIOA.\n * It ensures that the clock is enabled by setting the appropriate bit in the register.\n * \n * @return 1 if the clock was successfully enabled, 0 otherwise.\n */\nint ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC and the offset for the AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(RCC_BASE + RCC_AHB1ENR_OFFSET);\n    // Set the bit corresponding to GPIOA (bit 0) to enable its clock\n    *RCC_AHB1ENR |= (1 << 0);\n    // Return 1 if the clock is enabled, 0 otherwise\n    return ((*RCC_AHB1ENR & (1 << 0)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin on the STM32F407 board.\n *\n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specified pin. It uses bitwise XOR operation to ensure\n * atomic and reliable toggling of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    \n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    \n    // Toggle the state of the pin by using XOR operation on the corresponding bit in the ODR\n    *GPIO_ODR ^= (1 << pin_position);\n}\n\n"
        },
        {
            "unique_id": "48bb1a17-36d7-471a-907d-eeee881949ba",
            "timestamp": "2024-10-31T08:11:31.871276",
            "total time (seconds)": 5.324014902114868,
            "compilation-success": true,
            "Similarity with Previous": 100.0,
            "Similarity with Original": 51.536812008577556,
            "Removed Element": "ENABLE_GPIOA_CLOCK",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * @brief Sets a GPIO pin as either input or output.\n * \n * This function sets a GPIO pin as either input or output by modifying the\n * GPIO mode register (MODER). It uses direct register manipulation to ensure\n * atomic operations.\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Pointer to the GPIO MODER register\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base);\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Each pin has 2 bits in the MODER register\n    uint32_t moder_position = pin_position * 2;\n    // Clear the current mode for the pin by setting the two bits to 0\n    *GPIO_MODER &= ~(0x3 << moder_position);\n    // Set the new mode for the pin\n    *GPIO_MODER |= (mode << moder_position);\n}\n/**\n * @brief Writes a value to a specified GPIO pin on the STM32F407 board.\n * \n * This function directly manipulates the Output Data Register (ODR) of the GPIO port\n * to set or clear a specific pin. It calculates the pin position using a loop to ensure\n * the correct bit is modified.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to write to (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin: 1 to set the pin high, 0 to set it low.\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Write the value to the pin by setting or clearing the corresponding bit in the ODR\n    if (value) {\n        *GPIO_ODR |= (1 << pin_position);  // Set the pin high\n    } else {\n        *GPIO_ODR &= ~(1 << pin_position); // Set the pin low\n    }\n}\n/**\n * This function reads the state of a specified GPIO pin by directly accessing\n * the Input Data Register (IDR) of the GPIO port. It calculates the pin position\n * using a loop to ensure the correct bit is read.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to read (e.g., 1 << 5 for pin 5).\n * @return The state of the pin: 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Input Data Register (IDR)\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Read the state of the pin by checking the corresponding bit in the IDR\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n/**\n * @brief Toggles the state of a specified GPIO pin on the STM32F407 board.\n *\n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specified pin. It uses bitwise XOR operation to ensure\n * atomic and reliable toggling of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Toggle the state of the pin by using XOR operation on the corresponding bit in the ODR\n    *GPIO_ODR ^= (1 << pin_position);\n}\n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n *\n * This function directly manipulates the RCC_AHB1ENR register to enable the clock for GPIOA.\n * It ensures that the clock is enabled by setting the appropriate bit in the register.\n *\n * @return 1 if the clock was successfully enabled, 0 otherwise.\n */\nint ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC and the offset for the AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(RCC_BASE + RCC_AHB1ENR_OFFSET);\n    // Set the bit corresponding to GPIOA (bit 0) to enable its clock\n    *RCC_AHB1ENR |= (1 << 0);\n    // Return 1 if the clock is enabled, 0 otherwise\n    return ((*RCC_AHB1ENR & (1 << 0)) != 0) ? 1 : 0;\n}\n\n"
        },
        {
            "unique_id": "e500d01a-e208-4f88-96dc-c0e6aef3fc50",
            "timestamp": "2024-10-31T08:12:11.483821",
            "total time (seconds)": 7.349648952484131,
            "compilation-success": true,
            "Similarity with Previous": 100.0,
            "Similarity with Original": 51.536812008577556,
            "Removed Element": "hardware_abstraction_layer_function_gpio_read_pin",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * @brief Sets a GPIO pin as either input or output.\n * \n * This function sets a GPIO pin as either input or output by modifying the\n * GPIO mode register (MODER). It uses direct register manipulation to ensure\n * atomic operations.\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Pointer to the GPIO MODER register\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base);\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Each pin has 2 bits in the MODER register\n    uint32_t moder_position = pin_position * 2;\n    // Clear the current mode for the pin by setting the two bits to 0\n    *GPIO_MODER &= ~(0x3 << moder_position);\n    // Set the new mode for the pin\n    *GPIO_MODER |= (mode << moder_position);\n}\n/**\n * @brief Writes a value to a specified GPIO pin on the STM32F407 board.\n * \n * This function directly manipulates the Output Data Register (ODR) of the GPIO port\n * to set or clear a specific pin. It calculates the pin position using a loop to ensure\n * the correct bit is modified.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to write to (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin: 1 to set the pin high, 0 to set it low.\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Write the value to the pin by setting or clearing the corresponding bit in the ODR\n    if (value) {\n        *GPIO_ODR |= (1 << pin_position);  // Set the pin high\n    } else {\n        *GPIO_ODR &= ~(1 << pin_position); // Set the pin low\n    }\n}\n/**\n * @brief Toggles the state of a specified GPIO pin on the STM32F407 board.\n *\n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specified pin. It uses bitwise XOR operation to ensure\n * atomic and reliable toggling of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Toggle the state of the pin by using XOR operation on the corresponding bit in the ODR\n    *GPIO_ODR ^= (1 << pin_position);\n}\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n *\n * This function directly manipulates the RCC_AHB1ENR register to enable the clock for GPIOA.\n * It ensures that the clock is enabled by setting the appropriate bit in the register.\n *\n * @return 1 if the clock was successfully enabled, 0 otherwise.\n */\nint ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC and the offset for the AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(RCC_BASE + RCC_AHB1ENR_OFFSET);\n    // Set the bit corresponding to GPIOA (bit 0) to enable its clock\n    *RCC_AHB1ENR |= (1 << 0);\n    // Return 1 if the clock is enabled, 0 otherwise\n    return ((*RCC_AHB1ENR & (1 << 0)) != 0) ? 1 : 0;\n}\n\n/**\n * This function reads the state of a specified GPIO pin by directly accessing\n * the Input Data Register (IDR) of the GPIO port. It calculates the pin position\n * using a loop to ensure the correct bit is read.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to read (e.g., 1 << 5 for pin 5).\n * @return The state of the pin: 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Input Data Register (IDR)\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Read the state of the pin by checking the corresponding bit in the IDR\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n"
        },
        {
            "unique_id": "65c62ce6-6be0-46a4-9478-56730f6fce7f",
            "timestamp": "2024-10-31T08:12:34.097208",
            "total time (seconds)": 5.728898048400879,
            "compilation-success": true,
            "Similarity with Previous": 91.98868991517436,
            "Similarity with Original": 51.144492131616595,
            "Removed Element": "hardware_abstraction_layer_function_gpio_toggle_pin",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * @brief Sets a GPIO pin as either input or output.\n * \n * This function sets a GPIO pin as either input or output by modifying the\n * GPIO mode register (MODER). It uses direct register manipulation to ensure\n * atomic operations.\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Pointer to the GPIO MODER register\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base);\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Each pin has 2 bits in the MODER register\n    uint32_t moder_position = pin_position * 2;\n    // Clear the current mode for the pin by setting the two bits to 0\n    *GPIO_MODER &= ~(0x3 << moder_position);\n    // Set the new mode for the pin\n    *GPIO_MODER |= (mode << moder_position);\n}\n/**\n * @brief Writes a value to a specified GPIO pin on the STM32F407 board.\n * \n * This function directly manipulates the Output Data Register (ODR) of the GPIO port\n * to set or clear a specific pin. It calculates the pin position using a loop to ensure\n * the correct bit is modified.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to write to (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin: 1 to set the pin high, 0 to set it low.\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Write the value to the pin by setting or clearing the corresponding bit in the ODR\n    if (value) {\n        *GPIO_ODR |= (1 << pin_position);  // Set the pin high\n    } else {\n        *GPIO_ODR &= ~(1 << pin_position); // Set the pin low\n    }\n}\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n *\n * This function directly manipulates the RCC_AHB1ENR register to enable the clock for GPIOA.\n * It ensures that the clock is enabled by setting the appropriate bit in the register.\n *\n * @return 1 if the clock was successfully enabled, 0 otherwise.\n */\nint ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC and the offset for the AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(RCC_BASE + RCC_AHB1ENR_OFFSET);\n    // Set the bit corresponding to GPIOA (bit 0) to enable its clock\n    *RCC_AHB1ENR |= (1 << 0);\n    // Return 1 if the clock is enabled, 0 otherwise\n    return ((*RCC_AHB1ENR & (1 << 0)) != 0) ? 1 : 0;\n}\n/**\n * This function reads the state of a specified GPIO pin by directly accessing\n * the Input Data Register (IDR) of the GPIO port. It calculates the pin position\n * using a loop to ensure the correct bit is read.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to read (e.g., 1 << 5 for pin 5).\n * @return The state of the pin: 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Input Data Register (IDR)\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Read the state of the pin by checking the corresponding bit in the IDR\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function uses bitwise XOR operation to ensure atomic and reliable toggling\n * of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    \n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    \n    // Toggle the state of the pin by using XOR operation on the corresponding bit in the ODR\n    *GPIO_ODR ^= (1 << pin_position);\n}\n\n"
        },
        {
            "unique_id": "4986964a-d9ec-4f31-a962-47c6b2a3f628",
            "timestamp": "2024-10-31T08:13:03.873893",
            "total time (seconds)": 10.755770683288574,
            "compilation-success": true,
            "Similarity with Previous": 100.0,
            "Similarity with Original": 51.144492131616595,
            "Removed Element": "hardware_abstraction_layer_function_gpio_toggle_pin",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * @brief Sets a GPIO pin as either input or output.\n * \n * This function sets a GPIO pin as either input or output by modifying the\n * GPIO mode register (MODER). It uses direct register manipulation to ensure\n * atomic operations.\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Pointer to the GPIO MODER register\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base);\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Each pin has 2 bits in the MODER register\n    uint32_t moder_position = pin_position * 2;\n    // Clear the current mode for the pin by setting the two bits to 0\n    *GPIO_MODER &= ~(0x3 << moder_position);\n    // Set the new mode for the pin\n    *GPIO_MODER |= (mode << moder_position);\n}\n/**\n * @brief Writes a value to a specified GPIO pin on the STM32F407 board.\n * \n * This function directly manipulates the Output Data Register (ODR) of the GPIO port\n * to set or clear a specific pin. It calculates the pin position using a loop to ensure\n * the correct bit is modified.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to write to (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin: 1 to set the pin high, 0 to set it low.\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Write the value to the pin by setting or clearing the corresponding bit in the ODR\n    if (value) {\n        *GPIO_ODR |= (1 << pin_position);  // Set the pin high\n    } else {\n        *GPIO_ODR &= ~(1 << pin_position); // Set the pin low\n    }\n}\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n *\n * This function directly manipulates the RCC_AHB1ENR register to enable the clock for GPIOA.\n * It ensures that the clock is enabled by setting the appropriate bit in the register.\n *\n * @return 1 if the clock was successfully enabled, 0 otherwise.\n */\nint ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC and the offset for the AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(RCC_BASE + RCC_AHB1ENR_OFFSET);\n    // Set the bit corresponding to GPIOA (bit 0) to enable its clock\n    *RCC_AHB1ENR |= (1 << 0);\n    // Return 1 if the clock is enabled, 0 otherwise\n    return ((*RCC_AHB1ENR & (1 << 0)) != 0) ? 1 : 0;\n}\n/**\n * This function reads the state of a specified GPIO pin by directly accessing\n * the Input Data Register (IDR) of the GPIO port. It calculates the pin position\n * using a loop to ensure the correct bit is read.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to read (e.g., 1 << 5 for pin 5).\n * @return The state of the pin: 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Input Data Register (IDR)\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Read the state of the pin by checking the corresponding bit in the IDR\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function uses bitwise XOR operation to ensure atomic and reliable toggling\n * of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    \n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    \n    // Toggle the state of the pin by using XOR operation on the corresponding bit in the ODR\n    *GPIO_ODR ^= (1 << pin_position);\n}\n\n"
        },
        {
            "unique_id": "9de6be14-fe5b-430c-aef6-df56f827b565",
            "timestamp": "2024-10-31T08:13:27.156134",
            "total time (seconds)": 4.813976287841797,
            "compilation-success": true,
            "Similarity with Previous": 88.58230256898192,
            "Similarity with Original": 52.0,
            "Removed Element": "ENABLE_GPIOA_CLOCK",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * @brief Sets a GPIO pin as either input or output.\n * \n * This function sets a GPIO pin as either input or output by modifying the\n * GPIO mode register (MODER). It uses direct register manipulation to ensure\n * atomic operations.\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Pointer to the GPIO MODER register\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base);\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Each pin has 2 bits in the MODER register\n    uint32_t moder_position = pin_position * 2;\n    // Clear the current mode for the pin by setting the two bits to 0\n    *GPIO_MODER &= ~(0x3 << moder_position);\n    // Set the new mode for the pin\n    *GPIO_MODER |= (mode << moder_position);\n}\n/**\n * @brief Writes a value to a specified GPIO pin on the STM32F407 board.\n * \n * This function directly manipulates the Output Data Register (ODR) of the GPIO port\n * to set or clear a specific pin. It calculates the pin position using a loop to ensure\n * the correct bit is modified.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to write to (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin: 1 to set the pin high, 0 to set it low.\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Write the value to the pin by setting or clearing the corresponding bit in the ODR\n    if (value) {\n        *GPIO_ODR |= (1 << pin_position);  // Set the pin high\n    } else {\n        *GPIO_ODR &= ~(1 << pin_position); // Set the pin low\n    }\n}\n/**\n * This function reads the state of a specified GPIO pin by directly accessing\n * the Input Data Register (IDR) of the GPIO port. It calculates the pin position\n * using a loop to ensure the correct bit is read.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to read (e.g., 1 << 5 for pin 5).\n * @return The state of the pin: 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Input Data Register (IDR)\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Read the state of the pin by checking the corresponding bit in the IDR\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function uses bitwise XOR operation to ensure atomic and reliable toggling\n * of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Toggle the state of the pin by using XOR operation on the corresponding bit in the ODR\n    *GPIO_ODR ^= (1 << pin_position);\n}\n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n *\n * This function directly manipulates the RCC_AHB1ENR register to enable the clock for GPIOA.\n * It ensures that the GPIOA peripheral is powered and ready for use.\n *\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Enable the clock for GPIOA by setting the appropriate bit in the RCC_AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);  // Set bit 0 to enable GPIOA clock\n}\n\n"
        },
        {
            "unique_id": "3573ab58-f0aa-447e-9102-d049dc502ed1",
            "timestamp": "2024-10-31T08:13:58.172201",
            "total time (seconds)": 8.576192617416382,
            "compilation-success": true,
            "Similarity with Previous": 93.11377245508982,
            "Similarity with Original": 51.911764705882355,
            "Removed Element": "hardware_abstraction_layer_function_gpio_write_pin",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * @brief Sets a GPIO pin as either input or output.\n * \n * This function sets a GPIO pin as either input or output by modifying the\n * GPIO mode register (MODER). It uses direct register manipulation to ensure\n * atomic operations.\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Pointer to the GPIO MODER register\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base);\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Each pin has 2 bits in the MODER register\n    uint32_t moder_position = pin_position * 2;\n    // Clear the current mode for the pin by setting the two bits to 0\n    *GPIO_MODER &= ~(0x3 << moder_position);\n    // Set the new mode for the pin\n    *GPIO_MODER |= (mode << moder_position);\n}\n/**\n * This function reads the state of a specified GPIO pin by directly accessing\n * the Input Data Register (IDR) of the GPIO port. It calculates the pin position\n * using a loop to ensure the correct bit is read.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to read (e.g., 1 << 5 for pin 5).\n * @return The state of the pin: 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Input Data Register (IDR)\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Read the state of the pin by checking the corresponding bit in the IDR\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function uses bitwise XOR operation to ensure atomic and reliable toggling\n * of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Toggle the state of the pin by using XOR operation on the corresponding bit in the ODR\n    *GPIO_ODR ^= (1 << pin_position);\n}\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n *\n * This function directly manipulates the RCC_AHB1ENR register to enable the clock for GPIOA.\n * It ensures that the GPIOA peripheral is powered and ready for use.\n *\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n    // Enable the clock for GPIOA by setting the appropriate bit in the RCC_AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);  // Set bit 0 to enable GPIOA clock\n}\n\n/**\n * @brief Writes a value to a specified GPIO pin by directly accessing\n * the Output Data Register (ODR) of the GPIO port. It calculates the pin position\n * using a loop to ensure the correct bit is set or cleared.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to write to (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin: 1 to set the pin high, 0 to set it low.\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Write the value to the pin by setting or clearing the corresponding bit in the ODR\n    if (value) {\n        *GPIO_ODR |= (1 << pin_position);  // Set the pin high\n    } else {\n        *GPIO_ODR &= ~(1 << pin_position); // Set the pin low\n    }\n}\n\n"
        },
        {
            "unique_id": "cb58efc1-1fc0-4d61-999d-37dcfa804900",
            "timestamp": "2024-10-31T08:14:27.132528",
            "total time (seconds)": 5.404406309127808,
            "compilation-success": true,
            "Similarity with Previous": 96.60493827160494,
            "Similarity with Original": 52.148148148148145,
            "Removed Element": "ENABLE_GPIOA_CLOCK",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * @brief Sets a GPIO pin as either input or output.\n * \n * This function sets a GPIO pin as either input or output by modifying the\n * GPIO mode register (MODER). It uses direct register manipulation to ensure\n * atomic operations.\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Pointer to the GPIO MODER register\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base);\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Each pin has 2 bits in the MODER register\n    uint32_t moder_position = pin_position * 2;\n    // Clear the current mode for the pin by setting the two bits to 0\n    *GPIO_MODER &= ~(0x3 << moder_position);\n    // Set the new mode for the pin\n    *GPIO_MODER |= (mode << moder_position);\n}\n/**\n * This function reads the state of a specified GPIO pin by directly accessing\n * the Input Data Register (IDR) of the GPIO port. It calculates the pin position\n * using a loop to ensure the correct bit is read.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to read (e.g., 1 << 5 for pin 5).\n * @return The state of the pin: 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Input Data Register (IDR)\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Read the state of the pin by checking the corresponding bit in the IDR\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function uses bitwise XOR operation to ensure atomic and reliable toggling\n * of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Toggle the state of the pin by using XOR operation on the corresponding bit in the ODR\n    *GPIO_ODR ^= (1 << pin_position);\n}\n/**\n * @brief Writes a value to a specified GPIO pin by directly accessing\n * the Output Data Register (ODR) of the GPIO port. It calculates the pin position\n * using a loop to ensure the correct bit is set or cleared.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to write to (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin: 1 to set the pin high, 0 to set it low.\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Write the value to the pin by setting or clearing the corresponding bit in the ODR\n    if (value) {\n        *GPIO_ODR |= (1 << pin_position);  // Set the pin high\n    } else {\n        *GPIO_ODR &= ~(1 << pin_position); // Set the pin low\n    }\n}\n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n *\n * This function directly manipulates the RCC_AHB1ENR register to enable the clock for GPIOA.\n * It ensures that the GPIOA peripheral is powered and ready for use.\n *\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Enable the clock for GPIOA by setting the 0th bit of the RCC_AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n"
        },
        {
            "unique_id": "a550e89c-61cb-43ea-b536-2932e2bac56c",
            "timestamp": "2024-10-31T08:14:56.273676",
            "total time (seconds)": 6.026020050048828,
            "compilation-success": true,
            "Similarity with Previous": 95.6386292834891,
            "Similarity with Original": 52.34549516008935,
            "Removed Element": "set_input_output_mode",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * This function reads the state of a specified GPIO pin by directly accessing\n * the Input Data Register (IDR) of the GPIO port. It calculates the pin position\n * using a loop to ensure the correct bit is read.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to read (e.g., 1 << 5 for pin 5).\n * @return The state of the pin: 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Input Data Register (IDR)\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Read the state of the pin by checking the corresponding bit in the IDR\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function uses bitwise XOR operation to ensure atomic and reliable toggling\n * of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Toggle the state of the pin by using XOR operation on the corresponding bit in the ODR\n    *GPIO_ODR ^= (1 << pin_position);\n}\n/**\n * @brief Writes a value to a specified GPIO pin by directly accessing\n * the Output Data Register (ODR) of the GPIO port. It calculates the pin position\n * using a loop to ensure the correct bit is set or cleared.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to write to (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin: 1 to set the pin high, 0 to set it low.\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Write the value to the pin by setting or clearing the corresponding bit in the ODR\n    if (value) {\n        *GPIO_ODR |= (1 << pin_position);  // Set the pin high\n    } else {\n        *GPIO_ODR &= ~(1 << pin_position); // Set the pin low\n    }\n}\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n *\n * This function directly manipulates the RCC_AHB1ENR register to enable the clock for GPIOA.\n * It ensures that the GPIOA peripheral is powered and ready for use.\n *\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n    // Enable the clock for GPIOA by setting the 0th bit of the RCC_AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n/**\n * @brief Sets a GPIO pin as either input or output.\n * \n * This function sets a GPIO pin as either input or output by modifying the\n * GPIO mode register (MODER). It uses direct register manipulation to ensure\n * atomic operations.\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Pointer to the GPIO MODER register\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base);\n\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Each pin has 2 bits in the MODER register\n    uint32_t moder_position = pin_position * 2;\n\n    // Clear the 2 bits corresponding to the pin\n    *GPIO_MODER &= ~(0x3 << moder_position);\n\n    // Set the mode (0 for input, 1 for output) in the MODER register\n    *GPIO_MODER |= (mode << moder_position);\n}\n\n"
        },
        {
            "unique_id": "5e674b0e-8a63-4627-814c-ce8af3aef848",
            "timestamp": "2024-10-31T08:15:18.008390",
            "total time (seconds)": 4.111045837402344,
            "compilation-success": true,
            "Similarity with Previous": 96.875,
            "Similarity with Original": 51.55786350148368,
            "Removed Element": "ENABLE_GPIOA_CLOCK",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * This function reads the state of a specified GPIO pin by directly accessing\n * the Input Data Register (IDR) of the GPIO port. It calculates the pin position\n * using a loop to ensure the correct bit is read.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to read (e.g., 1 << 5 for pin 5).\n * @return The state of the pin: 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Input Data Register (IDR)\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Read the state of the pin by checking the corresponding bit in the IDR\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function uses bitwise XOR operation to ensure atomic and reliable toggling\n * of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Toggle the state of the pin by using XOR operation on the corresponding bit in the ODR\n    *GPIO_ODR ^= (1 << pin_position);\n}\n/**\n * @brief Writes a value to a specified GPIO pin by directly accessing\n * the Output Data Register (ODR) of the GPIO port. It calculates the pin position\n * using a loop to ensure the correct bit is set or cleared.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to write to (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin: 1 to set the pin high, 0 to set it low.\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Write the value to the pin by setting or clearing the corresponding bit in the ODR\n    if (value) {\n        *GPIO_ODR |= (1 << pin_position);  // Set the pin high\n    } else {\n        *GPIO_ODR &= ~(1 << pin_position); // Set the pin low\n    }\n}\n/**\n * @brief Sets a GPIO pin as either input or output.\n * \n * This function sets a GPIO pin as either input or output by modifying the\n * GPIO mode register (MODER). It uses direct register manipulation to ensure\n * atomic operations.\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Pointer to the GPIO MODER register\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base);\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Each pin has 2 bits in the MODER register\n    uint32_t moder_position = pin_position * 2;\n    // Clear the 2 bits corresponding to the pin\n    *GPIO_MODER &= ~(0x3 << moder_position);\n    // Set the mode (0 for input, 1 for output) in the MODER register\n    *GPIO_MODER |= (mode << moder_position);\n}\n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n *\n * This function directly manipulates the RCC_AHB1ENR register to enable the clock for GPIOA.\n * It ensures that the GPIOA peripheral is powered and ready for use.\n *\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC_AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Set the 0th bit of the RCC_AHB1ENR register to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n"
        },
        {
            "unique_id": "6e9142be-6fdb-43ed-9f1a-2e69862b41d6",
            "timestamp": "2024-10-31T08:15:48.506850",
            "total time (seconds)": 12.953922748565674,
            "compilation-success": true,
            "Similarity with Previous": 96.87825182101977,
            "Similarity with Original": 53.0688622754491,
            "Removed Element": "hardware_abstraction_layer_function_gpio_write_pin",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * This function reads the state of a specified GPIO pin by directly accessing\n * the Input Data Register (IDR) of the GPIO port. It calculates the pin position\n * using a loop to ensure the correct bit is read.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to read (e.g., 1 << 5 for pin 5).\n * @return The state of the pin: 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Input Data Register (IDR)\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Read the state of the pin by checking the corresponding bit in the IDR\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function uses bitwise XOR operation to ensure atomic and reliable toggling\n * of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Toggle the state of the pin by using XOR operation on the corresponding bit in the ODR\n    *GPIO_ODR ^= (1 << pin_position);\n}\n/**\n * @brief Sets a GPIO pin as either input or output.\n * \n * This function sets a GPIO pin as either input or output by modifying the\n * GPIO mode register (MODER). It uses direct register manipulation to ensure\n * atomic operations.\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Pointer to the GPIO MODER register\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base);\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Each pin has 2 bits in the MODER register\n    uint32_t moder_position = pin_position * 2;\n    // Clear the 2 bits corresponding to the pin\n    *GPIO_MODER &= ~(0x3 << moder_position);\n    // Set the mode (0 for input, 1 for output) in the MODER register\n    *GPIO_MODER |= (mode << moder_position);\n}\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n *\n * This function directly manipulates the RCC_AHB1ENR register to enable the clock for GPIOA.\n * It ensures that the GPIOA peripheral is powered and ready for use.\n *\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC_AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n    // Set the 0th bit of the RCC_AHB1ENR register to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n/**\n * @brief Writes a value to a specified GPIO pin by directly accessing\n * the Output Data Register (ODR) of the GPIO port. It calculates the pin position\n * using a loop to ensure the correct bit is set or cleared.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to write to (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin: 1 to set the pin high, 0 to set it low.\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin by setting or clearing the corresponding bit in the ODR\n    if (value) {\n        // Set the pin high\n        *GPIO_ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *GPIO_ODR &= ~(1 << pin_position);\n    }\n}\n\n"
        },
        {
            "unique_id": "7ff9a5c4-77c1-4a11-857e-1fc7c5faccca",
            "timestamp": "2024-10-31T08:16:17.958771",
            "total time (seconds)": 10.479795455932617,
            "compilation-success": true,
            "Similarity with Previous": 93.20288362512873,
            "Similarity with Original": 51.865671641791046,
            "Removed Element": "set_input_output_mode",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * This function reads the state of a specified GPIO pin by directly accessing\n * the Input Data Register (IDR) of the GPIO port. It calculates the pin position\n * using a loop to ensure the correct bit is read.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to read (e.g., 1 << 5 for pin 5).\n * @return The state of the pin: 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Input Data Register (IDR)\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Read the state of the pin by checking the corresponding bit in the IDR\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function uses bitwise XOR operation to ensure atomic and reliable toggling\n * of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Toggle the state of the pin by using XOR operation on the corresponding bit in the ODR\n    *GPIO_ODR ^= (1 << pin_position);\n}\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n *\n * This function directly manipulates the RCC_AHB1ENR register to enable the clock for GPIOA.\n * It ensures that the GPIOA peripheral is powered and ready for use.\n *\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC_AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n    // Set the 0th bit of the RCC_AHB1ENR register to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n/**\n * @brief Writes a value to a specified GPIO pin by directly accessing\n * the Output Data Register (ODR) of the GPIO port. It calculates the pin position\n * using a loop to ensure the correct bit is set or cleared.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to write to (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin: 1 to set the pin high, 0 to set it low.\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Write the value to the pin by setting or clearing the corresponding bit in the ODR\n    if (value) {\n        // Set the pin high\n        *GPIO_ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *GPIO_ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Sets a GPIO pin as either input or output.\n * \n * This function sets a GPIO pin as either input or output by modifying the\n * GPIO mode register (MODER). It uses direct register manipulation to ensure\n * atomic operations.\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Pointer to the GPIO MODER register\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base);\n\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Calculate the position in the MODER register (each pin uses 2 bits)\n    uint32_t moder_position = pin_position * 2;\n\n    // Clear the current mode for the pin (set both bits to 0)\n    *GPIO_MODER &= ~(0x3 << moder_position);\n\n    // Set the new mode for the pin\n    *GPIO_MODER |= (mode << moder_position);\n}\n\n"
        },
        {
            "unique_id": "a72a9424-8904-4bda-960b-34a229b32a00",
            "timestamp": "2024-10-31T08:16:50.721610",
            "total time (seconds)": 7.6241374015808105,
            "compilation-success": true,
            "Similarity with Previous": 100.0,
            "Similarity with Original": 51.71385991058122,
            "Removed Element": "set_input_output_mode",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * This function reads the state of a specified GPIO pin by directly accessing\n * the Input Data Register (IDR) of the GPIO port. It calculates the pin position\n * using a loop to ensure the correct bit is read.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to read (e.g., 1 << 5 for pin 5).\n * @return The state of the pin: 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Input Data Register (IDR)\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Read the state of the pin by checking the corresponding bit in the IDR\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function uses bitwise XOR operation to ensure atomic and reliable toggling\n * of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Toggle the state of the pin by using XOR operation on the corresponding bit in the ODR\n    *GPIO_ODR ^= (1 << pin_position);\n}\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n *\n * This function directly manipulates the RCC_AHB1ENR register to enable the clock for GPIOA.\n * It ensures that the GPIOA peripheral is powered and ready for use.\n *\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC_AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n    // Set the 0th bit of the RCC_AHB1ENR register to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n/**\n * @brief Writes a value to a specified GPIO pin by directly accessing\n * the Output Data Register (ODR) of the GPIO port. It calculates the pin position\n * using a loop to ensure the correct bit is set or cleared.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to write to (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin: 1 to set the pin high, 0 to set it low.\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Write the value to the pin by setting or clearing the corresponding bit in the ODR\n    if (value) {\n        // Set the pin high\n        *GPIO_ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *GPIO_ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Sets a GPIO pin as either input or output.\n * \n * This function sets a GPIO pin as either input or output by modifying the\n * GPIO mode register (MODER). It uses direct register manipulation to ensure\n * atomic operations.\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Pointer to the GPIO MODER register\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base);\n    \n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    \n    // Calculate the position in the MODER register (each pin uses 2 bits)\n    uint32_t moder_position = pin_position * 2;\n    \n    // Clear the current mode for the pin (set both bits to 0)\n    *GPIO_MODER &= ~(0x3 << moder_position);\n    \n    // Set the new mode for the pin\n    *GPIO_MODER |= (mode << moder_position);\n}\n\n"
        },
        {
            "unique_id": "047af9b9-a5fe-4de2-bd6f-ddafe24e6528",
            "timestamp": "2024-10-31T08:17:17.319713",
            "total time (seconds)": 6.552857875823975,
            "compilation-success": true,
            "Similarity with Previous": 94.63917525773195,
            "Similarity with Original": 51.25925925925926,
            "Removed Element": "hardware_abstraction_layer_function_gpio_toggle_pin",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * This function reads the state of a specified GPIO pin by directly accessing\n * the Input Data Register (IDR) of the GPIO port. It calculates the pin position\n * using a loop to ensure the correct bit is read.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to read (e.g., 1 << 5 for pin 5).\n * @return The state of the pin: 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Input Data Register (IDR)\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Read the state of the pin by checking the corresponding bit in the IDR\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n *\n * This function directly manipulates the RCC_AHB1ENR register to enable the clock for GPIOA.\n * It ensures that the GPIOA peripheral is powered and ready for use.\n *\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC_AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n    // Set the 0th bit of the RCC_AHB1ENR register to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n/**\n * @brief Writes a value to a specified GPIO pin by directly accessing\n * the Output Data Register (ODR) of the GPIO port. It calculates the pin position\n * using a loop to ensure the correct bit is set or cleared.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to write to (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin: 1 to set the pin high, 0 to set it low.\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Write the value to the pin by setting or clearing the corresponding bit in the ODR\n    if (value) {\n        // Set the pin high\n        *GPIO_ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *GPIO_ODR &= ~(1 << pin_position);\n    }\n}\n/**\n * @brief Sets a GPIO pin as either input or output.\n * \n * This function sets a GPIO pin as either input or output by modifying the\n * GPIO mode register (MODER). It uses direct register manipulation to ensure\n * atomic operations.\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Pointer to the GPIO MODER register\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Calculate the position in the MODER register (each pin uses 2 bits)\n    uint32_t moder_position = pin_position * 2;\n    // Clear the current mode for the pin (set both bits to 0)\n    *GPIO_MODER &= ~(0x3 << moder_position);\n    // Set the new mode for the pin\n    *GPIO_MODER |= (mode << moder_position);\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function uses bitwise XOR operation to ensure atomic and reliable toggling\n * of the pin state. It calculates the pin position using a loop to ensure the correct\n * bit is toggled in the Output Data Register (ODR).\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    \n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    \n    // Toggle the pin by XORing the corresponding bit in the ODR\n    *GPIO_ODR ^= (1 << pin_position);\n}\n\n"
        },
        {
            "unique_id": "a60aa437-4d31-4067-8d11-efc29cb70212",
            "timestamp": "2024-10-31T08:17:44.054972",
            "total time (seconds)": 6.4086291790008545,
            "compilation-success": true,
            "Similarity with Previous": 98.22361546499478,
            "Similarity with Original": 51.22131754256106,
            "Removed Element": "hardware_abstraction_layer_function_gpio_read_pin",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n *\n * This function directly manipulates the RCC_AHB1ENR register to enable the clock for GPIOA.\n * It ensures that the GPIOA peripheral is powered and ready for use.\n *\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC_AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n    // Set the 0th bit of the RCC_AHB1ENR register to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n/**\n * @brief Writes a value to a specified GPIO pin by directly accessing\n * the Output Data Register (ODR) of the GPIO port. It calculates the pin position\n * using a loop to ensure the correct bit is set or cleared.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to write to (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin: 1 to set the pin high, 0 to set it low.\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Write the value to the pin by setting or clearing the corresponding bit in the ODR\n    if (value) {\n        // Set the pin high\n        *GPIO_ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *GPIO_ODR &= ~(1 << pin_position);\n    }\n}\n/**\n * @brief Sets a GPIO pin as either input or output.\n * \n * This function sets a GPIO pin as either input or output by modifying the\n * GPIO mode register (MODER). It uses direct register manipulation to ensure\n * atomic operations.\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Pointer to the GPIO MODER register\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Calculate the position in the MODER register (each pin uses 2 bits)\n    uint32_t moder_position = pin_position * 2;\n    // Clear the current mode for the pin (set both bits to 0)\n    *GPIO_MODER &= ~(0x3 << moder_position);\n    // Set the new mode for the pin\n    *GPIO_MODER |= (mode << moder_position);\n}\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function uses bitwise XOR operation to ensure atomic and reliable toggling\n * of the pin state. It calculates the pin position using a loop to ensure the correct\n * bit is toggled in the Output Data Register (ODR).\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Toggle the pin by XORing the corresponding bit in the ODR\n    *GPIO_ODR ^= (1 << pin_position);\n}\n\n/**\n * This function reads the state of a specified GPIO pin by directly accessing\n * the Input Data Register (IDR) of the GPIO port. It calculates the pin position\n * using a loop to ensure the correct bit is read.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to read (e.g., 1 << 5 for pin 5).\n * @return The state of the pin: 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Input Data Register (IDR)\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    \n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    \n    // Read the pin state by checking the corresponding bit in the IDR\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n"
        },
        {
            "unique_id": "917c1459-f3ae-4b6d-b557-f8b1ab9952db",
            "timestamp": "2024-10-31T08:18:12.226362",
            "total time (seconds)": 8.141643285751343,
            "compilation-success": true,
            "Similarity with Previous": 98.74081846799581,
            "Similarity with Original": 51.33333333333333,
            "Removed Element": "hardware_abstraction_layer_function_gpio_toggle_pin",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n *\n * This function directly manipulates the RCC_AHB1ENR register to enable the clock for GPIOA.\n * It ensures that the GPIOA peripheral is powered and ready for use.\n *\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC_AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n    // Set the 0th bit of the RCC_AHB1ENR register to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n/**\n * @brief Writes a value to a specified GPIO pin by directly accessing\n * the Output Data Register (ODR) of the GPIO port. It calculates the pin position\n * using a loop to ensure the correct bit is set or cleared.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to write to (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin: 1 to set the pin high, 0 to set it low.\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Write the value to the pin by setting or clearing the corresponding bit in the ODR\n    if (value) {\n        // Set the pin high\n        *GPIO_ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *GPIO_ODR &= ~(1 << pin_position);\n    }\n}\n/**\n * @brief Sets a GPIO pin as either input or output.\n * \n * This function sets a GPIO pin as either input or output by modifying the\n * GPIO mode register (MODER). It uses direct register manipulation to ensure\n * atomic operations.\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Pointer to the GPIO MODER register\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Calculate the position in the MODER register (each pin uses 2 bits)\n    uint32_t moder_position = pin_position * 2;\n    // Clear the current mode for the pin (set both bits to 0)\n    *GPIO_MODER &= ~(0x3 << moder_position);\n    // Set the new mode for the pin\n    *GPIO_MODER |= (mode << moder_position);\n}\n/**\n * This function reads the state of a specified GPIO pin by directly accessing\n * the Input Data Register (IDR) of the GPIO port. It calculates the pin position\n * using a loop to ensure the correct bit is read.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to read (e.g., 1 << 5 for pin 5).\n * @return The state of the pin: 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Input Data Register (IDR)\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Read the pin state by checking the corresponding bit in the IDR\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function uses bitwise XOR operation to ensure atomic and reliable toggling\n * of the pin state. It calculates the pin position using a loop to ensure the correct\n * bit is toggled in the Output Data Register (ODR).\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Toggle the pin state by XORing the corresponding bit in the ODR\n    *GPIO_ODR ^= (1 << pin_position);\n}\n\n"
        },
        {
            "unique_id": "904b1cf8-4e54-410f-8398-0b9740ad3eb1",
            "timestamp": "2024-10-31T08:18:39.308915",
            "total time (seconds)": 8.872081995010376,
            "compilation-success": true,
            "Similarity with Previous": 100.0,
            "Similarity with Original": 51.183431952662716,
            "Removed Element": "hardware_abstraction_layer_function_gpio_toggle_pin",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n *\n * This function directly manipulates the RCC_AHB1ENR register to enable the clock for GPIOA.\n * It ensures that the GPIOA peripheral is powered and ready for use.\n *\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC_AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n    // Set the 0th bit of the RCC_AHB1ENR register to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n/**\n * @brief Writes a value to a specified GPIO pin by directly accessing\n * the Output Data Register (ODR) of the GPIO port. It calculates the pin position\n * using a loop to ensure the correct bit is set or cleared.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to write to (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin: 1 to set the pin high, 0 to set it low.\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Write the value to the pin by setting or clearing the corresponding bit in the ODR\n    if (value) {\n        // Set the pin high\n        *GPIO_ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *GPIO_ODR &= ~(1 << pin_position);\n    }\n}\n/**\n * @brief Sets a GPIO pin as either input or output.\n * \n * This function sets a GPIO pin as either input or output by modifying the\n * GPIO mode register (MODER). It uses direct register manipulation to ensure\n * atomic operations.\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Pointer to the GPIO MODER register\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Calculate the position in the MODER register (each pin uses 2 bits)\n    uint32_t moder_position = pin_position * 2;\n    // Clear the current mode for the pin (set both bits to 0)\n    *GPIO_MODER &= ~(0x3 << moder_position);\n    // Set the new mode for the pin\n    *GPIO_MODER |= (mode << moder_position);\n}\n/**\n * This function reads the state of a specified GPIO pin by directly accessing\n * the Input Data Register (IDR) of the GPIO port. It calculates the pin position\n * using a loop to ensure the correct bit is read.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to read (e.g., 1 << 5 for pin 5).\n * @return The state of the pin: 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Input Data Register (IDR)\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Read the pin state by checking the corresponding bit in the IDR\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function uses bitwise XOR operation to ensure atomic and reliable toggling\n * of the pin state. It calculates the pin position using a loop to ensure the correct\n * bit is toggled in the Output Data Register (ODR).\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    \n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    \n    // Toggle the pin state by XORing the corresponding bit in the ODR\n    *GPIO_ODR ^= (1 << pin_position);\n}\n\n"
        },
        {
            "unique_id": "c022c93c-6f89-415e-b257-f2c56f2ef796",
            "timestamp": "2024-10-31T08:19:06.557091",
            "total time (seconds)": 7.158822536468506,
            "compilation-success": true,
            "Similarity with Previous": 94.62474645030426,
            "Similarity with Original": 51.66051660516605,
            "Removed Element": "hardware_abstraction_layer_function_gpio_write_pin",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n *\n * This function directly manipulates the RCC_AHB1ENR register to enable the clock for GPIOA.\n * It ensures that the GPIOA peripheral is powered and ready for use.\n *\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC_AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n    // Set the 0th bit of the RCC_AHB1ENR register to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n/**\n * @brief Sets a GPIO pin as either input or output.\n * \n * This function sets a GPIO pin as either input or output by modifying the\n * GPIO mode register (MODER). It uses direct register manipulation to ensure\n * atomic operations.\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Pointer to the GPIO MODER register\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Calculate the position in the MODER register (each pin uses 2 bits)\n    uint32_t moder_position = pin_position * 2;\n    // Clear the current mode for the pin (set both bits to 0)\n    *GPIO_MODER &= ~(0x3 << moder_position);\n    // Set the new mode for the pin\n    *GPIO_MODER |= (mode << moder_position);\n}\n/**\n * This function reads the state of a specified GPIO pin by directly accessing\n * the Input Data Register (IDR) of the GPIO port. It calculates the pin position\n * using a loop to ensure the correct bit is read.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to read (e.g., 1 << 5 for pin 5).\n * @return The state of the pin: 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Input Data Register (IDR)\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Read the pin state by checking the corresponding bit in the IDR\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function uses bitwise XOR operation to ensure atomic and reliable toggling\n * of the pin state. It calculates the pin position using a loop to ensure the correct\n * bit is toggled in the Output Data Register (ODR).\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Toggle the pin state by XORing the corresponding bit in the ODR\n    *GPIO_ODR ^= (1 << pin_position);\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin on the STM32F407 board.\n * \n * This function directly manipulates the Output Data Register (ODR) of the GPIO port.\n * It calculates the pin position using a loop to ensure the correct bit is set or cleared.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to write to (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin: 1 to set the pin high, 0 to set it low.\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    \n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    \n    // Write the value to the pin by setting or clearing the corresponding bit in the ODR\n    if (value) {\n        // Set the pin high\n        *GPIO_ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *GPIO_ODR &= ~(1 << pin_position);\n    }\n}\n\n"
        },
        {
            "unique_id": "29dfb982-3204-409d-8e04-8a04472ddc31",
            "timestamp": "2024-10-31T08:19:31.714666",
            "total time (seconds)": 6.061757326126099,
            "compilation-success": true,
            "Similarity with Previous": 100.0,
            "Similarity with Original": 51.66051660516605,
            "Removed Element": "hardware_abstraction_layer_function_gpio_toggle_pin",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n *\n * This function directly manipulates the RCC_AHB1ENR register to enable the clock for GPIOA.\n * It ensures that the GPIOA peripheral is powered and ready for use.\n *\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC_AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n    // Set the 0th bit of the RCC_AHB1ENR register to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n/**\n * @brief Sets a GPIO pin as either input or output.\n * \n * This function sets a GPIO pin as either input or output by modifying the\n * GPIO mode register (MODER). It uses direct register manipulation to ensure\n * atomic operations.\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Pointer to the GPIO MODER register\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Calculate the position in the MODER register (each pin uses 2 bits)\n    uint32_t moder_position = pin_position * 2;\n    // Clear the current mode for the pin (set both bits to 0)\n    *GPIO_MODER &= ~(0x3 << moder_position);\n    // Set the new mode for the pin\n    *GPIO_MODER |= (mode << moder_position);\n}\n/**\n * This function reads the state of a specified GPIO pin by directly accessing\n * the Input Data Register (IDR) of the GPIO port. It calculates the pin position\n * using a loop to ensure the correct bit is read.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to read (e.g., 1 << 5 for pin 5).\n * @return The state of the pin: 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Input Data Register (IDR)\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Read the pin state by checking the corresponding bit in the IDR\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n/**\n * @brief Writes a value to a specific GPIO pin on the STM32F407 board.\n * \n * This function directly manipulates the Output Data Register (ODR) of the GPIO port.\n * It calculates the pin position using a loop to ensure the correct bit is set or cleared.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to write to (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin: 1 to set the pin high, 0 to set it low.\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Write the value to the pin by setting or clearing the corresponding bit in the ODR\n    if (value) {\n        // Set the pin high\n        *GPIO_ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *GPIO_ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function uses bitwise XOR operation to ensure atomic and reliable toggling\n * of the pin state. It calculates the pin position using a loop to ensure the correct\n * bit is toggled in the Output Data Register (ODR).\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    \n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    \n    // Toggle the pin state by XORing the corresponding bit in the ODR\n    *GPIO_ODR ^= (1 << pin_position);\n}\n\n"
        },
        {
            "unique_id": "bc0b9de4-0128-4c28-bcf5-4c7417694f3f",
            "timestamp": "2024-10-31T08:19:57.088913",
            "total time (seconds)": 7.028089761734009,
            "compilation-success": true,
            "Similarity with Previous": 92.81376518218623,
            "Similarity with Original": 51.698670605612996,
            "Removed Element": "hardware_abstraction_layer_function_gpio_toggle_pin",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n *\n * This function directly manipulates the RCC_AHB1ENR register to enable the clock for GPIOA.\n * It ensures that the GPIOA peripheral is powered and ready for use.\n *\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC_AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n    // Set the 0th bit of the RCC_AHB1ENR register to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n/**\n * @brief Sets a GPIO pin as either input or output.\n * \n * This function sets a GPIO pin as either input or output by modifying the\n * GPIO mode register (MODER). It uses direct register manipulation to ensure\n * atomic operations.\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Pointer to the GPIO MODER register\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Calculate the position in the MODER register (each pin uses 2 bits)\n    uint32_t moder_position = pin_position * 2;\n    // Clear the current mode for the pin (set both bits to 0)\n    *GPIO_MODER &= ~(0x3 << moder_position);\n    // Set the new mode for the pin\n    *GPIO_MODER |= (mode << moder_position);\n}\n/**\n * This function reads the state of a specified GPIO pin by directly accessing\n * the Input Data Register (IDR) of the GPIO port. It calculates the pin position\n * using a loop to ensure the correct bit is read.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to read (e.g., 1 << 5 for pin 5).\n * @return The state of the pin: 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Input Data Register (IDR)\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Read the pin state by checking the corresponding bit in the IDR\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n/**\n * @brief Writes a value to a specific GPIO pin on the STM32F407 board.\n * \n * This function directly manipulates the Output Data Register (ODR) of the GPIO port.\n * It calculates the pin position using a loop to ensure the correct bit is set or cleared.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to write to (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin: 1 to set the pin high, 0 to set it low.\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Write the value to the pin by setting or clearing the corresponding bit in the ODR\n    if (value) {\n        // Set the pin high\n        *GPIO_ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *GPIO_ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * This function toggles the state of a specified GPIO pin by directly accessing\n * the Output Data Register (ODR) of the GPIO port. It calculates the pin position\n * using a loop to ensure the correct bit is toggled.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    \n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    \n    // Toggle the pin state by XORing the corresponding bit in the ODR\n    *GPIO_ODR ^= (1 << pin_position);\n}\n\n"
        },
        {
            "unique_id": "1451522e-d6a7-43dd-8727-826a27df959b",
            "timestamp": "2024-10-31T08:20:21.667271",
            "total time (seconds)": 5.202683925628662,
            "compilation-success": true,
            "Similarity with Previous": 92.35412474849095,
            "Similarity with Original": 53.88679245283019,
            "Removed Element": "ENABLE_GPIOA_CLOCK",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\n/**\n * @brief Sets a GPIO pin as either input or output.\n * \n * This function sets a GPIO pin as either input or output by modifying the\n * GPIO mode register (MODER). It uses direct register manipulation to ensure\n * atomic operations.\n * \n * @param gpio_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin (e.g., 1 << 5 for pin 5).\n * @param mode The mode to set: 0 for input, 1 for output.\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Pointer to the GPIO MODER register\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Calculate the position in the MODER register (each pin uses 2 bits)\n    uint32_t moder_position = pin_position * 2;\n    // Clear the current mode for the pin (set both bits to 0)\n    *GPIO_MODER &= ~(0x3 << moder_position);\n    // Set the new mode for the pin\n    *GPIO_MODER |= (mode << moder_position);\n}\n/**\n * This function reads the state of a specified GPIO pin by directly accessing\n * the Input Data Register (IDR) of the GPIO port. It calculates the pin position\n * using a loop to ensure the correct bit is read.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to read (e.g., 1 << 5 for pin 5).\n * @return The state of the pin: 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Input Data Register (IDR)\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Read the pin state by checking the corresponding bit in the IDR\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n/**\n * @brief Writes a value to a specific GPIO pin on the STM32F407 board.\n * \n * This function directly manipulates the Output Data Register (ODR) of the GPIO port.\n * It calculates the pin position using a loop to ensure the correct bit is set or cleared.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to write to (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin: 1 to set the pin high, 0 to set it low.\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Write the value to the pin by setting or clearing the corresponding bit in the ODR\n    if (value) {\n        // Set the pin high\n        *GPIO_ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *GPIO_ODR &= ~(1 << pin_position);\n    }\n}\n/**\n * This function toggles the state of a specified GPIO pin by directly accessing\n * the Output Data Register (ODR) of the GPIO port. It calculates the pin position\n * using a loop to ensure the correct bit is toggled.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask A bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n * @return None\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Toggle the pin state by XORing the corresponding bit in the ODR\n    *GPIO_ODR ^= (1 << pin_position);\n}\n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Base address for the RCC (Reset and Clock Control)\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Set the bit 0 in RCC_AHB1ENR to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n"
        },
        {
            "unique_id": "aeadb858-5946-4909-8a49-1bf387532e30",
            "timestamp": "2024-11-19T07:11:26.295405",
            "total time (seconds)": 13.503571033477783,
            "compilation-success": false,
            "Similarity with Previous": 36.952714535901926,
            "Similarity with Original": 53.15515961395694,
            "Removed Element": "hardware_abstraction_layer_function_gpio_write_pin",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference\n// manual for the STM32F407, which specifies the offset for the DR register\n// within the USART peripheral's register map.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC (Reset and Clock Control) block.\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock for AHB1 peripherals.\n// The value is specific to the STM32F407 microcontroller.\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral\n// This offset is used to calculate the address of the BRR register for a given USART instance\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is specific to the STM32F407 microcontroller series.\n#define USART_SR_OFFSET ((uint32_t)0x00000000)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the USART transmit data register is empty\n// and ready to accept new data for transmission. It is a bit mask used in\n// status register checks.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC (Reset and Clock Control) block.\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock for AHB1 peripherals.\n// The value is specific to the STM32F407 microcontroller.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the clock is enabled by setting\n * the appropriate bit in the RCC_AHB1ENR register.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC and the offset for the AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n    // Set the bit 0 of RCC_AHB1ENR to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position from the pin mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n    // Set the mode for the pin\n    if (mode == 1) {\n        // Set as output\n        *GPIO_MODER |= (0x1 << (pin_position * 2));\n    } else {\n        // Set as input (default is already cleared)\n    }\n}\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin by accessing the input data register (IDR)\n * of the specified GPIO port. It calculates the bit position of the pin using a loop\n * to ensure accurate pin configuration.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask representing the pin to read (e.g., 1 << 5 for pin 5).\n * \n * @return 1 if the pin is set (high), 0 if the pin is reset (low).\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Pointer to the input data register (IDR) of the specified GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    // Calculate the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Read the pin state from the IDR and return it\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It uses bitwise operations to ensure atomic\n * and reliable toggling of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Toggle the pin by XORing the ODR with the pin mask\n    *ODR ^= pin_mask;\n}\n\n/**\n * @brief Writes a specified value to a GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or clear a specific pin. It uses bitwise operations to ensure atomic\n * and reliable setting of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n"
        },
        {
            "unique_id": "ac7e6ba8-b663-403a-aba5-800547618185",
            "timestamp": "2024-11-19T07:12:17.474005",
            "total time (seconds)": 6.2601189613342285,
            "compilation-success": true,
            "Similarity with Previous": 100.0,
            "Similarity with Original": 53.11572700296736,
            "Removed Element": "hardware_abstraction_layer_function_gpio_toggle_pin",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference\n// manual for the STM32F407, which specifies the offset for the DR register\n// within the USART peripheral's register map.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC (Reset and Clock Control) block.\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock for AHB1 peripherals.\n// The value is specific to the STM32F407 microcontroller.\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral\n// This offset is used to calculate the address of the BRR register for a given USART instance\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is specific to the STM32F407 microcontroller series.\n#define USART_SR_OFFSET ((uint32_t)0x00000000)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the USART transmit data register is empty\n// and ready to accept new data for transmission. It is a bit mask used in\n// status register checks.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC (Reset and Clock Control) block.\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock for AHB1 peripherals.\n// The value is specific to the STM32F407 microcontroller.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position from the pin mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n    // Set the mode for the pin\n    if (mode == 1) {\n        // Set as output\n        *GPIO_MODER |= (0x1 << (pin_position * 2));\n    } else {\n        // Set as input (default is already cleared)\n    }\n}\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin by accessing the input data register (IDR)\n * of the specified GPIO port. It calculates the bit position of the pin using a loop\n * to ensure accurate pin configuration.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask representing the pin to read (e.g., 1 << 5 for pin 5).\n * \n * @return 1 if the pin is set (high), 0 if the pin is reset (low).\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Pointer to the input data register (IDR) of the specified GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    // Calculate the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Read the pin state from the IDR and return it\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n/**\n * @brief Writes a specified value to a GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or clear a specific pin. It uses bitwise operations to ensure atomic\n * and reliable setting of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the clock is enabled by setting\n * the appropriate bit in the RCC_AHB1ENR register.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC and the offset for the AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n    // Set the bit 0 of RCC_AHB1ENR to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It uses bitwise operations to ensure atomic\n * and reliable toggling of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n    \n    // Toggle the pin by XORing the ODR with the pin mask\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "8c163acf-f1df-4c6c-8b41-d83a44d6ce5a",
            "timestamp": "2024-11-19T08:38:31.595523",
            "total time (seconds)": 11.01417589187622,
            "compilation-success": true,
            "Similarity with Previous": 59.09451945988881,
            "Similarity with Original": 66.63755458515284,
            "Removed Element": "hardware_abstraction_layer_function_gpio_toggle_pin",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for peripherals connected to the AHB1 bus on the STM32F407 microcontroller.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x08)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the USART transmit data register is empty\n// and ready to accept new data for transmission. The value is based on the\n// STM32F407 reference manual, where the TXE flag is typically bit 7 in the\n// USART status register (SR).\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference\n// manual for the STM32F407, which specifies the offset for the DR register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the clock is enabled by setting\n * the appropriate bit in the RCC_AHB1ENR register.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC and the offset for the AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n    // Set the bit 0 of RCC_AHB1ENR to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n    // Set the mode: 0x1 for output, 0x0 for input\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin specified by the port base address and pin mask.\n * It calculates the pin position and checks the input data register (IDR) to determine if the pin is high or low.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Pointer to the input data register (IDR) of the specified GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    // Calculate the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Read the pin state from the IDR and return 1 if high, 0 if low\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n *\n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations using bitwise\n * XOR to flip the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Toggle the specified pin using XOR operation\n    *GPIO_ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "297d2175-b582-4bfe-ada3-6570349c8f27",
            "timestamp": "2024-11-19T08:39:09.660297",
            "total time (seconds)": 9.697561502456665,
            "compilation-success": true,
            "Similarity with Previous": 100.0,
            "Similarity with Original": 66.63755458515284,
            "Removed Element": "hardware_abstraction_layer_function_gpio_toggle_pin",
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for peripherals connected to the AHB1 bus on the STM32F407 microcontroller.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x08)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the USART transmit data register is empty\n// and ready to accept new data for transmission. The value is based on the\n// STM32F407 reference manual, where the TXE flag is typically bit 7 in the\n// USART status register (SR).\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference\n// manual for the STM32F407, which specifies the offset for the DR register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the clock is enabled by setting\n * the appropriate bit in the RCC_AHB1ENR register.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC and the offset for the AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n    // Set the bit 0 of RCC_AHB1ENR to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n    // Set the mode: 0x1 for output, 0x0 for input\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin specified by the port base address and pin mask.\n * It calculates the pin position and checks the input data register (IDR) to determine if the pin is high or low.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Pointer to the input data register (IDR) of the specified GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n    // Calculate the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n    // Read the pin state from the IDR and return 1 if high, 0 if low\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n *\n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations using bitwise\n * XOR to flip the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n    // Toggle the specified pin using XOR operation\n    *GPIO_ODR ^= pin_mask;\n}\n\n"
        }
    ]
}