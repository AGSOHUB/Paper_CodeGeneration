{
    "test_data_3_2": [
        {
            "unique_id": "66bbbf6e-bda3-441c-baeb-b86147197506",
            "timestamp": "2024-10-08T19:53:23.654821",
            "total time (seconds)": 3.2608368396759033,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": 0
        },
        {
            "unique_id": "7213ec59-84a8-4c05-9701-88a1022b6c3a",
            "timestamp": "2024-10-08T19:56:56.370853",
            "total time (seconds)": 2.4268815517425537,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// RCC_BASE is the base address for the Reset and Clock Control (RCC) registers\n// on the STM32F407 microcontroller. This address is used to access the RCC\n// registers for configuring the clock system of the microcontroller.\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral\n// This offset is used to calculate the address of the BRR register for a given USART instance\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC (Reset and Clock Control) module.\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock for AHB1 peripherals.\n// The value is specific to the STM32F407 microcontroller.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n#define GPIOA_BASE ((uint32_t)0x40020000) // Base address for GPIOA peripheral on STM32F407 board\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is specific to the STM32F407\n// and is used in conjunction with the base address of a USART peripheral\n// to read from or write to the data register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready to accept new data for transmission. It is a part of the USART\n// status register (USART_SR) and is typically used in USART communication\n// to check if the transmitter is ready to send the next byte of data.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. This is necessary before any GPIOA operations can be performed.\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC (Reset and Clock Control)\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(RCC_BASE + RCC_AHB1ENR_OFFSET);\n\n    // Enable the clock for GPIOA by setting the 0th bit in the RCC AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n/**\n * @brief Configures a GPIO pin as input or output.\n * \n * This function sets the mode of a specific GPIO pin on a given GPIO port.\n * \n * @param gpio_base: Base address of the GPIO port (e.g., GPIOA_BASE).\n * @param pin_mask: Bitmask representing the pin to configure (e.g., 1 << 5 for pin 5).\n * @param mode: Mode to set for the pin (0 for input, 1 for output).\n */\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin number from the pin mask\n    uint8_t pin_number = 0;\n    while ((pin_mask >> pin_number) != 1) {\n        pin_number++;\n    }\n\n    // Calculate the address of the GPIO mode register\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin number\n    *GPIO_MODER &= ~(0x3 << (pin_number * 2));\n\n    // Set the mode for the pin (0x1 for output, 0x0 for input)\n    *GPIO_MODER |= (mode << (pin_number * 2));\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_base: Base address of the GPIO port (e.g., GPIOA_BASE).\n * @param pin_mask: Bitmask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value: Value to write to the pin (0 for LOW, 1 for HIGH).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_base, uint16_t pin_mask, uint8_t value) {\n    // Pointer to the Output Data Register (ODR) of the specified GPIO port\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_base + 0x14); // ODR offset is 0x14\n\n    if (value) {\n        // Set the pin: Use bitwise OR to set the specific pin bit\n        *GPIO_ODR |= pin_mask;\n    } else {\n        // Reset the pin: Use bitwise AND with NOT to clear the specific pin bit\n        *GPIO_ODR &= ~pin_mask;\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin by accessing the input data register (IDR)\n * of the specified GPIO port. It determines the bit position of the pin using a loop\n * and checks if the pin is set to high or low.\n * \n * @param gpio_base: Base address of the GPIO port (e.g., GPIOA_BASE).\n * @param pin_mask: Bit mask representing the pin (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_base, uint32_t pin_mask) {\n    // Pointer to the input data register (IDR) of the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_base + 0x10); // IDR offset is 0x10\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the pin state from the IDR\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of the specified GPIO port\n * to toggle the state of a given pin. It uses bitwise operations to ensure atomic and reliable\n * toggling of the pin state.\n * \n * @param gpio_base: The base address of the GPIO port (e.g., GPIOA_BASE).\n * @param pin_mask: The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the specified GPIO port\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_base + 0x14); // ODR offset is 0x14\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *GPIO_ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "e2c220c4-614a-46df-a85b-a06a3999c1f6",
            "timestamp": "2024-10-09T10:10:18.388261",
            "total time (seconds)": 4.01520848274231,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready to accept new data for transmission. It is a part of the USART\n// status register (USART_SR) and is typically used in USART communication\n// to check if the transmitter is ready to send the next byte.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference\n// manual for the STM32F407, which specifies the offset for the DR register\n// within the USART peripheral's register map.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC (Reset and Clock Control) block.\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock for AHB1 peripherals.\n// The offset value is based on the STM32F407 reference manual.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// For the STM32F407, the USART status register offset is 0x00.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x08)\n\n#define RCC_BASE ((uint32_t)0x40023800) // Base address for the Reset and Clock Control (RCC) registers on the STM32F407 board\n\n// USART_CR1_OFFSET is the offset for the Control Register 1 of the USART peripheral.\n// This offset is used to access the USART_CR1 register from the base address of a USART peripheral.\n// The value is specific to the STM32F407 microcontroller series.\n#define USART_CR1_OFFSET ((uint32_t)0x0000000C)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Enable the clock for GPIOA by setting the appropriate bit in the RCC AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n\n    // Set the mode: 0x1 for output, 0x0 for input\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *GPIO_ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *GPIO_ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin by accessing the input data register (IDR)\n * of the specified GPIO port. It uses bitwise operations to determine the state of the pin.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to read (e.g., 1 << 5 for pin 5).\n * \n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the position of the pin by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask & 1) == 0) {\n        pin_mask >>= 1;\n        pin_position++;\n    }\n\n    // Define a pointer to the input data register (IDR) of the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n\n    // Read the state of the pin by checking the corresponding bit in the IDR\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations using bitwise XOR.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "810778be-5cad-464d-9604-deeba282cb85",
            "timestamp": "2024-10-09T10:15:21.279544",
            "total time (seconds)": 4.0512659549713135,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n// on the STM32F407 microcontroller. This address is used to access\n// the RCC registers for configuring the clock system of the MCU.\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// USART_FLAG_TXE is a flag used to indicate that the USART transmit data register is empty.\n// This flag is typically used in USART status register to check if the USART is ready to send more data.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the offset for the USART_SR register.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference manual\n// which specifies the memory map of the USART registers.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_CR1_OFFSET is the offset for the Control Register 1 of the USART peripheral.\n// This offset is used to access the USART_CR1 register from the base address of a USART peripheral.\n// The value is specific to the STM32F407 microcontroller series.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a specific USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the offset for the BRR register.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the clock is enabled by setting\n * the appropriate bit in the RCC_AHB1ENR register.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC and the offset for the AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Set the bit 0 of RCC_AHB1ENR to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n\n    // Set the mode: 0x1 for output, 0x0 for input\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin specified by the port base address and pin mask.\n * It calculates the pin position and checks the input data register (IDR) to determine if the pin is high or low.\n * \n * @param port_base_address The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t port_base_address, uint32_t pin_mask) {\n    // Pointer to the input data register (IDR) of the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(port_base_address + 0x10);\n\n    // Calculate the pin position by finding the first set bit in the pin mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the pin state from the IDR and return 1 if high, 0 if low\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations using bitwise XOR.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the specified pin using XOR operation\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "7805f98e-2037-48b5-a431-4157fec4bda1",
            "timestamp": "2024-10-09T10:17:14.587277",
            "total time (seconds)": 100.12589144706726,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready to accept new data for transmission. It is a part of the USART\n// status register (USART_SR) and is typically used in USART communication\n// to check if the transmitter is ready to send more data.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the offset for the Status Register (SR) of the USART peripheral.\n// This offset is used to access the USART_SR register from the base address of a USART peripheral.\n// The value is based on the STM32F407 reference manual, where the USART_SR register is located\n// at an offset of 0x00 from the base address of the USART peripheral.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference manual.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the offset for the BRR register.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 microcontroller.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Enable the clock for GPIOA by setting the appropriate bit in the RCC AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n\n    // Set the mode: 0x1 for output, 0x0 for input\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin specified by the port base address and pin mask.\n * It calculates the pin position and checks the input data register (IDR) to determine if the pin is high or low.\n * \n * @param port_base_address The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t port_base_address, uint32_t pin_mask) {\n    // Calculate the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask & 1) == 0) {\n        pin_mask >>= 1;\n        pin_position++;\n    }\n\n    // Define the input data register (IDR) offset for the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(port_base_address + 0x10);\n\n    // Read the pin state from the IDR and return 1 if high, 0 if low\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It uses bitwise operations to ensure atomic\n * and reliable toggling of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "9cf318c6-f974-4bbf-bcc3-7ee33dcec865",
            "timestamp": "2024-10-09T10:25:28.317889",
            "total time (seconds)": 4.444570064544678,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference manual\n// which specifies the offset for the USART_DR register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral\n// This offset is used to calculate the address of the BRR register for a given USART instance\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the offset for the USART_SR register.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC (Reset and Clock Control) block.\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock for AHB1 peripherals.\n// The value is specific to the STM32F407 microcontroller.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// USART_FLAG_TXE is a flag used to indicate that the USART transmit data register is empty.\n// This flag is typically used in USART status register (USART_SR) to check if the USART is ready to send more data.\n// The value 0x0080 corresponds to the TXE (Transmit Data Register Empty) bit in the USART status register.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the clock is enabled by setting\n * the appropriate bit in the RCC_AHB1ENR register.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC and the offset for the AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Set the bit 0 of RCC_AHB1ENR to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin number from the pin mask\n    uint8_t pin_number = 0;\n    while ((pin_mask >> pin_number) != 1) {\n        pin_number++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin in the MODER register\n    *GPIO_MODER &= ~(0x3 << (pin_number * 2));\n\n    // Set the mode for the pin (0x1 for output, 0x0 for input)\n    *GPIO_MODER |= (mode << (pin_number * 2));\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin by accessing the input data register (IDR)\n * of the specified GPIO port. It uses bitwise operations to determine the state of the pin.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the input data register (IDR) for the given GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the state of the pin from the IDR and return it\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations using bitwise XOR.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the specified pin using XOR operation\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "e9403036-1609-4586-8729-c48a7744ef64",
            "timestamp": "2024-10-09T10:27:23.043381",
            "total time (seconds)": 99.0413966178894,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference\n// manual for the STM32F407, which specifies the offset for the DR register\n// within the USART peripheral's register map.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, where the BRR register is located\n// at an offset of 0x08 from the base address of the USART peripheral.\n#define USART_BRR_OFFSET ((uint32_t)0x08)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the offset for the USART_SR register.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// The RCC_AHB1ENR register is used to enable the clock for peripherals connected to the AHB1 bus.\n// The offset is based on the STM32F407 reference manual, which specifies the location of this register.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// USART_FLAG_TXE is a flag flag used to indicate that the transmit data register is empty.\n// This flag is used in USART communication to check if the USART is ready to send more data.\n// The value is based on the STM32F407 reference manual, where the TXE flag is typically bit 7 in the USART status register.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// RCC_BASE is the base address for the Reset and Clock Control (RCC) registers\n// on the STM32F407 microcontroller. This address is used to access the RCC\n// registers for configuring the clock system of the microcontroller.\n#define RCC_BASE ((uint32_t)0x40023800)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Enable the clock for GPIOA by setting the appropriate bit in the RCC AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n\n    // Set the mode: 0x1 for output, 0x0 for input\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin by accessing the input data register (IDR)\n * of the specified GPIO port. It calculates the bit position of the pin using a loop\n * to ensure accurate pin configuration.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Pointer to the input data register (IDR) of the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n\n    // Calculate the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the pin state from the IDR and return it\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It uses bitwise operations to ensure atomic\n * and reliable toggling of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "c3549295-2251-45c9-bde8-8704f2ff885a",
            "timestamp": "2024-10-09T10:29:25.622957",
            "total time (seconds)": 104.72539138793945,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference\n// manual for the STM32F407, which specifies the offset for the DR register\n// within the USART peripheral's register map.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a specific USART instance.\n// The value is based on the STM32F407 reference manual, where the BRR register is located\n// at an offset of 0x08 from the base address of the USART peripheral.\n#define USART_BRR_OFFSET ((uint32_t)0x08)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the offset for the USART_SR register.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC (Reset and Clock Control) block.\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock for AHB1 peripherals.\n// The offset value is based on the STM32F407 reference manual.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The USART_CR1 register is responsible for configuring various aspects of the USART peripheral,\n// such as enabling the USART, setting the word length, parity control, and more.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Enable the clock for GPIOA by setting the 0th bit of the RCC_AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin number from the pin mask\n    uint8_t pin_number = 0;\n    for (uint32_t mask = pin_mask; mask > 1; mask >>= 1) {\n        pin_number++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin in the MODER register\n    *GPIO_MODER &= ~(0x3 << (pin_number * 2));\n\n    // Set the mode for the pin (0x1 for output, 0x0 for input)\n    *GPIO_MODER |= (mode << (pin_number * 2));\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin by accessing the input data register (IDR)\n * of the specified GPIO port. It uses bitwise operations to determine the state of the pin.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the position of the pin by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Define a pointer to the input data register (IDR) of the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n\n    // Read the state of the pin by checking the corresponding bit in the IDR\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations using bitwise\n * XOR to flip the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "c55ab445-b38c-438b-8f1f-7cc76ca1a473",
            "timestamp": "2024-10-09T10:31:47.444658",
            "total time (seconds)": 126.38981199264526,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// USART_DR_OFFSET is the offset for the Data Register in the USART peripheral.\n// This offset is used to access the data register for reading or writing data.\n// The value is specific to the STM32F407 microcontroller series.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x08)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the offset for the USART_SR register.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// The RCC_AHB1ENR register is used to enable the clock for peripherals connected to the AHB1 bus.\n// The offset is based on the STM32F407 reference manual, where the RCC base address is 0x40023800\n// and the AHB1ENR register is located at an offset of 0x30 from the RCC base address.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// USART_FLAG_TXE is a flag used to indicate that the USART transmit data register is empty.\n// This flag is typically used in USART status register to check if the USART is ready to send more data.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n#define RCC_BASE ((uint32_t)0x40023800) // Base address for the Reset and Clock Control (RCC) registers on the STM32F407 board\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the clock is enabled by setting\n * the appropriate bit in the register.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Set the bit corresponding to GPIOA (bit 0) to enable its clock\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin number from the pin mask\n    uint8_t pin_number = 0;\n    while ((pin_mask >> pin_number) != 1) {\n        pin_number++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin in the MODER register\n    *GPIO_MODER &= ~(0x3 << (pin_number * 2));\n\n    // Set the mode for the pin\n    if (mode == 1) {\n        // Set as output\n        *GPIO_MODER |= (0x1 << (pin_number * 2));\n    } else {\n        // Set as input (default is 0, so no need to set)\n    }\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin from a specified GPIO port.\n * It uses direct register access to ensure atomic operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Pointer to the input data register (IDR) of the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n\n    // Calculate the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the pin state from the IDR and return it\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations using bitwise XOR.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the specified pin using XOR operation\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "ba3c2b76-b4d4-4d62-a8b0-66723c238aad",
            "timestamp": "2024-10-09T10:33:43.558610",
            "total time (seconds)": 100.85649824142456,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// USART_DR_OFFSET is the offset for the Data Register in the USART peripheral.\n// This offset is used to access the data register for reading or writing data.\n// The value is specific to the STM32F407 microcontroller series.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral\n// The USART_BRR_OFFSET is used to calculate the address of the BRR register\n// within the USART peripheral's memory map. This offset is specific to the\n// STM32F407 microcontroller series.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// USART_FLAG_TXE is a flag used to indicate that the USART transmit data register is empty.\n// This flag is typically used in USART status register (USART_SR) to check if the USART is ready to send more data.\n// The value 0x0080 corresponds to the bit position of the TXE flag in the USART status register.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n// on the STM32F407 microcontroller. This address is used to access\n// the RCC registers for configuring the clock system of the MCU.\n#define RCC_BASE ((uint32_t)0x40023800)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the clock is enabled by setting\n * the appropriate bit in the RCC_AHB1ENR register.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC and the offset for the AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Set the bit 0 of RCC_AHB1ENR to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n\n    // Set the mode: 0x1 for output, 0x0 for input\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin by accessing the input data register (IDR)\n * of the specified GPIO port. It calculates the bit position of the pin using a loop\n * to ensure accurate pin configuration.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Pointer to the input data register (IDR) of the specified GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n\n    // Calculate the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the pin state from the IDR and return it\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations using bitwise XOR.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "69420e51-f16d-415f-a907-d0ef4d4287b4",
            "timestamp": "2024-10-09T10:35:38.655537",
            "total time (seconds)": 99.83129906654358,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// USART_DR_OFFSET is the offset for the Data Register in the USART peripheral.\n// This offset is used to access the data register for reading or writing data.\n// The value is specific to the STM32F407 microcontroller series.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, where the BRR register is located\n// at an offset of 0x08 from the base address of the USART peripheral.\n#define USART_BRR_OFFSET ((uint32_t)0x08)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the offset for the USART_SR register.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 microcontroller.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The USART_CR1 register is responsible for configuring various aspects of the USART peripheral,\n// such as enabling the USART, setting the word length, parity control, and more.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// USART_FLAG_TXE is a flag used to indicate that the USART transmit data register is empty.\n// This flag is typically used in USART status register to check if the USART is ready to send more data.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n// on the STM32F407 microcontroller. This address is used to access\n// the RCC registers for configuring the clock system of the MCU.\n#define RCC_BASE ((uint32_t)0x40023800)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Enable the clock for GPIOA by setting the appropriate bit in the RCC AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n\n    // Set the mode for the pin\n    if (mode == 1) {\n        // Set as output\n        *GPIO_MODER |= (0x1 << (pin_position * 2));\n    } else {\n        // Set as input (default is already cleared)\n    }\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin specified by the port base address and pin mask.\n * It calculates the pin position and checks the input data register (IDR) to determine if the pin is high or low.\n * \n * @param port_base_address The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t port_base_address, uint32_t pin_mask) {\n    // Calculate the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Define a pointer to the input data register (IDR) of the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(port_base_address + 0x10);\n\n    // Read the IDR and check if the specific pin is set\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations using bitwise XOR.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the specified pin using XOR operation\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "b40c8391-ccc3-46f3-b36d-168d2a31d579",
            "timestamp": "2024-10-09T10:37:35.936705",
            "total time (seconds)": 101.78820872306824,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference\n// manual for the STM32F407, which specifies the offset for the DR register\n// within the USART peripheral's register map.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is based on the STM32F407 reference manual.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// The RCC_AHB1ENR register is used to enable the clock for peripherals connected to the AHB1 bus.\n// The offset is based on the STM32F407 reference manual, which specifies the memory map for the RCC registers.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready to accept new data for transmission. It is a part of the USART\n// status register (USART_SR) and is typically used in USART communication\n// to check if the transmitter is ready to send more data.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// RCC_BASE is the base address for the Reset and Clock Control (RCC) registers\n// on the STM32F407 microcontroller. This address is used to access the RCC\n// registers for configuring the clock system of the microcontroller.\n#define RCC_BASE ((uint32_t)0x40023800)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the clock is enabled by setting\n * the appropriate bit in the RCC_AHB1ENR register.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC and the offset for the AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Set the bit 0 of RCC_AHB1ENR to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin number from the pin mask\n    uint8_t pin_number = 0;\n    while ((pin_mask >> pin_number) != 1) {\n        pin_number++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin in the MODER register\n    *GPIO_MODER &= ~(0x3 << (pin_number * 2));\n\n    // Set the mode for the pin\n    if (mode == 1) {\n        // Set as output\n        *GPIO_MODER |= (0x1 << (pin_number * 2));\n    } else {\n        // Set as input (default is already cleared)\n    }\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 to reset, 1 to set).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14); // ODR offset is 0x14\n\n    if (value) {\n        // Set the pin: Use bitwise OR to set the specific pin bit\n        *ODR |= pin_mask;\n    } else {\n        // Reset the pin: Use bitwise AND with NOT to clear the specific pin bit\n        *ODR &= ~pin_mask;\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin by accessing the input data register (IDR)\n * of the specified GPIO port. It calculates the bit position of the pin using a loop\n * to ensure accurate pin configuration.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask representing the pin to read (e.g., 1 << 5 for pin 5).\n * \n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Pointer to the input data register (IDR) of the specified GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n\n    // Calculate the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the pin state from the IDR and return it\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of the specified GPIO port\n * to toggle the state of a given pin. It ensures atomic operations using bitwise XOR.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the specified pin using XOR operation\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "1c506fb1-2ace-4d9c-be23-90d41eb449a8",
            "timestamp": "2024-10-09T10:39:30.842887",
            "total time (seconds)": 99.59565806388855,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// USART_DR_OFFSET is the offset for the Data Register in the USART peripheral.\n// This offset is used to access the data register for reading or writing data.\n// The value is specific to the STM32F407 microcontroller series.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral\n// This offset is used to calculate the address of the BRR register for a given USART instance\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is specific to the STM32F407 microcontroller series.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// USART_FLAG_TXE is a flag used to indicate that the USART transmit data register is empty.\n// This flag is typically used in USART status register to check if the USART is ready to send more data.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// RCC_BASE is the base address for the Reset and Clock Control (RCC) registers\n// on the STM32F407 microcontroller. This address is used to access the RCC\n// registers for configuring the clock system of the microcontroller.\n#define RCC_BASE ((uint32_t)0x40023800)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Enable the clock for GPIOA by setting the appropriate bit in the RCC AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin number from the pin mask\n    uint8_t pin_number = 0;\n    while ((pin_mask >> pin_number) != 1) {\n        pin_number++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin in the MODER register\n    *GPIO_MODER &= ~(0x3 << (pin_number * 2));\n\n    // Set the mode for the pin\n    // 0x1 for output mode, 0x0 for input mode\n    *GPIO_MODER |= (mode << (pin_number * 2));\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin by accessing the input data register (IDR)\n * of the specified GPIO port. It uses bitwise operations to determine the state of the pin.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Pointer to the input data register (IDR) of the specified GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the state of the pin by checking the corresponding bit in the IDR\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It uses bitwise operations to ensure atomic\n * and reliable toggling of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "a823bac2-531a-4429-b0ff-03d7ac59d20b",
            "timestamp": "2024-10-09T10:41:15.605001",
            "total time (seconds)": 89.57611298561096,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// USART_DR_OFFSET is the offset for the Data Register in the USART peripheral.\n// This offset is used to access the data register for reading or writing data.\n// The value is specific to the STM32F407 microcontroller series.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral\n// This offset is used to calculate the address of the BRR register for a given USART instance\n// on the STM32F407 microcontroller. The value is based on the reference manual for the STM32F407.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the clock is enabled by setting\n * the appropriate bit in the RCC_AHB1ENR register.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC and the offset for the AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Set the bit 0 of RCC_AHB1ENR to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position from the pin mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n\n    // Set the mode for the pin\n    if (mode == 1) {\n        // Set as output\n        *GPIO_MODER |= (0x1 << (pin_position * 2));\n    } else {\n        // Set as input (default is already 0, so no need to set)\n    }\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin by accessing the input data register (IDR)\n * of the specified GPIO port. It uses bitwise operations to determine the state of the pin.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the input data register (IDR) for the given GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the state of the pin by checking the corresponding bit in the IDR\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It uses bitwise operations to ensure atomic\n * and reliable toggling of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "6b64837e-1f6b-4ca6-96a3-3246a4e0b41d",
            "timestamp": "2024-10-09T10:42:55.864831",
            "total time (seconds)": 84.77945685386658,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference manual.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, where the BRR register is located\n// at an offset of 0x08 from the base address of the USART peripheral.\n#define USART_BRR_OFFSET ((uint32_t)0x08)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the offset for the USART_SR register.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The USART_CR1 register is responsible for configuring various aspects of the USART peripheral,\n// such as enabling the USART, setting the word length, parity control, and more.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// USART_FLAG_TXE is a flag used to indicate that the USART transmit data register is empty.\n// This flag is typically used in USART status register (USART_SR) to check if the USART is ready to send more data.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n#define RCC_BASE ((uint32_t)0x40023800) // Base address for the Reset and Clock Control (RCC) registers on the STM32F407 board\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the clock is enabled by setting\n * the appropriate bit in the RCC_AHB1ENR register.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC and the offset for the AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Set the bit 0 of RCC_AHB1ENR to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position from the pin mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n\n    // Set the mode for the pin\n    if (mode == 1) {\n        // Set as output\n        *GPIO_MODER |= (0x1 << (pin_position * 2));\n    } else {\n        // Set as input (default is already cleared)\n    }\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin by accessing the input data register (IDR)\n * of the specified GPIO port. It calculates the bit position of the pin using a loop\n * to ensure accurate pin configuration.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask representing the pin to read (e.g., 1 << 5 for pin 5).\n * \n * @return 1 if the pin is set (high), 0 if the pin is reset (low).\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Pointer to the input data register (IDR) of the specified GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n\n    // Calculate the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the pin state from the IDR and return it\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It uses bitwise operations to ensure atomic\n * and reliable toggling of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "6b724ea0-e60b-478f-be05-b71405c87378",
            "timestamp": "2024-10-11T13:06:57.415536",
            "total time (seconds)": 3.44667387008667,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference manual\n// for the STM32F407, which specifies the offset for the USART_DR register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x08)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// The RCC_AHB1ENR register is used to enable the clock for peripherals connected to the AHB1 bus.\n// The offset is based on the STM32F407 reference manual, which specifies the memory map for the RCC registers.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n#define RCC_BASE ((uint32_t)0x40023800) // Base address for the Reset and Clock Control (RCC) registers on the STM32F407 board\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the USART transmit data register is empty\n// and ready to accept new data for transmission. It is a bit mask used in\n// status register checks.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the offset for the USART_SR register.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC and the offset for the AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Set the bit corresponding to GPIOA (bit 0) to enable its clock\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - port_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t port_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin number from the pin mask\n    uint8_t pin_number = 0;\n    for (uint32_t mask = pin_mask; mask > 1; mask >>= 1) {\n        pin_number++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(port_base + 0x00);\n\n    // Clear the two bits corresponding to the pin in the MODER register\n    *GPIO_MODER &= ~(0x3 << (pin_number * 2));\n\n    // Set the mode for the pin (0x1 for output, 0x0 for input)\n    *GPIO_MODER |= (mode << (pin_number * 2));\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin specified by the port base address and pin mask.\n * It calculates the pin position and checks the input data register (IDR) to determine if the pin is high or low.\n * \n * @param port_base_address The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t port_base_address, uint32_t pin_mask) {\n    // Calculate the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask & 1) == 0) {\n        pin_mask >>= 1;\n        pin_position++;\n    }\n\n    // Define the input data register (IDR) offset for the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(port_base_address + 0x10);\n\n    // Read the pin state from the IDR and return 1 if high, 0 if low\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It uses bitwise operations to ensure atomic\n * and reliable toggling of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the specified pin by XORing the ODR with the pin mask\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "f30aee84-c53b-4631-81bc-f34759f2f060",
            "timestamp": "2024-10-11T13:08:40.246762",
            "total time (seconds)": 64.34353470802307,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference\n// manual for the STM32F407, which specifies the offset for the DR register\n// within the USART peripheral's register map.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_BRR_OFFSET is the offset for the Baud Rate Register in the USART peripheral.\n// This offset is used to calculate the address of the Baud Rate Register for a specific USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n// on the STM32F407 microcontroller. This address is used to access\n// the RCC registers for configuring the clock system of the MCU.\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready to accept new data for transmission. It is a part of the USART\n// status register (USART_SR) and is typically used in USART communication\n// to check if the transmitter is ready to send the next byte of data.\n// The value 0x0080 corresponds to the TXE flag position in the USART_SR register.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the offset for the Status Register (SR) of the USART peripheral.\n// This offset is used to access the USART_SR register from the base address of a USART peripheral.\n// The value is based on the STM32F407 reference manual, where the USART_SR register is located\n// at an offset of 0x00 from the base address of the USART peripheral.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function sets the appropriate bit in the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. This is necessary before any GPIOA operations can be performed.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Set the bit 0 in RCC_AHB1ENR to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bit mask for the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin number from the pin mask\n    uint8_t pin_number = 0;\n    for (uint32_t mask = pin_mask; mask > 1; mask >>= 1) {\n        pin_number++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin in the MODER register\n    *GPIO_MODER &= ~(0x3 << (pin_number * 2));\n\n    // Set the mode for the pin\n    if (mode == 1) {\n        // Set as output\n        *GPIO_MODER |= (0x1 << (pin_number * 2));\n    } else {\n        // Set as input (default is already cleared)\n    }\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin specified by the port base address and pin mask.\n * It calculates the pin position and checks the input data register (IDR) to determine if the pin is high or low.\n * \n * @param port_base_address The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t port_base_address, uint32_t pin_mask) {\n    // Pointer to the input data register (IDR) of the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(port_base_address + 0x10);\n\n    // Calculate the pin position by finding the first set bit in the pin mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the pin state from the IDR and return 1 if high, 0 if low\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations by using\n * bitwise XOR to flip the pin's state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint16_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the specified pin by XORing the ODR with the pin mask\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "31a33b0d-99d5-4500-b8b9-ed140f4147b8",
            "timestamp": "2024-10-11T13:09:55.856543",
            "total time (seconds)": 62.24759602546692,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference\n// manual for the STM32F407, which specifies the offset for the DR register\n// within the USART peripheral's register map.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the offset for the BRR register.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC (Reset and Clock Control) module.\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock for AHB1 peripherals.\n// The offset value is based on the STM32F407 reference manual.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n// on the STM32F407 microcontroller. This address is used to access\n// the RCC registers for configuring the clock system of the MCU.\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready to accept new data for transmission. It is a part of the USART\n// status register (USART_SR) and is typically used in USART communication\n// to check if the transmitter is ready to send the next byte of data.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the offset for the USART_SR register.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the clock is enabled by setting\n * the appropriate bit in the RCC_AHB1ENR register.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC and the offset for the AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Set the bit 0 of RCC_AHB1ENR to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - port_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t port_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin number from the pin mask\n    uint8_t pin_number = 0;\n    while ((pin_mask >> pin_number) != 1) {\n        pin_number++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(port_base + 0x00);\n\n    // Clear the two bits corresponding to the pin in the MODER register\n    *GPIO_MODER &= ~(0x3 << (pin_number * 2));\n\n    // Set the mode for the pin\n    // 0x1 for output mode, 0x0 for input mode\n    *GPIO_MODER |= (mode << (pin_number * 2));\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin specified by the port base address and pin mask.\n * It calculates the pin position and checks the input data register (IDR) to determine if the pin is high or low.\n * \n * @param port_base_address The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t port_base_address, uint32_t pin_mask) {\n    // Pointer to the input data register (IDR) of the specified GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(port_base_address + 0x10);\n\n    // Calculate the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the pin state from the IDR and return 1 if high, 0 if low\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations using bitwise XOR.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "ae003ba7-5337-4b71-9118-193a82a0867f",
            "timestamp": "2024-10-11T13:32:55.531919",
            "total time (seconds)": 5.180490493774414,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral\n// This offset is used to calculate the address of the BRR register for a given USART instance\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the offset for the Status Register (SR) of the USART peripheral.\n// This offset is used to access the USART_SR register from the base address of a USART peripheral.\n// The value is based on the STM32F407 reference manual, where the USART_SR register is located at an offset of 0x00 from the USART base address.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n#define RCC_BASE ((uint32_t)0x40023800) // Base address for the Reset and Clock Control (RCC) registers on the STM32F407 board\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference\n// manual for the STM32F407, which specifies the offset for the USART_DR register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Enable the clock for GPIOA by setting the appropriate bit in the RCC AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - port_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t port_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    for (uint32_t mask = pin_mask; mask > 1; mask >>= 1) {\n        pin_position++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(port_base + 0x00);\n\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n\n    // Set the mode: 0x1 for output, 0x0 for input\n    *GPIO_MODER |= (mode & 0x1) << (pin_position * 2);\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin by accessing the input data register (IDR)\n * of the specified GPIO port. It uses bitwise operations to determine the state of the pin.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the input data register (IDR) for the given GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the state of the pin from the IDR and return it\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It uses bitwise operations to ensure atomic\n * and reliable toggling of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "65fd4cbf-b574-4098-8059-2b909b2b3f1b",
            "timestamp": "2024-10-11T13:34:24.356601",
            "total time (seconds)": 75.16763138771057,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x08)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is based on the STM32F407 reference manual.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// USART_DR_OFFSET is the offset for the Data Register in the USART peripheral.\n// This offset is used to access the data register for reading or writing data.\n// The value is specific to the STM32F407 microcontroller series.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the USART transmit data register is empty\n// and ready to accept new data for transmission. It is a part of the USART status register (SR).\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Enable the clock for GPIOA by setting the appropriate bit in the RCC AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin number from the pin mask\n    uint8_t pin_number = 0;\n    while ((pin_mask >> pin_number) != 1) {\n        pin_number++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin in the MODER register\n    *GPIO_MODER &= ~(0x3 << (pin_number * 2));\n\n    // Set the mode for the pin\n    if (mode == 1) {\n        // Set as output\n        *GPIO_MODER |= (0x1 << (pin_number * 2));\n    } else {\n        // Set as input (default is already 0, so no need to set)\n    }\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin specified by the port base address and pin mask.\n * It calculates the pin position and checks the input data register (IDR) to determine if the pin is high or low.\n * \n * @param port_base_address The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t port_base_address, uint32_t pin_mask) {\n    // Pointer to the input data register (IDR) of the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(port_base_address + 0x10);\n\n    // Calculate the pin position by finding the first set bit in the pin mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the pin state from the IDR and return 1 if high, 0 if low\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It uses bitwise operations to ensure atomic\n * and reliable toggling of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "f6aa5650-aa15-4a7e-b93b-860e38631df3",
            "timestamp": "2024-10-17T11:16:07.404037",
            "total time (seconds)": 4.720076560974121,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready to accept new data for transmission.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the offset for the USART_SR register.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The USART_CR1 register is responsible for configuring various aspects of the USART peripheral,\n// such as enabling the USART, setting the word length, parity, and enabling interrupts.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// USART_DR_OFFSET is the offset for the Data Register in the USART peripheral.\n// This offset is used to access the data register for reading or writing data.\n// The value is specific to the STM32F407 microcontroller series.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_BRR_OFFSET is the offset for the Baud Rate Register in the USART peripheral.\n// This offset is used to calculate the address of the Baud Rate Register for a specific USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the clock is enabled by setting\n * the appropriate bit in the RCC_AHB1ENR register.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC and the offset for the AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Set the bit 0 in RCC_AHB1ENR to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    for (uint32_t mask = pin_mask; mask > 1; mask >>= 1) {\n        pin_position++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n\n    // Set the mode: 0x1 for output, 0x0 for input\n    *GPIO_MODER |= (mode & 0x1) << (pin_position * 2);\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin by accessing the input data register (IDR)\n * of the specified GPIO port. It uses bitwise operations to determine the state of the pin.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the input data register (IDR) for the given GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the state of the pin by checking the corresponding bit in the IDR\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations using bitwise XOR.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "a5a6dbc7-623d-4fb8-81ec-5fd1b036c534",
            "timestamp": "2024-10-17T11:18:17.880044",
            "total time (seconds)": 63.737038373947144,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the USART transmit data register is empty\n// and ready to accept new data for transmission. It is a bit mask used in\n// status register checks to determine the state of the USART peripheral.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the offset for the USART_SR register.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The USART_CR1 register is responsible for configuring various aspects of the USART peripheral,\n// such as enabling the USART, setting the word length, parity, and enabling interrupts.\n#define USART_CR1_OFFSET ((uint32_t)0x0000000C)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// USART_DR_OFFSET is the offset for the Data Register in the USART peripheral.\n// This offset is used to access the data register for reading or writing data.\n// The value is specific to the STM32F407 microcontroller series.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, where the BRR register is located\n// at an offset of 0x08 from the base address of the USART peripheral.\n#define USART_BRR_OFFSET ((uint32_t)0x08)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Enable the clock for GPIOA by setting the 0th bit of the RCC_AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin number from the pin mask\n    uint8_t pin_number = 0;\n    while ((pin_mask >> pin_number) != 1) {\n        pin_number++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin in the MODER register\n    *GPIO_MODER &= ~(0x3 << (pin_number * 2));\n\n    // Set the mode for the pin (0x1 for output, 0x0 for input)\n    *GPIO_MODER |= (mode << (pin_number * 2));\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin by accessing the input data register (IDR)\n * of the specified GPIO port. It determines the bit position of the pin using a loop\n * and returns the state of the pin.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Pointer to the input data register (IDR) of the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the pin state from the IDR and return it\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It uses bitwise operations to ensure atomic\n * and reliable toggling of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "f2ef7f7c-8bb3-49c7-b06c-9702298a4062",
            "timestamp": "2024-10-17T11:49:17.951127",
            "total time (seconds)": 2.6431760787963867,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral\n// This offset is used to calculate the address of the BRR register for a given USART instance\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The USART_CR1 register is responsible for configuring various aspects of the USART peripheral,\n// such as enabling the USART, setting the word length, parity control, and more.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC (Reset and Clock Control) block.\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock for AHB1 peripherals.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n#define RCC_BASE ((uint32_t)0x40023800) // Base address for the Reset and Clock Control (RCC) registers on the STM32F407 board\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference\n// manual for the STM32F407, which specifies the offset for the DR register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the offset for the USART_SR register.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for the next byte to be sent. It is typically used in USART\n// communication to check if the transmitter is ready to send more data.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Enable the clock for GPIOA by setting the appropriate bit in the RCC AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin number from the pin mask\n    uint8_t pin_number = 0;\n    while ((pin_mask >> pin_number) != 1) {\n        pin_number++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin in the MODER register\n    *GPIO_MODER &= ~(0x3 << (pin_number * 2));\n\n    // Set the mode for the pin\n    if (mode == 1) {\n        // Set as output\n        *GPIO_MODER |= (0x1 << (pin_number * 2));\n    } else {\n        // Set as input (default is already cleared)\n    }\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin by accessing the input data register (IDR)\n * of the specified GPIO port. It uses bitwise operations to determine the state of the pin.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the input data register (IDR) for the given GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the state of the pin by checking the corresponding bit in the IDR\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It uses bitwise operations to ensure atomic\n * and reliable toggling of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "686aa084-6ed2-4585-96b3-99e39cc1f236",
            "timestamp": "2024-10-17T12:03:10.639428",
            "total time (seconds)": 3.1919422149658203,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference\n// manual for the STM32F407, which specifies the offset for the DR register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 microcontroller.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the USART transmit data register is empty\n// and ready to accept new data for transmission. The value is based on the\n// STM32F407 reference manual, where the TXE flag is typically bit 7 in the\n// USART status register (SR).\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is based on the STM32F407 reference manual.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n// on the STM32F407 microcontroller. This address is used to access\n// the RCC registers for configuring the clock system of the MCU.\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral\n// This offset is used to calculate the address of the BRR register for a given USART instance\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Enable the clock for GPIOA by setting the appropriate bit in the RCC AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin (input or output) on an STM32F407 board\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin to configure (e.g., 1 << 5 for pin 5)\n// - mode: Mode to set (0 for input, 1 for output)\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the position of the pin\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n\n    // Set the mode (0 for input, 1 for output) at the pin position\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin by accessing the input data register (IDR)\n * of the specified GPIO port. It calculates the bit position of the pin using a loop\n * to ensure accurate pin configuration.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Pointer to the input data register (IDR) of the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n\n    // Calculate the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the pin state from the IDR and return it\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It uses bitwise operations to ensure atomic\n * and reliable toggling of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "7a81009e-2b33-4565-abb2-87bec802ca2a",
            "timestamp": "2024-10-17T12:04:30.872516",
            "total time (seconds)": 64.81269407272339,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference manual\n// which specifies the offset for the USART_DR register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC (Reset and Clock Control) module.\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock for AHB1 peripherals.\n// The value is specific to the STM32F407 microcontroller.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready to accept new data for transmission.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n#define RCC_BASE ((uint32_t)0x40023800) // Base address for the Reset and Clock Control (RCC) registers on the STM32F407 board\n\n// USART_BRR_OFFSET is the offset for the Baud Rate Register in the USART peripheral.\n// This offset is used to calculate the address of the Baud Rate Register for a specific USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the clock is enabled by setting\n * the appropriate bit in the RCC_AHB1ENR register.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC and the offset for the AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Enable the clock for GPIOA by setting the 0th bit of the RCC_AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n\n    // Set the mode: 0x1 for output, 0x0 for input\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin specified by the port base address and pin mask.\n * It calculates the pin position and checks the input data register (IDR) to determine if the pin is high or low.\n * \n * @param port_base_address The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t port_base_address, uint32_t pin_mask) {\n    // Pointer to the input data register (IDR) of the specified GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(port_base_address + 0x10);\n\n    // Calculate the pin position by finding the first set bit in the pin mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the pin state from the IDR and return 1 if high, 0 if low\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It uses bitwise operations to ensure atomic\n * and reliable toggling of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "47c2f3c7-4a1e-4772-bf20-3545faff2184",
            "timestamp": "2024-10-17T12:05:59.153790",
            "total time (seconds)": 72.52539086341858,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference\n// manual for the STM32F407, which specifies the offset for the DR register\n// within the USART peripheral's register map.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written to it. It is a part of the USART status register (SR).\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the offset for the USART_SR register.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n// on the STM32F407 microcontroller. This address is used to access\n// the RCC registers for configuring the clock system of the MCU.\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral\n// This offset is used to calculate the address of the BRR register for a given USART instance\n// The value is based on the STM32F407 reference manual, where the BRR register is located\n// at an offset of 0x08 from the base address of the USART peripheral.\n#define USART_BRR_OFFSET ((uint32_t)0x08)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the clock is enabled by setting\n * the appropriate bit in the RCC_AHB1ENR register.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC and the offset for the AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Enable the clock for GPIOA by setting the 0th bit in the RCC_AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin number from the pin mask\n    uint8_t pin_number = 0;\n    for (uint32_t mask = pin_mask; mask > 1; mask >>= 1) {\n        pin_number++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin in the MODER register\n    *GPIO_MODER &= ~(0x3 << (pin_number * 2));\n\n    // Set the mode for the pin (0x1 for output, 0x0 for input)\n    *GPIO_MODER |= (mode << (pin_number * 2));\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin specified by the port base address and pin mask.\n * It calculates the pin position and checks the input data register (IDR) to determine if the pin is high or low.\n * \n * @param port_base_address The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t port_base_address, uint32_t pin_mask) {\n    // Pointer to the input data register (IDR) of the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(port_base_address + 0x10);\n\n    // Calculate the pin position by finding the first set bit in the pin mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the pin state from the IDR and return 1 if high, 0 if low\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations using bitwise XOR.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "61a826cd-ebd7-42a3-9a1c-52460b85d37b",
            "timestamp": "2024-10-17T12:07:27.203822",
            "total time (seconds)": 69.30962014198303,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference\n// manual for the STM32F407, which specifies the offset for the DR register\n// within the USART peripheral's register map.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The USART_CR1 register is responsible for configuring various aspects of the USART peripheral,\n// such as enabling the USART, setting the word length, parity, and enabling interrupts.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready to accept new data for transmission.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is specific to the STM32F407 microcontroller series.\n#define USART_SR_OFFSET ((uint32_t)0x00000000)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x08)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the clock is enabled by setting\n * the appropriate bit in the RCC_AHB1ENR register.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC and the offset for the AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Enable the clock for GPIOA by setting the 0th bit in the RCC_AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin number from the pin mask\n    uint8_t pin_number = 0;\n    while ((pin_mask >> pin_number) != 1) {\n        pin_number++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin in the MODER register\n    *GPIO_MODER &= ~(0x3 << (pin_number * 2));\n\n    // Set the mode for the pin\n    // 0x1 for output mode, 0x0 for input mode\n    *GPIO_MODER |= (mode << (pin_number * 2));\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin specified by the port base address and pin mask.\n * It calculates the pin position and checks the input data register (IDR) to determine if the pin is high or low.\n * \n * @param port_base_address The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t port_base_address, uint32_t pin_mask) {\n    // Pointer to the input data register (IDR) of the specified GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(port_base_address + 0x10);\n\n    // Calculate the pin position by finding the first set bit in the pin mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the pin state from the IDR and return 1 if high, 0 if low\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It uses bitwise operations to ensure atomic\n * and reliable toggling of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "54f12f96-7a7e-4e5f-aeea-37f12d8f3eca",
            "timestamp": "2024-10-17T12:08:56.094480",
            "total time (seconds)": 73.75764632225037,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference\n// manual for the STM32F407, which specifies the offset for the DR register\n// within the USART peripheral's register map.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The USART_CR1 register is used to configure various settings of the USART peripheral,\n// such as enabling the USART, setting the word length, parity, and enabling interrupts.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// The RCC_AHB1ENR register is used to enable the clock for peripherals connected to the AHB1 bus.\n// The offset is based on the STM32F407 reference manual, which specifies the memory map for the RCC registers.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready to accept new data for transmission. It is a part of the USART\n// status register (USART_SR) and is typically used in USART communication\n// to check if the transmitter is ready to send the next byte.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the offset for the Status Register (SR) of the USART peripheral.\n// This offset is used to access the USART_SR register from the base address of a USART peripheral.\n// The value is based on the STM32F407 reference manual, where the USART_SR register is located\n// at an offset of 0x00 from the base address of the USART peripheral.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n// on the STM32F407 microcontroller. This address is used to access\n// the RCC registers for configuring the clock system of the MCU.\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral\n// The USART_BRR_OFFSET is used to calculate the address of the BRR register\n// within a USART peripheral's memory map. This offset is specific to the STM32F407\n// microcontroller series and is used in conjunction with the base address of a USART\n// peripheral to access the BRR register.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the clock is enabled by setting\n * the appropriate bit in the RCC_AHB1ENR register.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC and the offset for the AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Enable the clock for GPIOA by setting the 0th bit of the RCC_AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin number from the pin mask\n    uint8_t pin_number = 0;\n    while ((pin_mask >> pin_number) != 1) {\n        pin_number++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin in the MODER register\n    *GPIO_MODER &= ~(0x3 << (pin_number * 2));\n\n    // Set the mode for the pin (0x1 for output, 0x0 for input)\n    *GPIO_MODER |= (mode << (pin_number * 2));\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin by accessing the input data register (IDR)\n * of the specified GPIO port. It calculates the bit position of the pin using a loop\n * and returns the state of the pin.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Pointer to the input data register (IDR) of the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n\n    // Calculate the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the pin state from the IDR and return it\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It uses bitwise operations to ensure atomic\n * and reliable toggling of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "5d45f828-456c-4120-bae7-d320f5282ee7",
            "timestamp": "2024-10-17T12:10:11.040024",
            "total time (seconds)": 59.77073311805725,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference\n// manual for the STM32F407, which specifies the offset for the DR register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The USART_CR1 register is responsible for configuring various aspects of the USART peripheral,\n// such as enabling the USART, setting the word length, parity control, and more.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC (Reset and Clock Control) block.\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock for AHB1 peripherals.\n// The offset value is based on the STM32F407 reference manual.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board.\n// This flag is used to indicate that the USART transmit data register is empty.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the offset for the USART_SR register.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n#define RCC_BASE ((uint32_t)0x40023800) // Base address for the Reset and Clock Control (RCC) registers on the STM32F407 board\n\n// USART_BRR_OFFSET is the offset for the Baud Rate Register in the USART peripheral.\n// This offset is used to calculate the address of the Baud Rate Register for a specific USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the clock is enabled by setting\n * the appropriate bit in the RCC_AHB1ENR register.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC and the offset for the AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Enable the clock for GPIOA by setting the 0th bit in the RCC_AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin number from the pin mask\n    uint8_t pin_number = 0;\n    while ((pin_mask >> pin_number) != 1) {\n        pin_number++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin in the MODER register\n    *GPIO_MODER &= ~(0x3 << (pin_number * 2));\n\n    // Set the mode for the pin (0x1 for output, 0x0 for input)\n    *GPIO_MODER |= (mode << (pin_number * 2));\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin specified by the port base address and pin mask.\n * It calculates the pin position and checks the input data register (IDR) to determine if the pin is high or low.\n * \n * @param port_base_address The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t port_base_address, uint32_t pin_mask) {\n    // Pointer to the input data register (IDR) of the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(port_base_address + 0x10);\n\n    // Calculate the pin position by finding the first set bit in the pin mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the pin state from the IDR and return 1 if high, 0 if low\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of the specified GPIO port\n * to toggle the state of a given pin. It ensures atomic operations using bitwise XOR.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the specified pin using XOR operation\n    *GPIO_ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "673b4ad3-1fe7-4298-bea0-fc5a5e37cda2",
            "timestamp": "2024-10-17T12:11:30.200378",
            "total time (seconds)": 63.999008893966675,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference\n// manual for the STM32F407, which specifies the offset for the DR register\n// within the USART peripheral's register map.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// USART_FLAG_TXE is a flag used to indicate that the USART transmit data register is empty.\n// This flag is typically used in USART status register (USART_SR) to check if the USART is ready to send more data.\n// The value 0x0080 corresponds to the bit position of the TXE flag in the USART status register.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is based on the STM32F407 reference manual.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x08)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the clock is enabled by setting\n * the appropriate bit in the RCC_AHB1ENR register.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC and the offset for the AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Set the bit corresponding to GPIOA (bit 0) to enable its clock\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin number from the pin mask\n    uint8_t pin_number = 0;\n    while ((pin_mask >> pin_number) != 1) {\n        pin_number++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin in the MODER register\n    *GPIO_MODER &= ~(0x3 << (pin_number * 2));\n\n    // Set the mode for the pin (0x1 for output, 0x0 for input)\n    *GPIO_MODER |= (mode << (pin_number * 2));\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin specified by the port base address and pin mask.\n * It calculates the pin position and checks the input data register (IDR) to determine if the pin is high or low.\n * \n * @param port_base_address The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t port_base_address, uint32_t pin_mask) {\n    // Pointer to the input data register (IDR) of the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(port_base_address + 0x10);\n\n    // Calculate the pin position by finding the first set bit in the pin mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the pin state from the IDR and return 1 if high, 0 if low\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It uses bitwise operations to ensure atomic\n * and reliable toggling of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "cb8232f9-dc3f-4207-892b-c4557ec1c024",
            "timestamp": "2024-10-17T12:12:39.764206",
            "total time (seconds)": 54.27219247817993,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference\n// manual for the STM32F407, which specifies the offset for the DR register\n// within the USART peripheral's register map.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC (Reset and Clock Control) module.\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock for AHB1 peripherals.\n// The offset value is based on the STM32F407 reference manual.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// USART_FLAG_TXE is a flag used to indicate that the USART transmit data register is empty.\n// This flag is typically used in USART status register (USART_SR) to check if the USART is ready to send more data.\n// The value 0x0080 corresponds to the bit position of the TXE flag in the USART_SR register.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n// on the STM32F407 microcontroller. This address is used to access\n// the RCC registers for configuring the clock system of the MCU.\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral\n// This offset is used to calculate the address of the BRR register for a given USART instance\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Enable the clock for GPIOA by setting the appropriate bit in the RCC AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin number from the pin mask\n    uint8_t pin_number = 0;\n    for (uint32_t mask = pin_mask; mask > 1; mask >>= 1) {\n        pin_number++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin in the MODER register\n    *GPIO_MODER &= ~(0x3 << (pin_number * 2));\n\n    // Set the mode for the pin (0x1 for output, 0x0 for input)\n    *GPIO_MODER |= (mode << (pin_number * 2));\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin by accessing the input data register (IDR)\n * of the specified GPIO port. It uses bitwise operations to determine the state of the pin.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the input data register (IDR) for the given GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the state of the pin from the IDR and return it\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations using bitwise XOR.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the specified pin using XOR operation\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "494896e6-8222-4335-9804-cd9217cb61c3",
            "timestamp": "2024-10-17T12:14:01.185491",
            "total time (seconds)": 66.32756066322327,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference\n// manual for the STM32F407, which specifies the offset for the DR register\n// within the USART peripheral's register map.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the USART transmit data register is empty\n// and ready to accept new data for transmission. It is a part of the USART status register (SR).\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n// on the STM32F407 microcontroller. This address is used to access\n// the RCC registers for configuring the clock system of the MCU.\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x08)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// The USART2 peripheral is used for serial communication and is mapped to a specific memory address.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the clock is enabled by setting\n * the appropriate bit in the RCC_AHB1ENR register.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC and the offset for the AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Set the bit corresponding to GPIOA (bit 0) to enable its clock\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bit mask for the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    for (uint32_t mask = pin_mask; mask > 1; mask >>= 1) {\n        pin_position++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n\n    // Set the mode: 0x1 for output, 0x0 for input\n    *GPIO_MODER |= (mode & 0x1) << (pin_position * 2);\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin by accessing the input data register (IDR)\n * of the specified GPIO port. It calculates the bit position of the pin using a loop\n * to ensure accurate pin configuration.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask representing the pin to read (e.g., 1 << 5 for pin 5).\n * \n * @return 1 if the pin is set (high), 0 if the pin is reset (low).\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Pointer to the input data register (IDR) of the specified GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n\n    // Calculate the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the pin state from the IDR and return it\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It uses bitwise operations to ensure atomic\n * and reliable toggling of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "6f1d8f1b-678f-4b7a-a8ef-156cd12f72b2",
            "timestamp": "2024-10-17T12:15:17.122222",
            "total time (seconds)": 60.705763816833496,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference\n// manual for the STM32F407, which specifies the offset for the DR register\n// within the USART peripheral's register map.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 microcontroller.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the USART transmit data register is empty\n// and ready to accept new data for transmission. The value is based on the\n// STM32F407 reference manual, where the TXE flag is typically bit 7 in the\n// USART status register (SR).\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the offset for the USART_SR register.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n// on the STM32F407 microcontroller. This address is used to access\n// the RCC registers for configuring the clock system of the MCU.\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x08)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the clock is enabled by setting\n * the appropriate bit in the RCC_AHB1ENR register.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC and the offset for the AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Set the bit 0 in RCC_AHB1ENR to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position from the pin mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n\n    // Set the mode: 0x1 for output, 0x0 for input\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin by accessing the input data register (IDR)\n * of the specified GPIO port. It uses bitwise operations to determine the state of the pin.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the input data register (IDR) for the given GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the state of the pin from the IDR and return it\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It uses bitwise operations to ensure atomic\n * and reliable toggling of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "f9c480b4-874b-482c-845a-ccbb2d67ccd3",
            "timestamp": "2024-10-17T15:42:28.363297",
            "total time (seconds)": 4.369966268539429,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// USART_DR_OFFSET is the offset for the Data Register in the USART peripheral.\n// This offset is used to access the data register for reading or writing data.\n// The value is specific to the STM32F407 microcontroller series.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n#define RCC_BASE ((uint32_t)0x40023800) // Base address for the Reset and Clock Control (RCC) registers on the STM32F407 board\n\n// USART_CR1_OFFSET is the offset for the Control Register 1 of the USART peripheral.\n// This offset is used to access the USART_CR1 register from the base address of a USART peripheral.\n// The value is specific to the STM32F407 microcontroller series.\n#define USART_CR1_OFFSET ((uint32_t)0x0000000C)\n\n// USART_BRR_OFFSET is the offset for the Baud Rate Register in the USART peripheral.\n// This offset is used to calculate the address of the Baud Rate Register for a specific USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// USART_FLAG_TXE is a flag used to indicate that the transmit data register is empty.\n// This flag is typically used in USART communication to check if the USART is ready to send more data.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the Status Register (SR) of the USART peripheral.\n// This offset is used to access the USART_SR register from the base address of a USART peripheral.\n// The value is based on the STM32F407 reference manual, where the USART_SR register is located at an offset of 0x00 from the USART base address.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the clock is enabled by setting\n * the appropriate bit in the RCC_AHB1ENR register.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC and the offset for the AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Set the bit 0 of RCC_AHB1ENR to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin (input or output) on an STM32F407 board\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin to configure (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n\n    // Set the mode for the pin\n    if (mode == 1) {\n        // Set as output\n        *GPIO_MODER |= (0x1 << (pin_position * 2));\n    } else {\n        // Set as input (default is already cleared)\n    }\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin specified by the port base address and pin mask.\n * It calculates the pin position and checks the input data register (IDR) to determine if the pin is high or low.\n * \n * @param port_base_address The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t port_base_address, uint32_t pin_mask) {\n    // Calculate the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Define a pointer to the input data register (IDR) of the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(port_base_address + 0x10);\n\n    // Read the pin state from the IDR and return 1 if the pin is high, 0 if low\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of the specified GPIO port\n * to toggle the state of a given pin. It ensures atomic operations using bitwise XOR.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the specified pin using XOR operation\n    *GPIO_ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "ffea067a-7b2d-4aaf-ac37-6f3876e7b5a3",
            "timestamp": "2024-10-17T15:45:44.369696",
            "total time (seconds)": 3.9839284420013428,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// USART_DR_OFFSET is the offset for the Data Register in the USART peripheral.\n// This offset is used to access the data register for reading or writing data.\n// The value is specific to the STM32F407 microcontroller series.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n// on the STM32F407 microcontroller. This address is used to access\n// the RCC registers for configuring the clock system of the MCU.\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// USART_FLAG_TXE is a flag used to indicate that the USART transmit data register is empty.\n// This flag is typically used in USART status register to check if the USART is ready to send more data.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 microcontroller.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Enable the clock for GPIOA by setting the appropriate bit in the RCC AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin number from the pin mask\n    uint8_t pin_number = 0;\n    for (uint32_t mask = pin_mask; mask > 1; mask >>= 1) {\n        pin_number++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin number\n    *GPIO_MODER &= ~(0x3 << (pin_number * 2));\n\n    // Set the mode for the pin\n    if (mode == 1) {\n        // Set as output\n        *GPIO_MODER |= (0x1 << (pin_number * 2));\n    } else {\n        // Set as input (default is already cleared)\n    }\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin by accessing the input data register (IDR)\n * of the specified GPIO port. It uses bitwise operations to determine the state of the pin.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the input data register (IDR) for the given GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the state of the pin from the IDR and return it\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of the specified GPIO port\n * to toggle the state of a given pin. It ensures atomic operations using bitwise XOR.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *GPIO_ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *GPIO_ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "7459df20-e5de-4013-b9a0-38cbdff5077d",
            "timestamp": "2024-10-17T17:41:50.218670",
            "total time (seconds)": 2.520341634750366,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// USART_BRR_OFFSET is the offset for the Baud Rate Register in the USART peripheral.\n// This offset is used to calculate the address of the Baud Rate Register for a specific USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference\n// manual for the STM32F407, which specifies the offset for the DR register\n// within the USART peripheral's register map.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n// on the STM32F407 microcontroller. This address is used to access\n// the RCC registers for configuring the clock system of the MCU.\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board.\n// This flag is used to indicate that the transmit data register is empty.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the offset for the USART_SR register.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the clock is enabled by setting\n * the appropriate bit in the RCC_AHB1ENR register.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC and the offset for the AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Enable the clock for GPIOA by setting the 0th bit in the RCC_AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin number from the pin mask\n    uint8_t pin_number = 0;\n    while ((pin_mask >> pin_number) != 1) {\n        pin_number++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin in the MODER register\n    *GPIO_MODER &= ~(0x3 << (pin_number * 2));\n\n    // Set the mode for the pin\n    if (mode == 1) {\n        // Set as output\n        *GPIO_MODER |= (0x1 << (pin_number * 2));\n    } else {\n        // Set as input (default is already cleared)\n    }\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin by accessing the input data register (IDR)\n * of the specified GPIO port. It calculates the bit position of the pin using a loop\n * to ensure accurate pin configuration.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask representing the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Pointer to the input data register (IDR) of the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n\n    // Calculate the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the pin state from the IDR and return it\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations using bitwise XOR.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "e725ee63-fed0-4fd2-addf-90c225dfa964",
            "timestamp": "2024-10-17T17:42:49.314463",
            "total time (seconds)": 46.31981611251831,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference\n// manual for the STM32F407, which specifies the offset for the DR register\n// within the USART peripheral's register map.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the offset for the Status Register (SR) of the USART peripheral.\n// This offset is used to access the USART_SR register from the base address of a USART peripheral.\n// The value is based on the STM32F407 reference manual, where the USART_SR register is located at an offset of 0x00 from the USART base address.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the clock is enabled by setting\n * the appropriate bit in the RCC_AHB1ENR register.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC and the offset for the AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Set the bit 0 in RCC_AHB1ENR to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n\n    // Set the mode: 0x1 for output, 0x0 for input\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin specified by the port base address and pin mask.\n * It calculates the pin position and checks the input data register (IDR) to determine if the pin is high or low.\n * \n * @param port_base_address The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t port_base_address, uint32_t pin_mask) {\n    // Pointer to the input data register (IDR) of the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(port_base_address + 0x10);\n\n    // Calculate the pin position by finding the first set bit in the pin mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the pin state from the IDR and return 1 if high, 0 if low\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It uses bitwise operations to ensure atomic\n * and reliable toggling of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "d329ef00-3f3b-4837-bf16-ad475e1bdca6",
            "timestamp": "2024-10-17T17:44:01.310941",
            "total time (seconds)": 61.470722675323486,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC (Reset and Clock Control) block.\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock for AHB1 peripherals.\n// The offset value is based on the STM32F407 reference manual.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// USART_BRR_OFFSET is the offset for the Baud Rate Register in the USART peripheral.\n// This offset is used to calculate the address of the Baud Rate Register for a specific USART instance.\n// The value is based on the STM32F407 reference manual.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference\n// manual for the STM32F407, which specifies the offset for the DR register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n// on the STM32F407 microcontroller. This address is used to access\n// the RCC registers for configuring the clock system of the MCU.\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n#define USART_FLAG_TXE ((uint16_t)0x0080) // USART Transmit Data Register Empty flag: This flag is set when the transmit data register is empty and ready to accept new data.\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is based on the STM32F407 reference manual.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Enable the clock for GPIOA by setting the appropriate bit in the RCC AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n\n    // Set the mode: 0x1 for output, 0x0 for input\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin by accessing the input data register (IDR)\n * of the specified GPIO port. It calculates the bit position of the pin using a loop\n * to ensure accurate pin configuration.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask representing the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Pointer to the input data register (IDR) of the specified GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n\n    // Calculate the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the pin state from the IDR and return it\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations using bitwise XOR.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "ef980d2a-de29-45a4-9c64-1a6f5c120757",
            "timestamp": "2024-10-17T17:45:24.285162",
            "total time (seconds)": 72.61029171943665,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x08)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference\n// manual for the STM32F407, which specifies the offset for the DR register\n// within the USART peripheral's register map.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is specific to the STM32F407 microcontroller series.\n#define USART_SR_OFFSET ((uint32_t)0x00000000)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC AHB1 peripheral clock enable register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Enable the clock for GPIOA by setting the appropriate bit in the RCC AHB1ENR register\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n\n    // Set the mode: 0x1 for output, 0x0 for input\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin by accessing the input data register (IDR)\n * of the specified GPIO port. It calculates the bit position of the pin using a loop\n * and returns the state of the pin.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Pointer to the input data register (IDR) of the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n\n    // Calculate the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the pin state from the IDR and return it\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It uses bitwise operations to ensure atomic\n * and reliable toggling of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "a55ac315-dc55-4b73-a652-52211531e00c",
            "timestamp": "2024-10-18T10:06:19.899723",
            "total time (seconds)": 2.8200337886810303,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// The RCC_AHB1ENR register is used to enable the clock for peripherals connected to the AHB1 bus.\n// The offset is based on the STM32F407 reference manual, which specifies the memory map for the RCC registers.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference\n// manual for the STM32F407, which specifies the offset for the USART_DR register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is based on the STM32F407 reference manual.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral\n// This offset is used to calculate the address of the BRR register for a given USART instance\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the clock is enabled by setting\n * the appropriate bit in the RCC_AHB1ENR register.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC and the offset for the AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Set the bit 0 in RCC_AHB1ENR to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin (input or output) on an STM32F407 board\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin to configure (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input mode, 1 for output mode\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in the pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n\n    // Set the mode for the pin (0x1 for output, 0x0 for input)\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin by accessing the input data register (IDR)\n * of the specified GPIO port. It calculates the bit position of the pin using a loop\n * and returns the state of the pin.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Pointer to the input data register (IDR) of the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n\n    // Calculate the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the pin state from the IDR and return it\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations using bitwise XOR.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "3e94ddbb-9f25-4c2e-b381-d9536547cd8c",
            "timestamp": "2024-10-18T10:07:53.721041",
            "total time (seconds)": 59.511929988861084,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The USART_CR1 register is responsible for configuring various parameters of the USART peripheral,\n// such as enabling the USART, setting the word length, parity control, and more.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// USART_FLAG_TXE is a flag used to indicate that the USART transmit data register is empty.\n// This flag is typically used in USART status register (USART_SR) to check if the USART is ready to send more data.\n// The value 0x0080 corresponds to the TXE (Transmit Data Register Empty) flag in the USART status register.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// The RCC_AHB1ENR register is used to enable the clock for peripherals connected to the AHB1 bus.\n// The offset is based on the reference manual for the STM32F407 microcontroller.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// USART_DR_OFFSET is the offset for the Data Register in the USART peripheral.\n// This offset is used to access the data register for reading or writing data.\n// The value is specific to the STM32F407 microcontroller series.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Define the offset for the Status Register (SR) of the USART peripheral.\n// This offset is used to access the USART_SR register from the base address of a USART peripheral.\n// The value is based on the STM32F407 reference manual, where the USART_SR register is located\n// at an offset of 0x00 from the base address of the USART peripheral.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the clock is enabled by setting\n * the appropriate bit in the RCC_AHB1ENR register.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC and the offset for the AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Set the bit 0 of RCC_AHB1ENR to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position from the pin mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n\n    // Set the mode: 0x1 for output, 0x0 for input\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin by accessing the input data register (IDR)\n * of the specified GPIO port. It calculates the bit position of the pin using a loop\n * and returns the state of the pin.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Pointer to the input data register (IDR) of the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n\n    // Calculate the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the pin state from the IDR and return it\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations using bitwise XOR.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14); // ODR offset is 0x14\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "2e6cf285-24d4-4293-9b8b-9913d9502a2e",
            "timestamp": "2024-10-18T10:09:18.796691",
            "total time (seconds)": 75.40402364730835,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// USART_FLAG_TXE is a flag used to indicate that the USART transmit data register is empty.\n// This flag is typically used in USART status register (USART_SR) to check if the USART is ready to send more data.\n// The value 0x0080 corresponds to the bit position of the TXE flag in the USART status register.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the base address for USART2 peripheral on the STM32F407 board\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// USART_DR_OFFSET is the offset for the Data Register in the USART peripheral.\n// This offset is used to access the data register for reading or writing data.\n// The value is specific to the STM32F407 microcontroller series.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// USART_BRR_OFFSET is the offset for the Baud Rate Register in the USART peripheral.\n// This offset is used to calculate the address of the Baud Rate Register for a specific USART instance.\n// The value is based on the STM32F407 reference manual.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the clock is enabled by setting\n * the appropriate bit in the RCC_AHB1ENR register.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC and the offset for the AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Set the bit 0 of RCC_AHB1ENR to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n\n    // Set the mode: 0x1 for output, 0x0 for input\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin specified by the port base address and pin mask.\n * It calculates the pin position and checks the input data register (IDR) to determine if the pin is high or low.\n * \n * @param port_base_address The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t port_base_address, uint32_t pin_mask) {\n    // Calculate the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Define a pointer to the input data register (IDR) of the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(port_base_address + 0x10);\n\n    // Read the pin state from the IDR and return 1 if the pin is high, 0 if low\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations using bitwise XOR.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the specified pin using XOR operation\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "69001ccb-7acf-4f7c-b400-2d290536753e",
            "timestamp": "2024-10-18T10:21:06.365041",
            "total time (seconds)": 3.050837993621826,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is based on the STM32F407 reference manual.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the offset for the BRR register.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference\n// manual for the STM32F407, which specifies the offset for the DR register\n// within the USART peripheral's register map.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n// on the STM32F407 microcontroller. This address is used to access\n// the RCC registers for configuring the clock system of the MCU.\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready to accept new data for transmission. It is a part of the USART\n// status register (USART_SR) and is typically used in USART communication\n// to check if the transmitter is ready to send the next byte of data.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the clock is enabled by setting\n * the appropriate bit in the RCC_AHB1ENR register.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC and the offset for the AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Set the bit 0 of RCC_AHB1ENR to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin number from the pin mask\n    uint8_t pin_number = 0;\n    while ((pin_mask >> pin_number) != 1) {\n        pin_number++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin in the MODER register\n    *GPIO_MODER &= ~(0x3 << (pin_number * 2));\n\n    // Set the mode for the pin (0x1 for output, 0x0 for input)\n    *GPIO_MODER |= (mode << (pin_number * 2));\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin by accessing the input data register (IDR)\n * of the specified GPIO port. It uses bitwise operations to determine the state of the pin.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the input data register (IDR) for the given GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the state of the pin from the IDR and return it\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations using bitwise XOR.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "779a0135-13e7-4341-a639-fbc3a8715819",
            "timestamp": "2024-10-18T10:22:22.663833",
            "total time (seconds)": 66.0314610004425,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is based on the STM32F407 reference manual.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x08)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// The RCC_AHB1ENR register is used to enable the clock for peripherals connected to the AHB1 bus.\n// The offset is based on the STM32F407 reference manual, which specifies the memory map for the RCC registers.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference\n// manual for the STM32F407, which specifies the offset for the DR register\n// within the USART peripheral's register map.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n// on the STM32F407 microcontroller. This address is used to access\n// the RCC registers for configuring the clock system of the MCU.\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// USART_FLAG_TXE is a flag used to indicate that the USART transmit data register is empty.\n// This flag is typically used in USART status register to check if the USART is ready to send more data.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the clock is enabled by setting\n * the appropriate bit in the RCC_AHB1ENR register.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC and the offset for the AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Set the bit 0 of RCC_AHB1ENR to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin number from the pin mask\n    uint8_t pin_number = 0;\n    while ((pin_mask >> pin_number) != 1) {\n        pin_number++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin in the MODER register\n    *GPIO_MODER &= ~(0x3 << (pin_number * 2));\n\n    // Set the mode for the pin\n    if (mode == 1) {\n        // Set as output\n        *GPIO_MODER |= (0x1 << (pin_number * 2));\n    } else {\n        // Set as input (default is already cleared)\n    }\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin specified by the port base address and pin mask.\n * It calculates the pin position and checks the input data register (IDR) to determine if the pin is high or low.\n * \n * @param port_base_address The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t port_base_address, uint32_t pin_mask) {\n    // Calculate the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask & 1) == 0) {\n        pin_mask >>= 1;\n        pin_position++;\n    }\n\n    // Define the input data register (IDR) offset for the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(port_base_address + 0x10);\n\n    // Read the pin state from the IDR and return 1 if high, 0 if low\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations using bitwise\n * XOR to flip the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "921dcf61-06e4-4d41-8f75-c45aba67ed4f",
            "timestamp": "2024-10-18T10:23:55.818899",
            "total time (seconds)": 83.15119171142578,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the offset for the USART_SR register.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference\n// manual for the STM32F407, which specifies the offset for the USART_DR register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n// on the STM32F407 microcontroller. This address is used to access\n// the RCC registers for configuring the clock system of the MCU.\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the USART transmit data register is empty\n// and ready to accept new data for transmission. It is a part of the USART status register (SR).\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the clock is enabled by setting\n * the appropriate bit in the RCC_AHB1ENR register.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC and the offset for the AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Set the bit 0 of RCC_AHB1ENR to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    for (uint32_t mask = pin_mask; mask > 1; mask >>= 1) {\n        pin_position++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n\n    // Set the mode: 0x1 for output, 0x0 for input\n    *GPIO_MODER |= (mode & 0x1) << (pin_position * 2);\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin by accessing the input data register (IDR)\n * of the specified GPIO port. It calculates the bit position of the pin using a loop\n * to ensure accurate pin configuration.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask representing the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Pointer to the input data register (IDR) of the specified GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n\n    // Calculate the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the pin state from the IDR and return 1 if high, 0 if low\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations using bitwise XOR.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14); // ODR offset is 0x14\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "bf517f82-8b55-4fad-99ec-f64d654af024",
            "timestamp": "2024-10-18T10:25:56.845814",
            "total time (seconds)": 110.91092205047607,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// USART_BRR_OFFSET is the offset for the Baud Rate Register in the USART peripheral.\n// This offset is used to calculate the address of the Baud Rate Register for a specific USART instance.\n// The value is based on the STM32F407 reference manual.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference\n// manual for the STM32F407, which specifies the offset for the DR register\n// within the USART peripheral's register map.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n// on the STM32F407 microcontroller. This address is used to access\n// the RCC registers for configuring the clock system of the MCU.\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the clock is enabled by setting\n * the appropriate bit in the RCC_AHB1ENR register.\n * \n * @param none\n * @return none\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC and the offset for the AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Set the bit 0 in RCC_AHB1ENR to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin number from the pin mask\n    uint8_t pin_number = 0;\n    while ((pin_mask >> pin_number) != 1) {\n        pin_number++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin in the MODER register\n    *GPIO_MODER &= ~(0x3 << (pin_number * 2));\n\n    // Set the mode for the pin\n    if (mode == 1) {\n        // Set as output\n        *GPIO_MODER |= (0x1 << (pin_number * 2));\n    } else {\n        // Set as input (default is already 0, so no need to set)\n    }\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin by accessing the input data register (IDR)\n * of the specified GPIO port. It calculates the bit position of the pin using a loop\n * and returns the state of the pin.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Pointer to the input data register (IDR) of the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n\n    // Calculate the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the pin state from the IDR and return it\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations using bitwise XOR.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the specified pin using XOR operation\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "24680aea-18dc-44a6-91eb-5e9e8e38c12b",
            "timestamp": "2024-10-18T10:28:16.932920",
            "total time (seconds)": 129.7296884059906,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is specific to the STM32F407 microcontroller series.\n#define USART_SR_OFFSET ((uint32_t)0x00000000)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral\n// The USART_BRR_OFFSET is used to calculate the address of the BRR register\n// within the USART peripheral's memory map. This offset is specific to the\n// STM32F407 microcontroller series.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference\n// manual for the STM32F407, which specifies the offset for the DR register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n#define RCC_BASE ((uint32_t)0x40023800) // Base address for the Reset and Clock Control (RCC) registers on the STM32F407 board\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready to accept new data for transmission. It is a part of the USART\n// status register (USART_SR) and is typically used in USART communication\n// to check if the transmitter is ready to send the next byte of data.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the USART Control Register 1 (CR1) from the base address of a USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the clock is enabled by setting\n * the appropriate bit in the RCC_AHB1ENR register.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC and the offset for the AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Set the bit 0 of RCC_AHB1ENR to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n\n    // Set the mode: 0x1 for output, 0x0 for input\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 to reset, 1 to set).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin: Use bitwise OR to set the specific bit\n        *ODR |= (1 << pin_position);\n    } else {\n        // Reset the pin: Use bitwise AND with NOT to clear the specific bit\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin specified by the port base address and pin mask.\n * It calculates the pin position and checks the input data register (IDR) to determine if the pin is high or low.\n * \n * @param port_base_address The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t port_base_address, uint32_t pin_mask) {\n    // Pointer to the input data register (IDR) of the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(port_base_address + 0x10);\n\n    // Calculate the pin position by finding the first set bit in the pin mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the pin state from the IDR and return 1 if high, 0 if low\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations using bitwise XOR.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "7e981455-7f5f-4eea-998a-26d03d26def0",
            "timestamp": "2024-10-18T10:30:31.403734",
            "total time (seconds)": 123.41668009757996,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the offset for the USART_SR register.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral\n// This offset is used to calculate the address of the BRR register for a given USART instance\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for peripherals connected to the AHB1 bus on the STM32F407 microcontroller.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference\n// manual for the STM32F407, which specifies the offset for the DR register\n// within the USART peripheral's register map.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready for new data to be written. It is a part of the USART status register.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the clock is enabled by setting\n * the appropriate bit in the RCC_AHB1ENR register.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC and the offset for the AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Set the bit 0 of RCC_AHB1ENR to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin number from the pin mask\n    uint8_t pin_number = 0;\n    for (uint32_t mask = pin_mask; mask > 1; mask >>= 1) {\n        pin_number++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin in the MODER register\n    *GPIO_MODER &= ~(0x3 << (pin_number * 2));\n\n    // Set the mode for the pin (0x1 for output, 0x0 for input)\n    *GPIO_MODER |= (mode << (pin_number * 2));\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin by accessing the input data register (IDR)\n * of the specified GPIO port. It uses bitwise operations to determine the state of the pin.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the input data register (IDR) for the given GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n\n    // Determine the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the state of the pin from the IDR and return it\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It uses bitwise operations to ensure atomic\n * and reliable toggling of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "5a24274a-eb66-4205-8b6b-ce1ecb385766",
            "timestamp": "2024-10-18T10:32:22.035825",
            "total time (seconds)": 100.26549983024597,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the offset for the USART_SR register.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// USART_BRR_OFFSET is the offset for the Baud Rate Register in the USART peripheral.\n// This offset is used to calculate the address of the Baud Rate Register for a specific USART instance.\n// The value is based on the STM32F407 reference manual.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference\n// manual for the STM32F407, which specifies the offset for the DR register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n// on the STM32F407 microcontroller. This address is used to access\n// the RCC registers for configuring the clock system of the MCU.\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready to accept new data for transmission. It is a part of the USART\n// status register (USART_SR) and is typically used in USART communication\n// to check if the transmitter is ready to send the next byte of data.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the GPIOA peripheral is powered\n * and ready for use.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC and the offset for the AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Set the bit corresponding to GPIOA (bit 0) to enable its clock\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin number from the pin mask\n    uint8_t pin_number = 0;\n    for (uint32_t mask = pin_mask; mask > 1; mask >>= 1) {\n        pin_number++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin in the MODER register\n    *GPIO_MODER &= ~(0x3 << (pin_number * 2));\n\n    // Set the mode for the pin (0x1 for output, 0x0 for input)\n    *GPIO_MODER |= (mode << (pin_number * 2));\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin specified by the port base address and pin mask.\n * It calculates the pin position and checks the input data register (IDR) to determine if the pin is high or low.\n * \n * @param port_base_address The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t port_base_address, uint32_t pin_mask) {\n    // Calculate the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Define the input data register (IDR) offset for the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(port_base_address + 0x10);\n\n    // Read the pin state from the IDR and return 1 if high, 0 if low\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It uses bitwise operations to ensure atomic\n * and reliable toggling of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "616d6b43-857a-47c6-9bbf-223a9ba840e1",
            "timestamp": "2024-10-18T10:33:24.418055",
            "total time (seconds)": 52.10143232345581,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the offset for the USART_SR register.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// USART_BRR_OFFSET is the offset for the Baud Rate Register in the USART peripheral.\n// This offset is used to calculate the address of the Baud Rate Register for a specific USART instance.\n// The value is based on the STM32F407 reference manual.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference manual\n// for the STM32F407, which specifies the offset for the USART_DR register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// USART_FLAG_TXE is a flag used to indicate that the USART transmit data register is empty.\n// This flag is typically used in USART status register to check if the USART is ready to send more data.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the clock is enabled by setting\n * the appropriate bit in the RCC_AHB1ENR register.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC and the offset for the AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Set the bit 0 in RCC_AHB1ENR to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin number from the pin mask\n    uint8_t pin_number = 0;\n    while ((pin_mask >> pin_number) != 1) {\n        pin_number++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin in the MODER register\n    *GPIO_MODER &= ~(0x3 << (pin_number * 2));\n\n    // Set the mode for the pin (0x1 for output, 0x0 for input)\n    *GPIO_MODER |= (mode << (pin_number * 2));\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin specified by the port base address and pin mask.\n * It calculates the pin position and checks the input data register (IDR) to determine if the pin is high or low.\n * \n * @param port_base_address The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t port_base_address, uint32_t pin_mask) {\n    // Pointer to the input data register (IDR) of the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(port_base_address + 0x10);\n\n    // Calculate the pin position by finding the first set bit in the pin mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the pin state from the IDR and return 1 if high, 0 if low\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It uses bitwise operations to ensure atomic\n * and reliable toggling of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "ff84273b-ed50-4395-9e54-37a836dd48a7",
            "timestamp": "2024-10-18T10:34:35.600155",
            "total time (seconds)": 61.01800060272217,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual, which specifies the offset for the USART_SR register.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x00000008)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// The RCC_AHB1ENR register is used to enable the clock for peripherals connected to the AHB1 bus.\n// The offset is based on the STM32F407 reference manual, which specifies the memory map for the RCC registers.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference manual\n// which specifies the offset for the USART_DR register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// USART_FLAG_TXE is a flag used to indicate that the USART transmit data register is empty.\n// This flag is typically used in USART communication to check if the USART is ready to send more data.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the clock is enabled by setting\n * the appropriate bit in the RCC_AHB1ENR register.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC and the offset for the AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Set the bit 0 of RCC_AHB1ENR to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin position by finding the first set bit in pin_mask\n    uint8_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin position\n    *GPIO_MODER &= ~(0x3 << (pin_position * 2));\n\n    // Set the mode: 0x1 for output, 0x0 for input\n    *GPIO_MODER |= (mode << (pin_position * 2));\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin by accessing the input data register (IDR)\n * of the specified GPIO port. It calculates the bit position of the pin using a loop\n * and returns the state of the pin.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask of the pin to read (e.g., 1 << 5 for pin 5).\n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Pointer to the input data register (IDR) of the GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n\n    // Calculate the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the pin state from the IDR and return it\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It uses bitwise operations to ensure atomic\n * and reliable toggling of the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *ODR ^= pin_mask;\n}\n\n"
        },
        {
            "unique_id": "4c62cbcf-91d6-48aa-9916-317d092af2b3",
            "timestamp": "2024-10-18T10:36:12.801662",
            "total time (seconds)": 87.12514638900757,
            "compilation-success": true,
            "Functioning code Binary": "7",
            "Code": "//typedefs.h \n\n\n// USART_SR_OFFSET is the offset for the Status Register of the USART peripheral.\n// This offset is used to access the status register from the base address of a USART peripheral.\n// The value is derived from the STM32F407 reference manual.\n#define USART_SR_OFFSET ((uint32_t)0x00)\n\n// Define the offset for the Baud Rate Register (BRR) in the USART peripheral.\n// This offset is used to calculate the address of the BRR register for a given USART instance.\n// The value is based on the STM32F407 reference manual, which specifies the register map for USART peripherals.\n#define USART_BRR_OFFSET ((uint32_t)0x08)\n\n// Define the offset for the AHB1 peripheral clock enable register in the RCC\n// This offset is used to access the RCC_AHB1ENR register, which controls the clock\n// for the AHB1 peripherals on the STM32F407 board.\n#define RCC_AHB1ENR_OFFSET ((uint32_t)0x30)\n\n// Define the base address for USART2 peripheral on the STM32F407 board.\n// This address is used to access the USART2 registers for configuration and data transmission.\n// The base address is specific to the STM32F407 microcontroller.\n#define USART2_BASE ((uint32_t)0x40004400)\n\n// Define the offset for the Data Register (DR) of the USART peripheral.\n// This offset is used to access the data register of a USART peripheral\n// on the STM32F407 microcontroller. The value is based on the reference\n// manual for the STM32F407, which specifies the offset for the DR register.\n#define USART_DR_OFFSET ((uint32_t)0x04)\n\n// Base address for the Reset and Clock Control (RCC) peripheral\n#define RCC_BASE ((uint32_t)0x40023800)\n\n// Define the USART_FLAG_TXE variable for the STM32F407 board\n// This flag is used to indicate that the transmit data register is empty\n// and ready to accept new data for transmission. It is a part of the USART\n// status register (USART_SR) and is typically used in USART communication\n// to check if the transmitter is ready to send the next byte of data.\n#define USART_FLAG_TXE ((uint16_t)0x0080)\n\n// Define the offset for the USART_CR1 register in the STM32F407 microcontroller.\n// This offset is used to access the control register 1 of the USART peripheral.\n// The value is hardcoded based on the STM32F407 reference manual.\n#define USART_CR1_OFFSET ((uint32_t)0x000C)\n\n//microcontroller_h.h \n \n\n/**\n * @brief Enables the clock for GPIOA on the STM32F407 board.\n * \n * This function directly manipulates the RCC AHB1 peripheral clock enable register\n * to enable the clock for GPIOA. It ensures that the clock is enabled by setting\n * the appropriate bit in the RCC_AHB1ENR register.\n * \n * @param None\n * @return None\n */\nvoid ENABLE_GPIOA_CLOCK(void) {\n    // Define the base address for the RCC and the offset for the AHB1ENR register\n    volatile uint32_t *RCC_AHB1ENR = (uint32_t *)(0x40023800 + 0x30);\n\n    // Set the bit 0 of RCC_AHB1ENR to enable the clock for GPIOA\n    *RCC_AHB1ENR |= (1 << 0);\n}\n\n\n// Function to set the mode of a GPIO pin as input or output\n// Parameters:\n// - gpio_base: Base address of the GPIO port (e.g., 0x40020000 for GPIOA)\n// - pin_mask: Bitmask representing the pin (e.g., 1 << 5 for pin 5)\n// - mode: 0 for input, 1 for output\nvoid set_input_output_mode(uint32_t gpio_base, uint32_t pin_mask, uint8_t mode) {\n    // Calculate the pin number from the pin mask\n    uint8_t pin_number = 0;\n    while ((pin_mask >> pin_number) != 1) {\n        pin_number++;\n    }\n\n    // Calculate the address of the GPIO mode register (MODER)\n    volatile uint32_t *GPIO_MODER = (uint32_t *)(gpio_base + 0x00);\n\n    // Clear the two bits corresponding to the pin in the MODER register\n    *GPIO_MODER &= ~(0x3 << (pin_number * 2));\n\n    // Set the mode for the pin (0x1 for output, 0x0 for input)\n    *GPIO_MODER |= (mode << (pin_number * 2));\n}\n\n/**\n * @brief Writes a value to a specific GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to set or reset a specific pin. It ensures atomic operations using bitwise operations.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bit mask representing the pin to be written (e.g., 1 << 5 for pin 5).\n * @param value The value to write to the pin (0 for low, 1 for high).\n */\nvoid hardware_abstraction_layer_function_gpio_write_pin(uint32_t gpio_port_base, uint32_t pin_mask, uint32_t value) {\n    // Calculate the address of the Output Data Register (ODR)\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Determine the bit position of the pin\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Write the value to the pin using bitwise operations\n    if (value) {\n        // Set the pin high\n        *ODR |= (1 << pin_position);\n    } else {\n        // Set the pin low\n        *ODR &= ~(1 << pin_position);\n    }\n}\n\n/**\n * @brief Reads the state of a specific GPIO pin.\n * \n * This function reads the state of a GPIO pin by accessing the input data register (IDR)\n * of the specified GPIO port. It calculates the bit position of the pin using a loop\n * to ensure accurate pin configuration.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The mask representing the pin to read (e.g., 1 << 5 for pin 5).\n * \n * @return 1 if the pin is high, 0 if the pin is low.\n */\nint hardware_abstraction_layer_function_gpio_read_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Pointer to the input data register (IDR) of the specified GPIO port\n    volatile uint32_t *GPIO_IDR = (uint32_t *)(gpio_port_base + 0x10);\n\n    // Calculate the pin position by finding the first set bit in the pin_mask\n    uint32_t pin_position = 0;\n    while ((pin_mask >> pin_position) != 1) {\n        pin_position++;\n    }\n\n    // Read the pin state from the IDR and return it\n    return ((*GPIO_IDR & (1 << pin_position)) != 0) ? 1 : 0;\n}\n\n/**\n * @brief Toggles the state of a specified GPIO pin.\n * \n * This function directly manipulates the Output Data Register (ODR) of a GPIO port\n * to toggle the state of a specific pin. It ensures atomic operations using bitwise\n * XOR to flip the pin state.\n * \n * @param gpio_port_base The base address of the GPIO port (e.g., 0x40020000 for GPIOA).\n * @param pin_mask The bitmask representing the pin to toggle (e.g., 1 << 5 for pin 5).\n */\nvoid hardware_abstraction_layer_function_gpio_toggle_pin(uint32_t gpio_port_base, uint32_t pin_mask) {\n    // Calculate the address of the Output Data Register (ODR) for the given GPIO port\n    volatile uint32_t *ODR = (uint32_t *)(gpio_port_base + 0x14);\n\n    // Toggle the pin by XORing the ODR with the pin mask\n    *ODR ^= pin_mask;\n}\n\n"
        }
    ]
}